["```py\nfrom sklearn.datasets import fetch_california_housing\nimport pandas as pd\n\n# Fetch the California housing dataset\ndata = fetch_california_housing()\n\n# Convert the dataset to a Pandas DataFrame\ndf = pd.DataFrame(data.data, columns=data.feature_names)\n\n# Add target column\ndf['MedHouseVal'] = data.target\n```", "```py\nprint(data.DESCR)\n```", "```py\ndf.info()\n```", "```py\nOutput >>>\n\n <class>RangeIndex: 20640 entries, 0 to 20639\nData columns (total 9 columns):\n #   Column   \tNon-Null Count  Dtype  \n---  ------   \t--------------  -----  \n 0   MedInc   \t20640 non-null  float64\n 1   HouseAge \t20640 non-null  float64\n 2   AveRooms \t20640 non-null  float64\n 3   AveBedrms\t20640 non-null  float64\n 4   Population   20640 non-null  float64\n 5   AveOccup \t20640 non-null  float64\n 6   Latitude \t20640 non-null  float64\n 7   Longitude\t20640 non-null  float64\n 8   MedHouseVal  20640 non-null  float64\ndtypes: float64(9)\nmemory usage: 1.4 MB</class>\n```", "```py\ndf.describe()\n```", "```py\n# Check for missing values in the DataFrame\nmissing_values = df.isnull().sum()\nprint(\"Missing Values:\")\nprint(missing_values)\n```", "```py\nOutput >>>\n\nMissing Values:\nMedInc     \t0\nHouseAge   \t0\nAveRooms   \t0\nAveBedrms  \t0\nPopulation \t0\nAveOccup   \t0\nLatitude   \t0\nLongitude  \t0\nMedHouseVal\t0\ndtype: int64\n```", "```py\n# Check for duplicate rows in the DataFrame\nduplicate_rows = df[df.duplicated()]\nprint(\"Duplicate Rows:\")\nprint(duplicate_rows)\n```", "```py\nOutput >>>\n\nDuplicate Rows:\nEmpty DataFrame\nColumns: [MedInc, HouseAge, AveRooms, AveBedrms, Population, AveOccup, Latitude, Longitude, MedHouseVal]\nIndex: []\n```", "```py\n# Check data types of each column in the DataFrame\ndata_types = df.dtypes\nprint(\"Data Types:\")\nprint(data_types)\n```", "```py\nOutput >>>\n\nData Types:\nMedInc     \tfloat64\nHouseAge   \tfloat64\nAveRooms   \tfloat64\nAveBedrms  \tfloat64\nPopulation \tfloat64\nAveOccup   \tfloat64\nLatitude   \tfloat64\nLongitude  \tfloat64\nMedHouseVal\tfloat64\ndtype: object\n```", "```py\ncolumns_to_check = ['MedInc', 'AveRooms', 'AveBedrms', 'Population']\n\n# Function to find records with outliers\ndef find_outliers_pandas(data, column):\n\tQ1 = data[column].quantile(0.25)\n\tQ3 = data[column].quantile(0.75)\n\tIQR = Q3 - Q1\n\tlower_bound = Q1 - 1.5 * IQR\n\tupper_bound = Q3 + 1.5 * IQR\n\toutliers = data[(data[column] < lower_bound) | (data[column] > upper_bound)]\n\treturn outliers\n\n# Find records with outliers for each specified column\noutliers_dict = {}\n\nfor column in columns_to_check:\n\toutliers_dict[column] = find_outliers_pandas(df, column)\n\n# Print the records with outliers for each column\nfor column, outliers in outliers_dict.items():\n\tprint(f\"Outliers in '{column}':\")\n\tprint(outliers)\n\tprint(\"\\n\")\n```", "```py\n# Check numerical value range for the 'MedInc' column\nvalid_range = (0, 16)  \nvalue_range_check = df[~df['MedInc'].between(*valid_range)]\nprint(\"Value Range Check (MedInc):\")\nprint(value_range_check)\n```", "```py\nOutput >>>\n\nValue Range Check (MedInc):\nEmpty DataFrame\nColumns: [MedInc, HouseAge, AveRooms, AveBedrms, Population, AveOccup, Latitude, Longitude, MedHouseVal]\nIndex: []\n```", "```py\n# AveRooms should not be smaller than AveBedrooms\ninvalid_data = df[df['AveRooms'] < df['AveBedrms']]\nprint(\"Invalid Records (AveRooms < AveBedrms):\")\nprint(invalid_data)\n```", "```py\nOutput >>>\n\nInvalid Records (AveRooms < AveBedrms):\nEmpty DataFrame\nColumns: [MedInc, HouseAge, AveRooms, AveBedrms, Population, AveOccup, Latitude, Longitude, MedHouseVal]\nIndex: []\n```", "```py\nimport pandas as pd\nimport re\n\ndata = {'Date': ['2023-10-29', '2023-11-15', '23-10-2023', '2023/10/29', '2023-10-30']}\ndf = pd.DataFrame(data)\n\n# Define the expected date format\ndate_format_pattern = r'^\\d{4}-\\d{2}-\\d{2}$'  # YYYY-MM-DD format\n\n# Function to check if a date value matches the expected format\ndef check_date_format(date_str, date_format_pattern):\n\treturn re.match(date_format_pattern, date_str) is not None\n\n# Apply the format check to the 'Date' column\ndate_format_check = df['Date'].apply(lambda x: check_date_format(x, date_format_pattern))\n\n# Identify and retrieve entries that do not follow the expected format\nnon_adherent_dates = df[~date_format_check]\n\nif not non_adherent_dates.empty:\n\tprint(\"Entries that do not follow the expected format:\")\n\tprint(non_adherent_dates)\nelse:\n\tprint(\"All dates are in the expected format.\")\n```", "```py\nOutput >>>\n\nEntries that do not follow the expected format:\n     \tDate\n2  23-10-2023\n3  2023/10/29\n```"]