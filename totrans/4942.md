# 道路车道线检测使用计算机视觉模型

> 原文：[https://www.kdnuggets.com/2017/07/road-lane-line-detection-using-computer-vision-models.html](https://www.kdnuggets.com/2017/07/road-lane-line-detection-using-computer-vision-models.html)

**作者：Vijay Ramakrishnan**。

检测车道线是自动驾驶车辆在道路上行驶的基本任务。它是其他路径规划和控制动作（如制动和转向）的基础。让我们开始实现它们吧！

* * *

## 我们的前三个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织的 IT

* * *

![](../Images/7a992963ff20ff065c613a4986e26864.png)

**图 1\. 本项目的最终输出**

> 注意：该项目来源于 [Udacity 博客](https://github.com/udacity/CarND-LaneLines-P1)。所有生成的媒体都使用了本文中解释的自定义 CV 配置。

**步骤 0：介绍**

在我们处理视频之前，先处理静态图像，因为这样更容易调试。这里是我们将要处理的图像。

![](../Images/e8f072f35ceec435a7d0e66babd21c0d.png)

***图. 输入图像***

我在 jupyter notebook 中运行 python 3，导入了以下库：

```py
---------------------------------------------------------------------------
#importing some useful packages
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np
import cv2
import math
import sys
%matplotlib inline

```

```py
---------------------------------------------------------------------------
```

车道检测管道遵循以下步骤：

1.  使用灰度化和高斯模糊预处理图像

1.  对图像应用 Canny 边缘检测

1.  对图像应用掩膜区域

1.  对图像应用霍夫变换

1.  外推霍夫变换中找到的线条，以构造左车道线和右车道线

1.  将外推的线条添加到输入图像中

**步骤 1：图像预处理**

我们对输入图像进行灰度处理，这对于 Canny 边缘检测是必要的。

```py
---------------------------------------------------------------------------
```

```py
def grayscale(img):
    """Applies the Grayscale transform
    This will return an image with only one color channel
    but NOTE: to see the returned image as grayscale
    you should call plt.imshow(gray, cmap='gray')"""
    return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

image = mpimg.imread('test_images/solidYellowCurve2.jpg')
# grayscale the image
grayscaled = grayscale(image)
plt.imshow(grayscaled, cmap='gray')
```

```py
---------------------------------------------------------------------------
```

![](../Images/3890713a560d8e34476af175fcf028a9.png)

***图. 灰度图像***

然后我们对图像应用高斯平滑函数。这对于 Canny 边缘检测是必要的，可以平均掉图像中异常的梯度。

```py
---------------------------------------------------------------------------
```

```py
def gaussian_blur(img, kernel_size):
    """Applies a Gaussian Noise kernel"""
    return cv2.GaussianBlur(img, (kernel_size, kernel_size), 0)

# apply gaussian blur
kernelSize = 5
gaussianBlur = gaussian_blur(grayscaled, kernelSize)

```

```py
---------------------------------------------------------------------------
```

**步骤 2：Canny 边缘检测**

我们需要检测车道边缘，因为车道与周围路面之间的对比为我们提供了有用的车道线检测信息。

Canny 边缘检测是一种使用图像像素值的水平和垂直梯度来检测边缘的操作符。对该算法的更深入理解可以在 [这里](http://docs.opencv.org/trunk/da/d22/tutorial_py_canny.html)找到。

```py
---------------------------------------------------------------------------
```

```py
def canny(img, low_threshold, high_threshold):
    """Applies the Canny transform"""
    return cv2.Canny(img, low_threshold, high_threshold)

# canny
minThreshold = 100
maxThreshold = 200
edgeDetectedImage = canny(gaussianBlur, minThreshold, maxThreshold)

```

```py
---------------------------------------------------------------------------
```

![](../Images/8e9646d2efb5b21233e6fae0a2961584.png)

*注意边缘检测器捕捉到了所有车道线，以及如树木等周围的边缘*

**步骤 3: 遮蔽出不在关注区域中的点**

汽车摄像头的关注区域仅包括视野范围内的两条车道，而不包括其他任何外部区域。我们可以通过创建一个多边形关注区域并移除所有不在该多边形中的像素来过滤掉外部像素。

```py
---------------------------------------------------------------------------
```

```py
def region_of_interest(img, vertices):
    """
    Applies an image mask.

    Only keeps the region of the image defined by the polygon
    formed from `vertices`. The rest of the image is set to black.
    """
    #defining a blank mask to start with
    mask = np.zeros_like(img)   

    #defining a 3 channel or 1 channel color to fill the mask with 
    #depending on the input image
    if len(img.shape) > 2:
        channel_count = img.shape[2]  # i.e. 3 or 4 depending on your image
        ignore_mask_color = (255,) * channel_count
    else:
        ignore_mask_color = 255

    #filling pixels inside the polygon defined by "vertices" with the fill color    
    cv2.fillPoly(mask, vertices, ignore_mask_color)

    #returning the image only where mask pixels are nonzero
    masked_image = cv2.bitwise_and(img, mask)
    return masked_image

#apply mask
lowerLeftPoint = [130, 540]
upperLeftPoint = [410, 350]
upperRightPoint = [570, 350]
lowerRightPoint = [915, 540]

pts = np.array([[lowerLeftPoint, upperLeftPoint, upperRightPoint, 
lowerRightPoint]], dtype=np.int32)
masked_image = region_of_interest(edgeDetectedImage, pts)

```

```py
---------------------------------------------------------------------------
```

![](../Images/1fa94ca382f7d5cc7aff7f61ec5738e7.png)

***图示：移除所有不在关注区域中的像素***

**步骤 4: 霍夫变换**

现在我们已经在关注区域中检测到边缘，我们要识别指示车道线的直线。这时，霍夫变换就派上用场了。

霍夫变换将“x 对 y”线转换为“梯度对截距”空间中的一个点。图像中的点将对应于霍夫空间中的直线。霍夫空间中的直线交点将对应于笛卡尔空间中的一条直线。通过这种技术，我们可以从 Canny 边缘检测输出的像素中找到直线。有关霍夫变换的详细解释，请点击这里。

```py
---------------------------------------------------------------------------
```

```py
def hough_lines(img, rho, theta, threshold, min_line_len, max_line_gap):
    """
    `img` should be the output of a Canny transform.

    Returns an image with hough lines drawn.
    """
    lines = cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), 
              minLineLength=min_line_len, maxLineGap=max_line_gap)
    line_img = np.zeros((*img.shape, 3), dtype=np.uint8)

    draw_lines(line_img, lines)
    return line_img

def draw_lines(img, lines, color=[255, 0, 0], thickness=2):
    """
    This function draws `lines` with `color` and `thickness`.    
    """
    for line in lines:
        for x1,y1,x2,y2 in line:
            cv2.line(img, (x1, y1), (x2, y2), color, thickness)

#hough lines
rho = 1
theta = np.pi/180
threshold = 30
min_line_len = 20 
max_line_gap = 20

houged = hough_lines(masked_image, rho, theta, 
                  threshold, min_line_len, max_line_gap)

```

```py
---------------------------------------------------------------------------
```

### 更多相关主题

+   [DINOv2: Meta AI 的自监督计算机视觉模型](https://www.kdnuggets.com/2023/05/dinov2-selfsupervised-computer-vision-models-meta-ai.html)

+   [TensorFlow 计算机视觉 - 轻松掌握迁移学习](https://www.kdnuggets.com/2022/01/tensorflow-computer-vision-transfer-learning-made-easy.html)

+   [探索计算机视觉的世界：介绍MLM的最新…](https://www.kdnuggets.com/2024/01/mlm-discover-the-world-of-computer-vision-ebook)

+   [计算机视觉的 5 个应用](https://www.kdnuggets.com/2022/03/5-applications-computer-vision.html)

+   [数据管理的 6 件事及其重要性…](https://www.kdnuggets.com/2022/05/6-things-need-know-data-management-matters-computer-vision.html)

+   [KDnuggets 新闻 2022年3月9日：在 5 步中构建机器学习网络应用](https://www.kdnuggets.com/2022/n10.html)
