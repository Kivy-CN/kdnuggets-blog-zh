["```py\nimport numpy as np\nimport pandas as pd\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style('darkgrid', {'axes.facecolor': '.9'})\nsns.set_palette(palette='deep')\nsns_c = sns.color_palette(palette='deep')\n%matplotlib inline\n\nfrom pandas.plotting import register_matplotlib_converters\nregister_matplotlib_converters()\n```", "```py\n# Set random state. \nrs = np.random.seed(25)\n\ndef generate_circle_sample_data(r, n, sigma):\n    \"\"\"Generate circle data with random Gaussian noise.\"\"\"\n    angles = np.random.uniform(low=0, high=2*np.pi, size=n)\n\n    x_epsilon = np.random.normal(loc=0.0, scale=sigma, size=n)\n    y_epsilon = np.random.normal(loc=0.0, scale=sigma, size=n)\n\n    x = r*np.cos(angles) + x_epsilon\n    y = r*np.sin(angles) + y_epsilon\n    return x, y\n\ndef generate_concentric_circles_data(param_list):\n    \"\"\"Generates many circle data with random Gaussian noise.\"\"\"\n    coordinates = [ \n        generate_circle_sample_data(param[0], param[1], param[2])\n     for param in param_list\n    ]\n    return coordinates\n```", "```py\n# Set global plot parameters. \nplt.rcParams['figure.figsize'] = [8, 8]\nplt.rcParams['figure.dpi'] = 80\n\n# Number of points per circle. \nn = 1000\n# Radius. \nr_list =[2, 4, 6]\n# Standar deviation (Gaussian noise). \nsigmas = [0.1, 0.25, 0.5]\n\nparam_lists = [[(r, n, sigma) for r in r_list] for sigma in sigmas] \n# We store the data on this list.\ncoordinates_list = []\n\nfig, axes = plt.subplots(3, 1, figsize=(7, 21))\n\nfor i, param_list in enumerate(param_lists):\n\n    coordinates = generate_concentric_circles_data(param_list)\n\n    coordinates_list.append(coordinates)\n\n    ax = axes[i]\n\n    for j in range(0, len(coordinates)):\n\n        x, y = coordinates[j]\n        sns.scatterplot(x=x, y=y, color='black', ax=ax)\n        ax.set(title=f'$\\sigma$ = {param_list[0][2]}')\n\nplt.tight_layout()\n```", "```py\nfrom itertools import chain\n\ncoordinates = coordinates_list[0]\n\ndef data_frame_from_coordinates(coordinates): \n    \"\"\"From coordinates to data frame.\"\"\"\n    xs = chain(*[c[0] for c in coordinates])\n    ys = chain(*[c[1] for c in coordinates])\n\n    return pd.DataFrame(data={'x': xs, 'y': ys})\n\ndata_df = data_frame_from_coordinates(coordinates)\n\n# Plot the input data.\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', color='black', data=data_df, ax=ax)\nax.set(title='Input Data');\n```", "```py\nfrom sklearn.cluster import KMeans\n\ninertias = []\n\nk_candidates = range(1, 10)\n\nfor k in k_candidates:\n    k_means = KMeans(random_state=42, n_clusters=k)\n    k_means.fit(data_df)\n    inertias.append(k_means.inertia_)\n\nfig, ax = plt.subplots(figsize=(10, 6))\nsns.scatterplot(x=k_candidates, y = inertias, s=80, ax=ax)\nsns.scatterplot(x=[k_candidates[2]], y = [inertias[2]], color=sns_c[3], s=150, ax=ax)\nsns.lineplot(x=k_candidates, y = inertias, alpha=0.5, ax=ax)\nax.set(title='Inertia K-Means', ylabel='inertia', xlabel='k');\n```", "```py\nk_means = KMeans(random_state=25, n_clusters=3)\nk_means.fit(data_df)\ncluster = k_means.predict(data_df)\n\ncluster = ['k-means_c_' + str(c) for c in cluster]\n\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', data=data_df.assign(cluster = cluster), hue='cluster', ax=ax)\nax.set(title='K-Means Clustering');\n```", "```py\nfrom sklearn.neighbors import kneighbors_graph\nfrom scipy import sparse\n\ndef generate_graph_laplacian(df, nn):\n    \"\"\"Generate graph Laplacian from data.\"\"\"\n    # Adjacency Matrix.\n    connectivity = kneighbors_graph(X=df, n_neighbors=nn, mode='connectivity')\n    adjacency_matrix_s = (1/2)*(connectivity + connectivity.T)\n    # Graph Laplacian.\n    graph_laplacian_s = sparse.csgraph.laplacian(csgraph=adjacency_matrix_s, normed=False)\n    graph_laplacian = graph_laplacian_s.toarray()\n    return graph_laplacian \n\ngraph_laplacian = generate_graph_laplacian(df=data_df, nn=8)\n\n# Plot the graph Laplacian as heat map.\nfig, ax = plt.subplots(figsize=(10, 8))\nsns.heatmap(graph_laplacian, ax=ax, cmap='viridis_r')\nax.set(title='Graph Laplacian');\n```", "```py\nfrom scipy import linalg\n\neigenvals, eigenvcts = linalg.eig(graph_laplacian)\n```", "```py\nnp.unique(np.imag(eigenvals))\n```", "```py\narray([0.])\n```", "```py\n# We project onto the real numbers. \ndef compute_spectrum_graph_laplacian(graph_laplacian):\n    \"\"\"Compute eigenvalues and eigenvectors and project \n    them onto the real numbers.\n    \"\"\"\n    eigenvals, eigenvcts = linalg.eig(graph_laplacian)\n    eigenvals = np.real(eigenvals)\n    eigenvcts = np.real(eigenvcts)\n    return eigenvals, eigenvcts\n\neigenvals, eigenvcts = compute_spectrum_graph_laplacian(graph_laplacian)\n```", "```py\neigenvcts_norms = np.apply_along_axis(\n  lambda v: np.linalg.norm(v, ord=2), \n  axis=0, \n  arr=eigenvcts\n)\n\nprint('Min Norm: ' + str(eigenvcts_norms.min()))\nprint('Max Norm: ' + str(eigenvcts_norms.max()))\n```", "```py\nMin Norm: 0.9999999999999997\nMax Norm: 1.0000000000000002\n```", "```py\neigenvals_sorted_indices = np.argsort(eigenvals)\neigenvals_sorted = eigenvals[eigenvals_sorted_indices]\n```", "```py\nfig, ax = plt.subplots(figsize=(10, 6))\nsns.lineplot(x=range(1, eigenvals_sorted_indices.size + 1), y=eigenvals_sorted, ax=ax)\nax.set(title='Sorted Eigenvalues Graph Laplacian', xlabel='index', ylabel=r'$\\lambda$');\n```", "```py\nindex_lim = 10\n\nfig, ax = plt.subplots(figsize=(10, 6))\nsns.scatterplot(x=range(1, eigenvals_sorted_indices[: index_lim].size + 1), y=eigenvals_sorted[: index_lim], s=80, ax=ax)\nsns.lineplot(x=range(1, eigenvals_sorted_indices[: index_lim].size + 1), y=eigenvals_sorted[: index_lim], alpha=0.5, ax=ax)\nax.axvline(x=3, color=sns_c[3], label='zero eigenvalues', linestyle='--')\nax.legend()\nax.set(title=f'Sorted Eigenvalues Graph Laplacian (First {index_lim})', xlabel='index', ylabel=r'$\\lambda$');\n```", "```py\nzero_eigenvals_index = np.argwhere(abs(eigenvals) < 1e-5)\neigenvals[zero_eigenvals_index]\n```", "```py\narray([[-9.42076177e-16],\n       [ 8.21825247e-16],\n       [ 5.97249344e-16]])\n```", "```py\nproj_df = pd.DataFrame(eigenvcts[:, zero_eigenvals_index.squeeze()])\nproj_df.columns = ['v_' + str(c) for c in proj_df.columns]\nproj_df.head()\n```", "```py\nfig, ax = plt.subplots(figsize=(10, 8))\nsns.heatmap(proj_df, ax=ax, cmap='viridis_r')\nax.set(title='Eigenvectors Generating the Kernel of the Graph Laplacian');\n```", "```py\ndef project_and_transpose(eigenvals, eigenvcts, num_ev):\n    \"\"\"Select the eigenvectors corresponding to the first \n    (sorted) num_ev eigenvalues as columns in a data frame.\n    \"\"\"\n    eigenvals_sorted_indices = np.argsort(eigenvals)\n    indices = eigenvals_sorted_indices[: num_ev]\n\n    proj_df = pd.DataFrame(eigenvcts[:, indices.squeeze()])\n    proj_df.columns = ['v_' + str(c) for c in proj_df.columns]\n    return proj_df\n```", "```py\ninertias = []\n\nk_candidates = range(1, 6)\n\nfor k in k_candidates:\n    k_means = KMeans(random_state=42, n_clusters=k)\n    k_means.fit(proj_df)\n    inertias.append(k_means.inertia_)\n```", "```py\nfig, ax = plt.subplots(figsize=(10, 6))\nsns.scatterplot(x=k_candidates, y = inertias, s=80, ax=ax)\nsns.lineplot(x=k_candidates, y = inertias, alpha=0.5, ax=ax)\nax.set(title='Inertia K-Means', ylabel='inertia', xlabel='k');\n```", "```py\ndef run_k_means(df, n_clusters):\n    \"\"\"K-means clustering.\"\"\"\n    k_means = KMeans(random_state=25, n_clusters=n_clusters)\n    k_means.fit(df)\n    cluster = k_means.predict(df)\n    return cluster\n\ncluster = run_k_means(proj_df, n_clusters=3)\n```", "```py\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.scatter(\n    xs=proj_df['v_0'], \n    ys=proj_df['v_1'], \n    zs=proj_df['v_2'],\n    c=[{0: sns_c[0], 1: sns_c[1], 2: sns_c[2]}.get(c) for c in cluster]\n)\nax.set_title('Small Eigenvectors Clusters', x=0.2);\n```", "```py\ndata_df['cluster'] = ['c_' + str(c) for c in cluster]\n\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', data=data_df, hue='cluster', ax=ax)\nax.set(title='Spectral Clustering');\n```", "```py\ndef spectral_clustering(df, n_neighbors, n_clusters):\n    \"\"\"Spectral Clustering Algorithm.\"\"\"\n    graph_laplacian = generate_graph_laplacian(df, n_neighbors)\n    eigenvals, eigenvcts = compute_spectrum_graph_laplacian(graph_laplacian)\n    proj_df = project_and_transpose(eigenvals, eigenvcts, n_clusters)\n    cluster = run_k_means(proj_df, proj_df.columns.size)\n    return ['c_' + str(c) for c in cluster]\n```", "```py\ndata_df = data_frame_from_coordinates(coordinates_list[1])\ndata_df['cluster'] = spectral_clustering(df=data_df, n_neighbors=8, n_clusters=3)\n\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', data=data_df, hue='cluster', ax=ax)\nax.set(title='Spectral Clustering');\n```", "```py\ndata_df = data_frame_from_coordinates(coordinates_list[1])\ndata_df['cluster'] = spectral_clustering(df=data_df, n_neighbors=8, n_clusters=2)\n\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', data=data_df, hue='cluster', ax=ax)\nax.set(title='Spectral Clustering');\n```", "```py\ndata_df = data_frame_from_coordinates(coordinates_list[2])\ndata_df['cluster'] = spectral_clustering(df=data_df, n_neighbors=8, n_clusters=3)\n\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', data=data_df, hue='cluster', ax=ax)\nax.set(title='Spectral Clustering');\n```", "```py\nfrom sklearn.cluster import SpectralClustering\n\ndata_df = data_frame_from_coordinates(coordinates_list[1])\n\nspec_cl = SpectralClustering(\n    n_clusters=3, \n    random_state=25, \n    n_neighbors=8, \n    affinity='nearest_neighbors'\n)\n\ndata_df['cluster'] = spec_cl.fit_predict(data_df[['x', 'y']])\ndata_df['cluster'] = ['c_' + str(c) for c in data_df['cluster']]\n\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', data=data_df, hue='cluster', ax=ax)\nax.set(title='Spectral Clustering - Scikit Learn');\n```", "```py\ndata_df = data_frame_from_coordinates(coordinates_list[2])\n\nspec_cl = SpectralClustering(\n    n_clusters=3, \n    random_state=42, \n    n_neighbors=8, \n    affinity='nearest_neighbors'\n)\n\ndata_df['cluster'] = spec_cl.fit_predict(data_df[['x', 'y']])\ndata_df['cluster'] = ['c_' + str(c) for c in data_df['cluster']]\n\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', data=data_df, hue='cluster', ax=ax)\nax.set(title='Spectral Clustering - Scikit Learn');\n```", "```py\ndata_df = data_frame_from_coordinates(coordinates_list[1])\n\ndata_df = data_df.assign(r2 = lambda x: np.power(x['x'], 2) + np.power(x['y'], 2))\n```", "```py\nfig, ax = plt.subplots()\nsns.scatterplot(x='r2', y='r2', color='black', data=data_df, ax=ax)\nax.set(title='Radius Feature');\n```", "```py\ninertias = []\n\nk_candidates = range(1, 10)\n\nfor k in k_candidates:\n    k_means = KMeans(random_state=42, n_clusters=k)\n    k_means.fit(data_df[['r2']])\n    inertias.append(k_means.inertia_)\n\nfig, ax = plt.subplots(figsize=(10, 6))\nsns.scatterplot(x=k_candidates, y = inertias, s=80, ax=ax)\nsns.scatterplot(x=[k_candidates[2]], y = [inertias[2]], color=sns_c[3], s=150, ax=ax)\nsns.lineplot(x=k_candidates, y = inertias, alpha=0.5, ax=ax)\nax.set(title='Inertia K-Means', ylabel='inertia', xlabel='k');\n```", "```py\nk_means = KMeans(random_state=25, n_clusters=3)\nk_means.fit(data_df[['r2']])\ncluster = k_means.predict(data_df[['r2']])\n\ndata_df = data_df.assign(cluster = ['k-means_c_' + str(c) for c in cluster])\n\nfig, ax = plt.subplots()\nsns.scatterplot(x='r2', y='r2', hue='cluster', data=data_df, ax=ax)\nax.set(title='Radius Feature (K-Means)');\n```", "```py\nfig, ax = plt.subplots()\nsns.scatterplot(x='x', y='y', hue='cluster', data=data_df, ax=ax)\nax.set(title='Radius Feature (K-Means)');\n```"]