# 谁是你的“金蛋鸡”？：群体分析

> 原文：[https://www.kdnuggets.com/2019/05/golden-goose-cohort-analysis.html](https://www.kdnuggets.com/2019/05/golden-goose-cohort-analysis.html)

![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [评论](/2019/05/golden-goose-cohort-analysis.html/2#comments)

**由 [Jiwon Jeong](https://www.linkedin.com/in/jiwon-jeong/)，延世大学的研究生助理**

客户细分是将客户根据其购买模式划分为不同组的技术，以识别最有利可图的组。在细分客户时，可以根据市场使用各种标准，例如地理位置、人口统计特征或行为基础。这种技术假设具有不同特征的组需要不同的营销方法，并希望找出那些可以最大程度提高盈利能力的组。

今天，我们将讨论如何使用 [UCI ML repo](https://www.kaggle.com/jihyeseo/online-retail-data-set-from-uci-ml-repo) 的 [在线零售数据集](https://www.kaggle.com/jihyeseo/online-retail-data-set-from-uci-ml-repo) 进行客户细分分析。此分析将集中于两个步骤：获取 RFM 值和使用 K-means 算法进行聚类。数据集和完整代码也可以在我的 [Github](https://github.com/jjone36/Cohort/blob/master/Cohort_Anaylsis_Medium.ipynb) 上找到。本笔记的原始资源来自课程 “[Python中的客户细分分析](https://www.datacamp.com/courses/customer-segmentation-in-python)”。

### 什么是 RFM？

RFM 是最近性、频率和货币的缩写。**最近性**是指客户的最后一次订单时间。它表示自客户上一次购买以来的天数。如果是网站或应用程序，这可以解释为最后一次访问的日期或最后一次登录时间。

**频率**是指在特定时间段内的购买次数。时间段可以是 3 个月、6 个月或 1 年。所以我们可以理解这个值为客户使用公司产品的频繁程度或次数。值越大，客户的参与度就越高。我们可以称他们为 VIP 吗？不一定。因为我们还需要考虑他们每次购买实际支付了多少，这意味着货币价值。

**货币**是指客户在给定时间段内花费的总金额。因此，大支出者将与其他客户区分开来，如 MVP 或 VIP。

![图](../Images/3425b2287bfac7a1cfbe638805f406cb.png)

图片来源：CleverTap

这三个值是群体分析中常用的量化因素。由于它们简单直观的概念，它们在其他客户细分方法中也很受欢迎。

### 导入数据

今天我们将把 RFM 应用于我们的群体分析。我们将使用的数据集是从 2010 年 1 月到 2011 年 9 月的交易历史数据。由于这是一个关于群体分析的教程指南，我将只使用原始数据集的随机选择部分。

```py
# Import data
online = pd.read_excel('Online Retail.xlsx')
# drop the row missing customer ID 
online = online[online.CustomerID.notnull()]
online = online.sample(frac = .3).reset_index(drop = True)
online.head()

```

![导入 rfm 数据](../Images/82ba67ed2348ffcb5e56742d2640f096.png)

### 计算 RFM 值

我们首先要计算的是近期值，即自客户上次订单以来的天数。我们可以从哪个列中获得这个值？ **InvoiceData**。通过这一列，我们可以得到客户的首次购买和最后一次购买的时间。我们将首次购买称为 **CohortDay**。由于**InvoiceDate** 还包含额外的时间数据，我们需要提取年份、月份和日期部分。之后，我们将得到**CohortDay**，它是**InvoiceDay**的最小值。

```py
# extract year, month and day
online['InvoiceDay'] = online.InvoiceDate.apply(lambda x: dt.datetime(x.year, x.month, x.day))
online.head()
```

![计算 rfm 值](../Images/5a33209e8858b432108dd99ae9c19301.png)

由于我们随机选择了数据的子集，我们还需要了解数据的时间范围。如你所见，数据集的最后一天是 2011 年 12 月 9 日。因此，将 12 月 10 日设置为我们的基准日期，并从每个客户的最新购买日期向回计算天数。这将是近期值。

```py
 # print the time period
print('Min : {}, Max : {}'.format(min(online.InvoiceDay), max(online.InvoiceDay)))

```

![图示](../Images/14ab7f9a8d69a837a9d3ac8359fbe2dd.png)

```py
# pin the last date
pin_date = max(online.InvoiceDay) + dt.timedelta(1)

```

在计算近期值之前，让我们提前计算一个额外的值，即每个客户花费的总金额。这是为了计算货币价值。我们如何得到这个值？很简单！在每一行中，将产品价格与订单数量相乘即可。

```py
# Create total spend dataframe
online['TotalSum'] = online.Quantity * online.UnitPrice
online.head()
```

![总花费数据框](../Images/fb9408756d1642695f6129e79e9076bd.png)

现在我们准备一次性获得三个 RFM 值。我将为每个客户分组数据，并分别汇总每个近期值、频率值和货币值。

```py
# calculate RFM values
rfm = online.groupby('CustomerID').agg({
    'InvoiceDate' : lambda x: (pin_date - x.max()).days,
    'InvoiceNo' : 'count', 
    'TotalSum' : 'sum'})
# rename the columns
rfm.rename(columns = {'InvoiceDate' : 'Recency', 
                      'InvoiceNo' : 'Frequency', 
                      'TotalSum' : 'Monetary'}, inplace = True)
rfm.head()

```

![RFM 表](../Images/312a3e54cb8f148d479933ff79cf8817.png)

### RFM 四分位数

现在我们将根据 RFM 值对客户进行分组。由于这些值是连续的，我们也可以使用分位数值并将其划分为 4 组。

```py
# create labels and assign them to tree percentile groups 
r_labels = range(4, 0, -1)
r_groups = pd.qcut(rfm.Recency, q = 4, labels = r_labels)
f_labels = range(1, 5)
f_groups = pd.qcut(rfm.Frequency, q = 4, labels = f_labels)
m_labels = range(1, 5)
m_groups = pd.qcut(rfm.Monetary, q = 4, labels = m_labels)

```

请特别注意 `r_labels`。我按降序给出了标签。为什么？因为近期值表示自客户最后一次订单以来经过的时间。因此，值越小，客户对品牌的参与度越高。现在让我们创建一个新列来指示组标签。

```py
# make a new column for group labels
rfm['R'] = r_groups.values
rfm['F'] = f_groups.values
rfm['M'] = m_groups.values
# sum up the three columns
rfm['RFM_Segment'] = rfm.apply(lambda x: str(x['R']) + str(x['F']) + str(x['M']), axis = 1)
rfm['RFM_Score'] = rfm[['R', 'F', 'M']].sum(axis = 1)
rfm.head()

```

![RFM 分段](../Images/7998d13c65a432e39e4cae794cadebd1.png)

我将所有三个标签附加在一个单元格中，命名为 `RFM_Segment`。这样，我们可以轻松检查客户属于哪个级别或分段。`RFM_Score` 是三个值的总和。它不一定是总和，平均值也是可能的。此外，我们还可以通过该得分来捕捉进一步的模式，例如近期值、频率和货币值的平均值或计数，如下所示。

```py
# calculate average values for each RFM
rfm_agg = rfm.groupby('RFM_Score').agg({
    'Recency' : 'mean',
    'Frequency' : 'mean',
    'Monetary' : ['mean', 'count']
})
rfm_agg.round(1).head()

```

![RFM_score](../Images/066155e851839111bdb97293bdb92917.png)

`RFM_Score` 将是客户参与度或忠诚度的总分。将三个值加总在一起，我们最终可以将客户分类为‘金牌’，‘银牌’，‘铜牌’，和‘绿牌’。

```py
# assign labels from total score
score_labels = ['Green', 'Bronze', 'Silver', 'Gold']
score_groups = pd.qcut(rfm.RFM_Score, q = 4, labels = score_labels)
rfm['RFM_Level'] = score_groups.values
rfm.head()

```

![使用 RFM 值的群体分析](../Images/18d7bfac61225ee0d20d57b5a7a7b654.png)

太好了！我们完成了一个 RFM 值的群体分析。我们识别出了我们的“金鸡母”以及需要额外关注的地方。现在，我们为什么不尝试不同的方法进行客户分段，并比较这两种结果呢？

* * *

## 我们的三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织的 IT 工作

* * *

### 更多相关内容

+   [最后召集：Stefan Krawcyzk 的《掌握 MLOps》现场课程](https://www.kdnuggets.com/2022/08/sphere-last-call-stefan-krawcyzk-mastering-mlops.html)

+   [使用聚类分析对数据进行分段](https://www.kdnuggets.com/using-cluster-analysis-to-segment-your-data)

+   [文本分类任务的最佳架构：基准测试…](https://www.kdnuggets.com/2023/04/best-architecture-text-classification-task-benchmarking-options.html)

+   [市场数据与新闻：时间序列分析](https://www.kdnuggets.com/2022/06/market-data-news-time-series-analysis.html)

+   [最佳 Python 课程：分析总结](https://www.kdnuggets.com/2022/01/best-python-courses-analysis-summary.html)

+   [机器学习的甜蜜点：NLP 和文档分析中的纯方法](https://www.kdnuggets.com/2022/05/machine-learning-sweet-spot-pure-approaches-nlp-document-analysis.html)
