- en: 'SQL For Data Science: Understanding and Leveraging Joins'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2023/08/sql-data-science-understanding-leveraging-joins.html](https://www.kdnuggets.com/2023/08/sql-data-science-understanding-leveraging-joins.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/86deadfbec258a1269997f42cd07dad7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Data science is an interdisciplinary field that relies heavily on extracting
    insights and making informed decisions from vast amounts of data. One of the fundamental
    tools in a data scientist's toolbox is SQL (Structured Query Language), a programming
    language designed for managing and manipulating relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this article, I will focus on one of the most powerful features of SQL:
    joins.'
  prefs: []
  type: TYPE_NORMAL
- en: What Are Joins in SQL?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL Joins allow you to combine data from multiple database tables based on common
    columns. That way, you can merge information together and create meaningful connections
    between related datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Joins in SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several [types of SQL joins](https://www.stratascratch.com/blog/different-types-of-sql-joins-that-you-must-know/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins):'
  prefs: []
  type: TYPE_NORMAL
- en: Inner join
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left outer join
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right outer join
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full outer join
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross join
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explain each type.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Inner Join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An inner join returns only the rows where there is a match in both tables being
    joined. It combines rows from two tables based on a shared key or column, discarding
    non-matching rows.
  prefs: []
  type: TYPE_NORMAL
- en: We visualize this in the following way.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/44d24b263f1f47b1285c60cc487cdfe3.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, this type of join is performed using the keywords JOIN or INNER JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Left Outer Join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A left outer join returns all the rows from the left (or first) table and the
    matched rows from the right (or second) table. If there is no match, it returns
    NULL values for the columns from the right table.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/24697b8483d2b05b9ad49a9b2438a346.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: When wanting to use this join in SQL, you can do that by using LEFT OUTER JOIN
    or LEFT JOIN keywords. Here’s an article that talks about [left join vs left outer
    join](https://www.stratascratch.com/blog/similarities-and-differences-left-join-vs-left-outer-join/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins).
  prefs: []
  type: TYPE_NORMAL
- en: SQL Right Outer Join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A right join is the opposite of a left join. It returns all the rows from the
    right table and the matched rows from the left table. If there is no match, it
    returns NULL values for the columns from the left table.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/b14a0d784cea5dc2682df16e97553195.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, this join type is performed using the keywords RIGHT OUTER JOIN or RIGHT
    JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Full Outer Join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A full outer join returns all the rows from both tables, matching rows where
    possible and filling in NULL values for non-matching rows.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/8ece26dd3f0c639286ddc64df5ae448e.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The keywords in SQL for this join are FULL OUTER JOIN or FULL JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Cross Join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of join combines all the rows from one table with all the rows from
    the second table. In other words, it returns the Cartesian product, i.e., all
    possible combinations of the two tables’ rows.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the visualization that will make it easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/8b9fe0b7a1fb44e74c1f71edd99cdb6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: When cross-joining in SQL, the keyword is CROSS JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SQL Join Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform a join in SQL, you need to specify the tables we want to join, the
    columns used for matching, and the type of join we want to perform. The basic
    syntax for joining tables in SQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how to use JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: You reference the first (or left) table in the FROM clause. Then you follow
    it with JOIN and reference the second (or right) table.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the joining condition in the ON clause. This is where you specify
    which columns you’ll use to join the two tables. Usually, it’s a shared column
    that’s a primary key in one table and the foreign key in the second table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note: A primary key is a unique identifier for each record in a table. A
    foreign key establishes a link between two tables, i.e., it’s a column in the
    second table that references the first table.** We’ll show you in the examples
    what that means.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use LEFT JOIN, RIGHT JOIN, or FULL JOIN, you just use these keywords
    instead of JOIN – everything else in the code is exactly the same!
  prefs: []
  type: TYPE_NORMAL
- en: Things are a little different with the CROSS JOIN. In its nature is to join
    all the rows’ combinations from both tables. That’s why the ON clause is not needed,
    and the syntax looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In other words, you simply reference one table in FROM and the second in CROSS
    JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can reference both tables in FROM and separate them with
    a comma – this is a shorthand for CROSS JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Self Join: A Special Type of Join in SQL'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s also one specific way of joining the tables – joining the table with
    itself. This is also called self joining the table.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not exactly a distinct type of join, as any of the earlier-mentioned join
    types can also be used for self joining.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for self joining is similar to what I showed you earlier. The main
    difference is the same table is referenced in FROM and JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, you need to give the table two aliases to distinguish between them. What
    you’re doing is joining the table with itself and treating it as two tables.
  prefs: []
  type: TYPE_NORMAL
- en: I just wanted to mention this here, but I won’t be going into further detail.
    If you’re interested in self join, please see this illustrated guide on [self
    join in SQL](https://www.stratascratch.com/blog/illustrated-guide-about-self-join-in-sql/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins).
  prefs: []
  type: TYPE_NORMAL
- en: SQL Join Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to show you how everything I mentioned works in practice. I’ll use
    [SQL JOIN interview questions](https://www.stratascratch.com/blog/sql-join-interview-questions/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    from StrataScratch to showcase each distinct type of join in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. JOIN Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[This question by Microsoft](https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    wants you to list each project and calculate the project’s budget by the employee.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Expensive Projects***'
  prefs: []
  type: TYPE_NORMAL
- en: '**“Given a list of projects and employees mapped to each project, calculate
    by the amount of project budget allocated to each employee . The output should
    include the project title and the project budget rounded to the closest integer.
    Order your list by projects with the highest budget per employee first.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The question gives two tables.
  prefs: []
  type: TYPE_NORMAL
- en: '**ms_projects**'
  prefs: []
  type: TYPE_NORMAL
- en: '| id: | int |'
  prefs: []
  type: TYPE_TB
- en: '| title: | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| budget: | int |'
  prefs: []
  type: TYPE_TB
- en: '**ms_emp_projects**'
  prefs: []
  type: TYPE_NORMAL
- en: '| emp_id: | int |'
  prefs: []
  type: TYPE_TB
- en: '| project_id: | int |'
  prefs: []
  type: TYPE_TB
- en: 'Now, the column id in the table **ms_projects** is the table’s primary key.
    The same column can be found in the table **ms_emp_projects**, albeit with a different
    name: project_id. This is the table’s foreign key, referencing the first table.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll use these two columns to join the tables in my solution.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I joined the two tables using JOIN. The table **ms_projects** is referenced
    in FROM, while **ms_emp_projects** is referenced after JOIN. I’ve given both tables
    an alias, allowing me not to use the table’s long names later on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I need to specify the columns on which I want to join the tables. I already
    mentioned which columns are the primary key in one table and the foreign key in
    another table, so I’ll use them here.
  prefs: []
  type: TYPE_NORMAL
- en: I equal these two columns because I want to get all the data where the project
    ID is the same. I also used the tables’ aliases in front of each column.
  prefs: []
  type: TYPE_NORMAL
- en: Now that I have access to data in both tables, I can list columns in SELECT.
    The first column is the project name, and the second column is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: This calculation uses the COUNT() function to count the number of employees
    by each project. Then I divide each project’s budget by the number of employees.
    I also convert the result to decimal values and round it to zero decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s what the query returns.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/6bd7c952f4590be4964d1b451fde8193.png)'
  prefs: []
  type: TYPE_IMG
- en: 2\. LEFT JOIN Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s practice this join on the [Airbnb interview question](https://platform.stratascratch.com/coding/9908-customer-orders-and-details?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins).
    It wants you to find the number of orders, the number of customers, and the total
    cost of orders for each city.
  prefs: []
  type: TYPE_NORMAL
- en: '***Customer Orders and Details***'
  prefs: []
  type: TYPE_NORMAL
- en: '**“Find the number of orders, the number of customers, and the total cost of
    orders for each city. Only include cities that have made at least 5 orders and
    count all customers in each city even if they did not place an order.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Output each calculation along with the corresponding city name.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re given the tables **customers,** and **orders**.
  prefs: []
  type: TYPE_NORMAL
- en: '**customers**'
  prefs: []
  type: TYPE_NORMAL
- en: '| id: | int |'
  prefs: []
  type: TYPE_TB
- en: '| first_name: | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| last_name: | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| city: | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| address: | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| phone_number: | varchar |'
  prefs: []
  type: TYPE_TB
- en: '**orders**'
  prefs: []
  type: TYPE_NORMAL
- en: '| id: | int |'
  prefs: []
  type: TYPE_TB
- en: '| cust_id: | int |'
  prefs: []
  type: TYPE_TB
- en: '| order_date: | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| order_details: | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| total_order_cost: | int |'
  prefs: []
  type: TYPE_TB
- en: The shared columns are id from the table **customers** and cust_id from the
    table **orders**. I’ll use these columns to join the tables.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s how to solve this question using LEFT JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I reference the table **customers** in FROM (this is our left table) and LEFT
    JOIN it with **orders** on the customer ID columns.
  prefs: []
  type: TYPE_NORMAL
- en: Now I can select the city, use COUNT() to get the number of orders and customers
    by city, and use SUM() to calculate the total orders cost by city.
  prefs: []
  type: TYPE_NORMAL
- en: To get all these calculations by city, I group the output by city.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one extra request in the question: “Only include cities that have made
    at least 5 orders…” I use HAVING to show only cities with five or more orders
    to achieve that.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The question is, why did I use** **LEFT JOIN** **and not** **JOIN****?**
    The clue is in the question:”...and count all customers in each city even if they
    did not place an order.” It’s possible that not all customers have placed orders.
    This means I want to show all customers from the table **customers**, which perfectly
    fits the definition of the LEFT JOIN.'
  prefs: []
  type: TYPE_NORMAL
- en: Had I used JOIN, the result would’ve been wrong, as I would’ve missed the customers
    that didn’t place any orders.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note: The complexity of joins in SQL isn’t reflected in their syntax but
    in their semantics!** As you saw, each join is written the same way, only the
    keyword changes. However, each join works differently and, therefore, can output
    different results depending on the data. Because of that, it’s crucial that you
    fully understand what each join does and choose the one that will return exactly
    what you want!'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let’s have a look at the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/f25478b07ca19c239ea6224e1259a9a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 3\. RIGHT JOIN Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RIGHT JOIN is the mirror image of LEFT JOIN. That’s why I could’ve easily
    solved the previous problem using RIGHT JOIN. Let me show you how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tables stay the same; I’ll just use a different type of join.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what’s changed. As I’m using RIGHT JOIN, I switched the order of the
    tables. Now the table **orders** becomes the left one, and the table **customers**
    the right one. The joining condition stays the same. I just switched the order
    of the columns to reflect the order of the tables, but it’s not necessary to do
    it.
  prefs: []
  type: TYPE_NORMAL
- en: By switching the order of the tables and using RIGHT JOIN, I again will output
    all the customers, even if they haven’t placed any orders.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the query is the same as in the previous example. The same goes
    for the output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note: In practice,** **RIGHT JOIN** **is relatively rarely used.** The LEFT
    JOIN seems more natural to SQL users, so they use it much more often. Anything
    that can be done with RIGHT JOIN can also be done with LEFT JOIN. Because of that,
    there’s no specific situation where RIGHT JOIN might be preferred.'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/f25478b07ca19c239ea6224e1259a9a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 4\. FULL JOIN Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The question by Salesforce and Tesla](https://platform.stratascratch.com/coding/10318-new-products?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    wants you to count the net difference between the number of products companies
    launched in 2020 with the number of products companies launched in the previous
    year.'
  prefs: []
  type: TYPE_NORMAL
- en: '***New Products***'
  prefs: []
  type: TYPE_NORMAL
- en: '*“You are given a table of product launches by company by year. Write a query
    to count the net difference between the number of products companies launched
    in 2020 with the number of products companies launched in the previous year. Output
    the name of the companies and a net difference of net products released for 2020
    compared to the previous year.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The question provides one table with the following columns.
  prefs: []
  type: TYPE_NORMAL
- en: '**car_launches**'
  prefs: []
  type: TYPE_NORMAL
- en: '| year: | int |'
  prefs: []
  type: TYPE_TB
- en: '| company_name: | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| product_name: | varchar |'
  prefs: []
  type: TYPE_TB
- en: How the hell will I join tables when there’s only one table? Hmm, let’s see
    that, too!
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This query is a little more complicated, so I’ll reveal it gradually.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first SELECT statement finds the company and the product name in 2020\.
    This query will later be turned into a subquery.
  prefs: []
  type: TYPE_NORMAL
- en: The question wants you to find the difference between 2020 and 2019\. So let’s
    write the same query but for 2019.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I’ll now make these queries into subqueries and join them using the FULL OUTER
    JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Subqueries can be treated as tables and, therefore, can be joined. I gave the
    first subquery an alias, and I placed it in the FROM clause. Then I use FULL OUTER
    JOIN to join it with the second subquery on the company name column.
  prefs: []
  type: TYPE_NORMAL
- en: By using this type of SQL join, I’ll get all the companies and products in 2020
    merged with all the companies and products in 2019.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/e93b4f2c0f0fd8ad0a49de95cf97bcd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Now I can finalize my query. Let’s select the company name. Also, I’ll use the
    COUNT() function to find the number of products launched in each year and then
    subtract it to get the difference. Finally, I’ll group the output by company and
    sort it also by company alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the whole query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s the list of companies and the launched products difference between 2020
    and 2019.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/437525d5348f8d14247ef258e2bf80cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 5\. CROSS JOIN Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[This question by Deloitte](https://platform.stratascratch.com/coding/2101-maximum-of-two-numbers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    is great for showing how CROSS JOIN works.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Maximum of Two Numbers***'
  prefs: []
  type: TYPE_NORMAL
- en: '**“Given a single column of numbers, consider all possible permutations of
    two numbers assuming that pairs of numbers (x,y) and (y,x) are two different permutations.
    Then, for each permutation, find the maximum of the two numbers.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Output three columns: the first number, the second number and the maximum
    of the two.”*'
  prefs: []
  type: TYPE_NORMAL
- en: The question wants you to find all possible permutations of two numbers assuming
    that pairs of numbers (x,y) and (y,x) are two different permutations. Then, we
    need to find the maximum of the numbers for each permutation.
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The question gives us one table with one column.
  prefs: []
  type: TYPE_NORMAL
- en: '**deloitte_numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: '| number: | int |'
  prefs: []
  type: TYPE_TB
- en: Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code is an example of CROSS JOIN, but also of self join.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I reference the table in FROM and give it one alias. Then I CROSS JOIN it with
    itself by referencing it after CROSS JOIN and giving the table another alias.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s possible to use one table as they’re two. I select the column number
    from each table. Then I use the CASE statement to set a condition that will show
    the maximum number of the two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Why is CROSS JOIN used here? Remember, it’s a type of SQL join that will show
    all combinations of all rows from all tables. That’s exactly what the question
    is asking!
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s the snapshot of all the combinations and the higher number of the two.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/0dbd17281afe1d66e06d7000a7662d7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Utilizing SQL Joins for Data Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to use SQL joins, the question is how to utilize that
    knowledge in data science.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Joins play a crucial role in data science tasks such as data exploration,
    data cleaning, and feature engineering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of how SQL joins can be leveraged:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining Data:** Joining tables allows you to bring together different sources
    of data, enabling you to analyze relationships and correlations across multiple
    datasets. For example, joining a customer table with a transaction table can provide
    insights into customer behavior and purchasing patterns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data Validation:** Joins can be used to validate data quality and integrity.
    By comparing data from different tables, you can identify inconsistencies, missing
    values, or outliers. This helps you in data cleaning and ensures that the data
    used for analysis is accurate and reliable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Feature Engineering:** Joins can be instrumental in creating new features
    for machine learning models. By merging relevant tables, you can extract meaningful
    information and generate features that capture important relationships within
    the data. This can enhance the predictive power of your models.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Aggregation and Analysis:** Joins enable you to perform complex aggregations
    and analyses across multiple tables. By combining data from various sources, you
    can gain a comprehensive view of the data and derive valuable insights. For example,
    joining a sales table with a product table can help you analyze sales performance
    by product category or region.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Best Practices for SQL Joins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I already mentioned, the complexity of joins doesn’t show in their syntax.
    You saw that syntax is relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The best practices for joins also reflect that, as they are not concerned with
    coding itself but what join does and how it performs.
  prefs: []
  type: TYPE_NORMAL
- en: To make the most out of joins in SQL, consider the following best practices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand Your Data:** Familiarize yourself with the structure and relationships
    within your data. This will help you choose the appropriate type of join and select
    the right columns for matching.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use Indexes:** If your tables are large or frequently joined, consider adding
    indexes on the columns used for joining. Indexes can significantly improve query
    performance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Be Mindful of Performance:** Joining large tables or multiple tables can
    be computationally expensive. Optimize your queries by filtering data, using appropriate
    join types, and considering the use of temporary tables or subqueries.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test and Validate:** Always validate your join results to ensure correctness.
    Perform sanity checks and verify that the joined data aligns with your expectations
    and business logic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL Joins are a fundamental concept that empowers you as a data scientist to
    merge and analyze data from multiple sources. By understanding the different types
    of SQL joins, mastering their syntax, and leveraging them effectively, data scientists
    can unlock valuable insights, validate data quality, and drive data-driven decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: I showed you how to do it in five examples. Now it’s up to you to harness the
    power of SQL and joins for your data science projects and achieve better results.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Nate Rosidi](https://www.stratascratch.com)** is a data scientist and in
    product strategy. He''s also an adjunct professor teaching analytics, and is the
    founder of [StrataScratch](https://www.stratascratch.com/), a platform helping
    data scientists prepare for their interviews with real interview questions from
    top companies. Connect with him on [Twitter: StrataScratch](https://twitter.com/StrataScratch)
    or [LinkedIn](https://www.linkedin.com/in/nathanrosidi/).'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[In-Database Analytics: Leveraging SQL''s Analytic Functions](https://www.kdnuggets.com/2023/07/indatabase-analytics-leveraging-sql-analytic-functions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leveraging GPT Models to Transform Natural Language to SQL Queries](https://www.kdnuggets.com/leveraging-gpt-models-to-transform-natural-language-to-sql-queries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leveraging AI to Design Fair and Equitable EV Charging Grids](https://www.kdnuggets.com/leveraging-ai-to-design-fair-and-equitable-ev-charging-grids)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leveraging Geospatial Data in Python with GeoPandas](https://www.kdnuggets.com/leveraging-geospatial-data-in-python-with-geopandas)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leveraging XGBoost for Time-Series Forecasting](https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leveraging the Power of GPUs with CuPy in Python](https://www.kdnuggets.com/leveraging-the-power-of-gpus-with-cupy-in-python)*****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
