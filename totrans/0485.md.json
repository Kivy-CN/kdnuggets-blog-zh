["```py\n**import** **numpy** **as** **np\n\n#create dataset** **with** **100** **values that follow a normal distribution\nnp****.****random****.****seed****(****0****)** **data** **=** **np****.****random****.****normal****(****0****,****1****,** **1000****)** **#view first** **10** **values\ndata****[****:****10****]** \n```", "```py\narray([ 1.76405235,  0.40015721,  0.97873798,  2.2408932 ,  1.86755799,\n       -0.97727788,  0.95008842, -0.15135721, -0.10321885,  0.4105985 ])\n```", "```py\n**import** **statsmodels****.****api** **as** **sm** **import** **matplotlib****.****pyplot** **as** **plt\n\n#create** **Q****-****Q** **plot** **with** **45****-****degree line added to plot\nfig** **=** **sm****.****qqplot****(****data****,** **line****=****'45'****)** **plt****.****show****(****)**\n```", "```py\n**#create dataset** **of** **100** **uniformally distributed values** **data** **=** **np****.****random****.****uniform****(****0****,****1****,** **1000****)**\n\n**#generate** **Q****-****Q** **plot** **for** **the dataset** **fig** **=** **sm****.****qqplot****(****data****,** **line****=****'45'****)** **plt****.****show****(****)**\n```", "```py\n**import** numpy as np\n**import** random\n**import** matplotlib.pyplot as plt\n\n**#create a population** **with** **a gamma distribution**\nshape, scale = 2., 2\\.  #mean=4, std=2*sqrt(2)\nmu = shape*scale #mean and standard deviation\nsigma = scale*np.sqrt(shape)\n\ns = np.random.gamma(shape, scale, 1000000)\n```", "```py\n**#sample** **10000** **values**\nrs = random.choices(s, k=10000)\n```", "```py\n**#****set** **k**\nks = [0.1,0.5,1.0,1.5,2.0,2.5,3.0]\n\n**#probability list**\nprobs = [] **#****for** **each k**\n\nfor k in ks: \n    **#start count**\n    c = 0\n    for i in rs:\n        **#** count if far from mean in k standard deviation\n        if abs(i - mu) > k * sigma :\n            c += 1\n    probs.append(c/10000)\n```", "```py\nplot = plt.figure(figsize=(20,10))\n**#plot each probability**\nplt.xlabel('**K**')\nplt.ylabel('**probability**')\nplt.plot(ks,probs, marker='o')\nplot.show()\n**#print each probability**\nprint(\"Probability of a sample far from mean more than k standard deviation:\")\nfor i, prob in enumerate(probs):\n    print(\"k:\" + str(ks[i]) + \", probability: \" \\\n          + str(prob)[0:5] + \\\n          \" | in theory, probability should less than: \" \\\n          + str(1/ks[i]**2)[0:5])\n```", "```py\n**import** numpy **as** np\n**import** matplotlib.pyplot **as** plt\n**from** scipy.stats **import** lognorm\n\nnp.random.seed(42)\n\ndata = lognorm.rvs(s=0.5, loc=1, scale=1000, size=1000)\n\nplt.figure(figsize=(10,6))\nax = plt.subplot(111)\nplt.title('**Generate wrandom numbers from a Log-normal distribution**')\nax.hist(data, bins=np.logspace(0,5,200), density=True)\nax.set_xscale(\"**log**\")\n\nshape,loc,scale = lognorm.fit(data)\n\nx = np.logspace(0, 5, 200)\npdf = lognorm.pdf(x, shape, loc, scale)\n\nax.plot(x, pdf, 'y')\nplt.show()\n```", "```py\n**import** numpy **as** np\n**import** matplotlib.pyplot **as** plt\n**from** scipy.stats **import** pareto\n\nx_m = 1 #scale\nalpha = [1, 2, 3] #list of values of shape parameters\nplt.figure(figsize=(10,6))\nsamples = np.linspace(start=0, stop=5, num=1000)\nfor a in alpha:\n    output = np.array([pareto.pdf(x=samples, b=a, loc=0, scale=x_m)])\n    plt.plot(samples, output.T, label='alpha {0}' .format(a))\n\nplt.xlabel('**samples**', fontsize=15)\nplt.ylabel('**PDF**', fontsize=15)\nplt.title('**Probability Density function**', fontsize=15)\nplt.legend(loc='**best**')\nplt.show()\n```", "```py\n#load necessary packages\n**import** numpy **as** np \n**from** scipy.stats **import** boxcox \n**import** seaborn **as** sns \n\n#make this example reproducible\nnp.random.seed(0)\n\n#**generate dataset**\ndata = np.random.exponential(size=1000)\n\nfig, ax = plt.subplots(1, 2)\n#**plot the distribution** **of** **data values**\nsns.distplot(data, hist=False, kde=True, \n             kde_kws = {'shade': True, 'linewidth': 2}, \n            label = \"Non-Normal\", color =\"red\", ax = ax[0]) \n\n#**perform Box****-****Cox transformation on original data**\ntransformed_data, best_lambda = boxcox(data) \n\nsns.distplot(transformed_data, hist = False, kde = True,\n            kde_kws = {'shade': True, 'linewidth': 2}, \n            label = \"**Normal**\", color =\"**red**\", ax = ax[1])\n\n#**adding legends to the subplots**\nplt.legend(loc = \"**upper right**\")\n\n#**rescaling the subplots**\nfig.set_figheight(5)\nfig.set_figwidth(10)\n#**display optimal lambda value**\nprint(f\"**Lambda value used for Transformation: {best_lambda}**\")\n```", "```py\n**from** numpy **import** random\n**import** matplotlib.pyplot as plt\n**import** seaborn as sns\n\nlam_list = [1, 4, 9] **#list** **of** **Lambda values** \n\nplt.figure(figsize=(10,6))\nsamples = np.linspace(start=0, stop=5, num=1000)\n\nfor lam in lam_list:\n    sns.distplot(random.poisson(lam=lam, size=10), hist=False, label='**lambda {0}**'.format(lam))\n\nplt.xlabel('**Poisson Distribution**', fontsize=15)\nplt.ylabel('**Frequency**', fontsize=15)\nplt.legend(loc='**best**')\nplt.show()\n```"]