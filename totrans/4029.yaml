- en: 8 Built-in Python Decorators to Write Elegant Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/8-built-in-python-decorators-to-write-elegant-code](https://www.kdnuggets.com/8-built-in-python-decorators-to-write-elegant-code)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![8 Built-in Python Decorators to Write Elegant Code](../Images/9a45d20f9bd18537e1f5c2974d8fb7a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Editor
  prefs: []
  type: TYPE_NORMAL
- en: Python, with its clean and readable syntax, is a widely used high-level programming
    language. Python is designed for ease of use that emphasizes simplicity and reduced
    cost of program maintenance. It comes with an extensive library that reduces the
    need for developers to write code from scratch and increases developers' productivity.
    One powerful feature of Python that contributes to code elegance is decorators.
  prefs: []
  type: TYPE_NORMAL
- en: What are Python Decorators?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, a decorator is a function that allows you to modify the behavior
    of another function without changing its core logic. It takes another function
    as an argument and returns the function with extended functionality. This way,
    you can use decorators to add some extra logic to existing functions to increase
    reusability with just a few lines of code. In this article, we will explore eight
    built-in Python decorators that can help you write more elegant and maintainable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![8 Built-in Python Decorators to Write Elegant Code](../Images/92724f0843ac2c039dd26e41b8a9cb17.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Editor
  prefs: []
  type: TYPE_NORMAL
- en: 1\. @atexit.register
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@atexit.register` decorator is used to register a function to be executed
    at program termination. This function can be used to perform any task when the
    program is about to exit, whether it’s due to normal execution or an unexpected
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation, `@atexit.register` is mentioned above the function
    definition. It defines the `exit_handler()` function as an exit function. Essentially,
    it means that whenever the program reaches its termination point, either through
    normal execution or due to an unexpected error causing a premature exit, the `exit_handler()`
    function will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. @dataclasses.dataclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@dataclasses.dataclass` is a powerful decorator that is used to automatically
    generate common special methods for classes such as “__init__”, “__repr__” and
    others. It helps you write cleaner, more concise code by eliminating the need
    to write boilerplate methods for initializing and comparing instances of your
    class. It can also help prevent errors by ensuring that common special methods
    are implemented consistently across your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@dataclass` decorator, applied above the Point class definition, signals
    Python to utilize default behavior for generating special methods. This automatically
    creates the `__init__` method, which initializes class attributes, such as x and
    y, upon object instantiation. As a result, instances like point can be constructed
    without the need for explicit coding. Moreover, the `__repr__` method, responsible
    for providing a string representation of objects, is also automatically adjusted.
    This ensures that when an object, like a point, is printed, it yields a clear
    and ordered representation, as seen in the output: Point(x=3, y=2). Additionally,
    the equality comparison (==) between two instances, point1 and point2, produces
    True. This is noteworthy because, by default, Python checks for equality based
    on memory location. However, in the context of dataclass objects, equality is
    determined by the data contained within them. This is because the @dataclass decorator
    generates an `__eq__` method that checks for the equality of the data present
    in the objects, rather than checking for the same memory location.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. @enum.unique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@enum.unique` decorator, found in the enum module, is used to ensure that
    the values of all the members of an enumeration are unique. This helps prevent
    the accidental creation of multiple enumeration members with the same value, which
    can lead to confusion and errors. If duplicate values are found, a **ValueError**
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation, "BUS" and "MOTORCYCLE" have the same value "3".
    As a result, the `@unique` decorator raises a ValueError with a message indicating
    that duplicate values have been found. Neither can you use the same key more than
    once nor can you assign the same value to different members. In this manner, it
    helps prevent duplicate values for multiple enumeration members.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. @partial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `partial` decorator is a powerful tool that is used to create partial functions.
    Partial functions allow you to pre-set some of the arguments of the original function
    and generate a new function with those arguments already filled in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation, we have a function “power” which accepts two arguments
    “base” and “exponent” and returns the result of the base raised to the power of
    exponent. We have created a partial function named “square” using the original
    function in which the exponent is pre-set to 2\. In this way, we can extend the
    functionality of original functions using a `partial` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. @singledispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@singledisptach` decorator is used to create generic functions. It allows
    you to define different implementations of functions with the same name but different
    argument types. It is particularly useful when you want your code to behave differently
    for different data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation, we first developed the generic function `display_info()`
    using the `@singledisptach` decorator and then registered its implementation for
    int, float, string, and list separately. The output shows the working of `display_info()`
    for separate data types.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. @classmethod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@classmethod` is a decorator used to define class methods within the class.
    Class methods are bound to the class rather than the object of the class. The
    primary distinction between static methods and class methods lies in their interaction
    with the class state. Class methods have access to and can modify the class state,
    whereas static methods can not access the class state and operate independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation, the **Student** class has **total_students** as
    a class variable. The `@classmethod` decorator is used to define the `increment_total_students()`
    class method to increment the **total_students** variable. Whenever we create
    an instance of the Student class, the total number of students is incremented
    by one. We created two instances of the class and then used the class method to
    modify the **total_students** variable to **3**, which is also reflected by the
    instances of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. @staticmethod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@staticmethod` decorator is used to define static methods within a class.
    Static methods are the methods that can be called without creating an instance
    of the class. Static methods are often used when they don't have to access object-related
    parameters and are more related to the class as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation, we have used `@staticmethod` to define a static
    method add() for the class “MathOperations”. We have added the two numbers “4”
    and “5” which results in “9” without creating any instance of the class. Similarly,
    subtract the two numbers “8” and “3” to get “5”. This way static methods can be
    generated to perform utility functions that do not require the state of an instance.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. @property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@property` decorator is used to define the getter methods for the class
    attribute. The getter methods are the methods that return the value of an attribute.
    These methods are used for data encapsulation which specifies who can access the
    details of the class or instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation, the class “Circle” has an attribute “radius”. We
    have used `@property` to set up the getter methods for the radius as well as the
    area. It provides a clean and consistent interface for the users of the class
    to access these attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This article highlights some of the most versatile and functional decorators
    that you can use to make your code more flexible and readable. These decorators
    let you extend the functionalities of the original function to make it more organized
    and less prone to errors. They are like magic touches that make your Python programs
    look neat and work smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**[](https://www.linkedin.com/in/kanwal-mehreen1/)**[Kanwal Mehreen](https://www.linkedin.com/in/kanwal-mehreen1/)****
    Kanwal is a machine learning engineer and a technical writer with a profound passion
    for data science and the intersection of AI with medicine. She co-authored the
    ebook "Maximizing Productivity with ChatGPT". As a Google Generation Scholar 2022
    for APAC, she champions diversity and academic excellence. She''s also recognized
    as a Teradata Diversity in Tech Scholar, Mitacs Globalink Research Scholar, and
    Harvard WeCode Scholar. Kanwal is an ardent advocate for change, having founded
    FEMCodes to empower women in STEM fields.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Pydon''ts - Write elegant Python code: Free Book Review](https://www.kdnuggets.com/2022/05/pydonts-write-elegant-python-code-free-book-review.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What You Should Know About Python Decorators And Metaclasses](https://www.kdnuggets.com/2023/03/know-python-decorators-metaclasses.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Write Clean Python Code Using Pipes](https://www.kdnuggets.com/2021/12/write-clean-python-code-pipes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How To Write Efficient Python Code: A Tutorial for Beginners](https://www.kdnuggets.com/how-to-write-efficient-python-code-a-tutorial-for-beginners)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7 Projects Built with Generative AI](https://www.kdnuggets.com/2023/08/7-projects-built-generative-ai.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Write SQL in Native Python](https://www.kdnuggets.com/2022/02/easy-sql-native-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
