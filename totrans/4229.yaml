- en: Data Scientist’s Guide to Efficient Coding in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2021/08/data-scientist-guide-efficient-coding-python.html](https://www.kdnuggets.com/2021/08/data-scientist-guide-efficient-coding-python.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[comments](#comments)'
  prefs: []
  type: TYPE_NORMAL
- en: '**By [Dr. Varshita Sher](https://varshitasher.medium.com/), Data Scientist**'
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I wanted to share a few tips for writing cleaner codes that
    I have absorbed in the last year — mainly from pair programming. Generally speaking,
    including them as part of my everyday coding routine has helped me generate supreme
    quality Python scripts, that are easily maintainable and scalable over time.
  prefs: []
  type: TYPE_NORMAL
- en: Ever thought why **senior developer’s code look so much better in comparison
    to a junior developer**. Read on to bridge the gap….
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rather than giving generic examples on how to use these techniques, I will be
    giving real-life coding scenarios where I have *actually* used them! Here is the [Jupyter
    Colab Notebook](https://colab.research.google.com/drive/1gSIJd_HY88A_bq-Z0zMMzFYb1hjRI8DO?usp=sharing) if
    you’d like to follow along!
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Use `tqdm` when working with `for `loops.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine looping over a *large* iterable (list, dictionary, tuple, set), and
    not knowing whether the code has finished running! *Bummer*, *right*! In such
    scenarios make sure to use `tqdm` construct to display a progress bar alongside.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to display the progress as I read through all the files present
    in 44 different directories (whose paths I have already stored in a list called `fpaths`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9bcd861ff49e3bd8b0e25a728332679a.png)'
  prefs: []
  type: TYPE_IMG
- en: Using tqdm with “for“ loop
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: Use the *`*desc*`* argument to specify a small description for the loop.*'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Use `type hinting when writing functions.`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In simple terms, it means explicitly stating the type of all the arguments in
    your Python function definition.
  prefs: []
  type: TYPE_NORMAL
- en: I wish there were specific use cases I could provide to emphasize *when* I use
    type hinting for my work, but the truth is, I use them more often than not.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a hypothetical example of a function `update_df()`. It updates a given
    data frame by appending a row containing useful information from a simulation
    run — such as classifier used, accuracy scored, train-test split size, and additional
    remarks for that particular run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/930d1b32e90748482182847e086597d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The datatype following the `->` symbol in the function definition (`def update_df(.......) **->** pd.DataFrame`)
    indicates the type of the value returned by the functions, i.e. a Pandas’s dataframe
    in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default value, if any, can be specified as usual in the form `param:type
    = value` . (For example: `split: float = 0.5`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case a function does not return anything, feel free to use `None`. For example
    : `def func(a: str, b: int) -> None: print(a,b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To return values of mixed types, for example, say a function could either print
    a statement if a flag `option`was set OR return an `int`if the flag was not set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: As of Python 3.10, *`*Union*`* is not required, so you can simply do:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can go as specific as you’d like while defining the types of parameters,
    as we have done for `remarks: List[str]`. Not only do we specify it should be
    a `List`, but it should be a list of `str` only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For fun, try passing a list of integers to `remarks`while calling the function.
    You’ll see no error returned! *Why is that? *Because Python interpreter doesn’t
    enforce any type checking based on your type-hints.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Type-hints have no impact on your code other than adding documentation](https://www.pythonlikeyoumeanit.com/Module5_OddsAndEnds/Writing_Good_Code.html#What-is-It-Good-For?-(Absolutely-Nothing)).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s still good practice, though, to include it! I feel it lends more clarity
    to oneself when writing a function. In addition, when someone makes a call to
    such a function, they get to see nice prompts for the arguments it would take
    as inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9f1d83d3b0fc37b952d7bfb93d64ea76.png)'
  prefs: []
  type: TYPE_IMG
- en: Prompts when calling a function with type hinting
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Use args and kwargs for functions with unknown # of arguments`.`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine this: you want to write a function that takes as input *some* directory
    paths and prints the number of files within each. The problem is, we do not know *how* many
    paths the user would input! Could be 2 could be 20! So we are unsure how many
    parameters should we define in our function definition. Clearly, writing a function
    like `def count_files(file1, file2, file3, …..file20)`would be silly. In such
    cases, `args` and (sometimes `kwargs`) come handy!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Args** is used for specifying an unknown number of **positional** arguments.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Kwargs** is used for specifying an unknown number of **keyword** arguments.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Args
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s an example of a function `count_files_in_dir()`that takes in `project_root_dir` and
    an arbitrary number of folder paths within it (using `*fpaths` in the function
    definition). As an output, it prints the number of files within each of these
    folders.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/8e8c20d0e9910db055928a7971a3ff0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Counting the # of files in Google Colab directories'
  prefs: []
  type: TYPE_NORMAL
- en: In the function call, we pass in 5 arguments. As the function definition expects
    one *required* positional arguments i.e. `project_root_dir`, it automatically
    knows `"../usr"` must be it. All the remaining arguments (four in this case) are
    “soaked up” by `*fpaths`and are used for counting the files.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: The proper terminology for this soaking up technique is “argument packing”
    i.e. remaining arguments are packed into *`**fpaths*`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Kwargs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at functions that must take an unknown number of *keyword* arguments.
    In such scenarios, we must use `kwargs` instead of `args`. Here’s a short (useless)
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/25cd205f9fd4647a869c6dfc99d2f52b.png)'
  prefs: []
  type: TYPE_IMG
- en: The usage is quite similar to `*args` but now we are able to pass an arbitrary
    number of *keyword* arguments to a function. These arguments get stored as key-value
    pairs in `**results`dictionary. From hereon, it is easy to access the items within
    this dictionary using `.items()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have found two main applications for `kwargs` in my work:'
  prefs: []
  type: TYPE_NORMAL
- en: merging dictionaries (*useful but less interesting*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: extending an existing method (*more interesting*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: Checkout *[*matplotlib’s plot function using *](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib-pyplot-plot)`[*kwargs*](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib-pyplot-plot)`* to
    specify optional embellishments for a plot such as linewidth and label.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a real practical use-case for extending methods using `**kwargs` from
    one of my recent projects:'
  prefs: []
  type: TYPE_NORMAL
- en: We often use Sklearn’s `train_test_split()` for splitting `X` and `y`. While
    working on one of the GANs projects, I had to split the generated synthetic images
    into the *same* train-test split that is used for splitting real images and their
    respective labels. In addition, I also wanted to be able to pass any other arguments
    that one would normally pass to the `train_test_split()`. Finally, `stratify` must
    always be passed because I was working on a face recognition problem (and wanted
    all labels to be present in both train and test set).
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we created a function called `custom_train_test_split()`. I’ve
    included a bunch of print statements to show what exactly is happening under the
    hood (and omitted some snippets for brevity).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: While calling this function, instead of using the actual image vectors
    and labels (see figure below), I have replaced them with dummy data for ease of
    understanding. The code, however, should work for real images as well!*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5c62be74580ff4d94753b0667954be87.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A Calling a function with kwargs in function definition
  prefs: []
  type: TYPE_NORMAL
- en: 'Bunch of things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: All the *keyword* arguments (**except **`stratify`), used in the function call
    statement (such as `train_size` and `random_state`) will be stored as a key-value
    pair in the `**split_args` dictionary. (To verify, check out the output in Blue.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not `stratify`, you might ask? This is because according to the function
    definition, it is a *required *keyword-onlyargument and not an *optional* one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All the *non-keyword *(i.e. positional)arguments passed in the function call
    (such as `"SVM"`, `labels`, etc.) would be stored in the first three parameters
    in function definition i.e.`clf`, `y` and `*X`, (and yes the order in which they
    are passed matters). However, we have *four* arguments in function call i.e. `"SVM"`, `labels`, `ims` ,
    and `synthetic_ims`. *Where do we store the fourth one?*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that we used `*X` as the third parameter in the function definition,
    hence all arguments passed to the function after the first two arguments are *packed *(soaked)
    into `*X`. (To verify, check output in Green).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When calling `train_test_split()` method within our function, we are essentially *unpacking* the `X` and `split_args` arguments
    using the `*` operator,(`*X` and `**split_args`), so that all elements of it can
    be passed as different parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: is equivalent to writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When storing the results from the `train_test_split()` method, we again *pack* the `synthetic_train` and `synthetic_test` sets
    into a single `*synthetic` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/eff64186647cd1a947a83aabcbda8884.png)'
  prefs: []
  type: TYPE_IMG
- en: To check what’s inside it, we can unpack it again using `*` operator (see the
    output in Pink).
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: For those of you who’d like a deep dive into packing & unpacking using *`***`* operator,
    do check out this *[*article*](https://realpython.com/python-kwargs-and-args/)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Use pre-commit hooks`.`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code we write is often messy and lacks proper formatting such as trailing
    whitespaces, trailing commas, unsorted import statements, spaces in indentation,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to fix all this manually, you will be saving yourself a
    great deal of time with [pre-commit hooks](https://pre-commit.com/). In simpler
    terms, these hooks can perform auto-formatting for you with one line of command
    — `pre-commit run`.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some [simple steps](https://pre-commit.com/#install) from the official
    documentation to get started and [create a ](https://pre-commit.com/index.html#2-add-a-pre-commit-configuration)`[.pre-commit-config.yaml](https://pre-commit.com/index.html#2-add-a-pre-commit-configuration)`[ file](https://pre-commit.com/index.html#2-add-a-pre-commit-configuration).
    It will contain [hooks](https://pre-commit.com/hooks.html) for all the formatting
    issues that you care about!
  prefs: []
  type: TYPE_NORMAL
- en: As a purely personal preference, I tend to keep my `.pre-commit-config.yaml` configuration
    file simple and stick with [Black’s](https://black.readthedocs.io/en/stable/integrations/source_version_control.html) pre-commit
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: One thing to remember is that files must be staged i.e. *`*git add .*`* before
    you do *`*pre-commit run*`* , otherwise, you’ll see all the files will be Skipped
    :*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/74bb1092d28f8ab78b952edfb55eebad.png)'
  prefs: []
  type: TYPE_IMG
- en: 5\. Use .yml config files to store constants`.`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your project contains a lot of config variables such as database hostname,
    passwords, AWS credentials, etc. use a `.yml` file to keep track of all of them.
    You can later use this file in any Jupyter Notebook or script that you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Given most of my work is aimed at providing a model framework to clients so
    they can train it again on their own dataset, I usually use config files for storing
    paths to folders and files. It is also a nice way to make sure the client has
    to make changes to only one file when running your script at their end.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and create a `fpaths.yml` file in the project directory. We will
    be storing the root directory where images must be stored. Additionally, the paths
    to the file names, labels, attributes, etc. Finally, we also store the paths to
    synthetic images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read this file like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: If you’d like to dig deeper, here’s a brilliant *[*tutorial*](https://www.cloudbees.com/blog/yaml-tutorial-everything-you-need-get-started)* to
    get you started with yaml.*'
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Bonus: Useful VS-Code Extensions`.`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there are certainly many nice choices for Python editors, I must say
    VSCode is hands-down the best I have seen so far (*sorry, Pycharm*). To get even
    more use of it, consider installing these extensions from the marketplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bracket Pair Colorizer ](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer)—
    allows matching brackets to be identified with colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/22f7c332c972b0d391e893eca83873db.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Path Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense) —
    allows autocompleting filenames.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/bc298c53b24cd3daaed9de47e1e6b762.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Python Dockstring generator](https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring) —
    allows generating docstrings for Python functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/85c8b32707fe9632374d81b585627221.png)'
  prefs: []
  type: TYPE_IMG
- en: Generating docstrings using VScode extension
  prefs: []
  type: TYPE_NORMAL
- en: '*Pro-tip: Generate the docstring (using *`*"""*`*) ****after**** you’ve written
    the function using type hinting. This way, the docstring generated will be even
    richer in information such as default value, argument types, etc. (See image on
    right above).*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Python Indent](https://marketplace.visualstudio.com/items?itemName=KevinRose.vsc-python-indent) —
    (*my favorite; published by *by [Kevin Rose](https://marketplace.visualstudio.com/publishers/KevinRose))
    allows proper indentation of code/brackets that runs on multiple lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/eee5fbeebed8adbf8634e945e0bf7d3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Source: [VSCode Extensions Marketplace](https://marketplace.visualstudio.com/items?itemName=KevinRose.vsc-python-indent)
  prefs: []
  type: TYPE_NORMAL
- en: '[Python Type Hint](https://marketplace.visualstudio.com/items?itemName=njqdev.vscode-python-typehint) —
    allows auto-completion for type hints when writing functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/92497f3d02c0316705bc33017a00d027.png)'
  prefs: []
  type: TYPE_IMG
- en: '[TODO tree](https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree):
    (*second favorite*) keeps track of ALL the `TODO`''s at one place that were inserted
    while writing scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/495629a719138e57c940c0da96e57c0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep track of all TODO comments inserted in your project
  prefs: []
  type: TYPE_NORMAL
- en: '[Pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance) —
    allows code completion, parameter suggestions (and a loootttt more for writing
    code faster).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congrats on being one step closer to a professional Python developer. I intend
    to keep updating this article as and when I learn more cool tricks. As always,
    if there’s an easier way to do some of the things I mentioned in this article,
    please do let me know.
  prefs: []
  type: TYPE_NORMAL
- en: Until next time :)
  prefs: []
  type: TYPE_NORMAL
- en: Step by step guide to explaining your ML project during a data science interview.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interviewer’s favorite question- How would you “scale your ML model?”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Time Series Analysis using Pandas in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Podurama: Podcast player'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read every story from Dr. Varshita Sher (and thousands of other writers on Medium)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bio: [Dr. Varshita Sher](https://varshitasher.medium.com/)** is a Data Scientist
    at Alan Turing Institute, and an Oxford & SFU Alumni.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](https://towardsdatascience.com/data-scientists-guide-to-efficient-coding-in-python-670c78a7bf79).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[5 Tips for Writing Clean R Code](/2021/08/5-tips-writing-clean-r-code.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python Data Structures Compared](/2021/07/python-data-structures-compared.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitHub Copilot Open Source Alternatives](/2021/07/github-copilot-open-source-alternatives-code-generation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[KDnuggets News, May 4: 9 Free Harvard Courses to Learn Data…](https://www.kdnuggets.com/2022/n18.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[15 Python Coding Interview Questions You Must Know For Data Science](https://www.kdnuggets.com/2022/04/15-python-coding-interview-questions-must-know-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3 Hard Python Coding Interview Questions For Data Science](https://www.kdnuggets.com/2023/03/3-hard-python-coding-interview-questions-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Free Python Project Coding Course](https://www.kdnuggets.com/2022/08/free-python-project-coding-course.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7 Must-Know Python Tips for Coding Interviews](https://www.kdnuggets.com/2023/03/7-mustknow-python-tips-coding-interviews.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enhance Your Python Coding Style with Ruff](https://www.kdnuggets.com/enhance-your-python-coding-style-with-ruff)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
