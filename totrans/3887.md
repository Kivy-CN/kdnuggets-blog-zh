# 让 Python 程序飞快

> 原文：[https://www.kdnuggets.com/2020/09/making-python-programs-blazingly-fast.html](https://www.kdnuggets.com/2020/09/making-python-programs-blazingly-fast.html)

[评论](#comments)

**由 [Martin Heinz](https://www.linkedin.com/in/heinz-martin/)，IBM 的 DevOps 工程师**

*Python* 反对者总是说，他们不愿意使用它的原因之一是它*慢*。无论具体程序——不论使用的编程语言如何——是快还是慢，都很大程度上取决于编写它的开发者及其编写*优化*和*快速*程序的技能和能力。

* * *

## 我们的三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业轨道。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析水平

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你在 IT 领域的组织

* * *

所以，让我们证明一些人错了，看看如何提升我们的*Python* 程序的性能，让它们真的很快！

![图](../Images/8e2b22b053bf334d3c9ae781110804fe.png)

由 [@veri_ivanova](https://unsplash.com/@veri_ivanova) 在 unsplash 上提供

### 计时和分析

在我们开始优化之前，我们首先需要找出代码中哪些部分实际上拖慢了整个程序。有时程序的瓶颈可能很明显，但如果你不知道在哪里，那这里有一些找出瓶颈的选项：

*注意：这是我用于演示的程序，它计算*`*e*`*的*`*X*`*次方（取自 Python 文档）：*

### 最懒的“分析”

首先，最简单而且坦白说非常懒的解决方案——Unix `time` 命令：

如果你只是想对整个程序进行计时，这可能会有效，但通常还不够……

### 最详细的分析

另一端的选择是`cProfile`，它会给你*过多*的信息：

在这里，我们用`cProfile`模块和`time`参数运行了测试脚本，以便按内部时间（`cumtime`）排序行。这给我们提供了*大量*的信息，上面显示的行仅是实际输出的约 10%。由此，我们可以看到`exp`函数是罪魁祸首（*惊喜，惊喜*），现在我们可以对计时和分析做得更具体一些……

### 计时特定函数

现在我们知道了应该把注意力集中在哪里，我们可能想要对慢函数进行计时，而不测量其余代码。为此，我们可以使用简单的装饰器：

这个装饰器可以像这样应用于测试函数：

这会给我们输出如下：

一个需要考虑的因素是*我们实际（想要）测量*的时间种类。时间包提供了`time.perf_counter`和`time.process_time`。它们的区别在于，`perf_counter`返回的是绝对值，包括你的 Python 程序处理过程没有运行的时间，因此可能会受到机器负载的影响。另一方面，`process_time`只返回*用户时间*（排除*系统时间*），这只是你进程的时间。

### 提升速度

现在，进入有趣的部分。让我们来提高你的 Python 程序的运行速度。我（大部分情况下）不会给你展示一些技巧、窍门或代码片段，这些东西可以神奇地解决你的性能问题。这更多的是关于一些通用的想法和策略，运用这些策略可以对性能产生巨大的影响，在某些情况下甚至可以提高30%的速度。

### 使用内置数据类型

这一点很明显。内置数据类型非常快速，尤其是与我们的自定义类型（如树或链表）相比。这主要是因为内置类型是用*C*实现的，而在用 Python 编码时，我们无法匹敌这种速度。

### 使用 lru_cache 进行缓存/记忆化

我在之前的博客文章中已经展示过这个[这里](https://martinheinz.dev/blog/4)，但我认为用一个简单的例子重复这个例子是值得的：

上面的函数使用`time.sleep`模拟了重计算。当第一次调用参数`1`时，它会等待2秒钟然后返回结果。再次调用时，结果已经被缓存，因此跳过函数体并立即返回结果。有关更多*现实生活*中的示例，请参阅之前的博客文章[这里](https://martinheinz.dev/blog/4)。

### 使用局部变量

这与每个作用域中变量查找的速度有关。我说*每个作用域*，因为这不仅仅是关于使用局部变量还是全局变量。实际上，即使是在——比如说——函数中的局部变量（最快），类级别属性（例如`self.name` - 较慢）和全局变量，例如导入的函数`time.time`（最慢）之间也存在查找速度的差异。

你可以通过使用看似不必要（完全无用）的赋值来提升性能，例如：

### 使用函数

这可能看起来有些违反直觉，因为调用函数会在栈上增加更多内容并产生函数返回的开销，但这与之前的观点有关。如果你只是把整个代码放到一个文件中而不把它放入函数中，它会因为全局变量而变得更慢。因此，你可以通过将整个代码封装到`main`函数中并只调用一次来加快代码速度，如下所示：

### 不要访问属性

另一个可能会减慢你程序的因素是*点运算符*(`.`)，它在访问对象属性时使用。这个运算符会触发通过`__getattribute__`的字典查找，这会在你的代码中产生额外的开销。那么，我们如何实际避免（限制）使用它呢？

### 注意字符串

对字符串进行操作时，当使用例如*模运算*(`%s`)或`.format()`在循环中运行时，可能会变得相当慢。我们有什么更好的选择？根据雷蒙德·赫廷格最近的[tweet](https://twitter.com/raymondh/status/1205969258800275456)，我们应该使用的是*f-string*，它是最可读、简洁且最快的方法。因此，根据那个 tweet，这里是你可以使用的方法列表 - 从最快到最慢：

生成器本身并不比其他方式快，它们是为了实现延迟计算而设计的，这样能节省内存而不是时间。然而，节省的内存可以使你的程序实际运行得更快。如何做到这一点？如果你有一个大型数据集而没有使用生成器（迭代器），那么数据可能会溢出 CPU 的*L1 缓存*，这将显著降低内存中的值查找速度。

在性能方面，CPU 能够将其处理的数据尽可能靠近地存储在缓存中是非常重要的。你可以观看[雷蒙德·赫廷格的讲座](https://www.youtube.com/watch?v=OSGv2VnC0go&t=8m17s)，他提到了这些问题。

### 结论

优化的第一个原则是*不要做*。但是，如果你真的需要这样做，那么希望这些小提示能对你有所帮助。不过，在优化代码时要小心，因为这可能会使代码难以阅读，从而难以维护，这可能会抵消优化带来的好处。

*注意：这篇文章最初发布在*[*martinheinz.dev*](https://martinheinz.dev/blog/13)

**简介：[马丁·海因茨](https://www.linkedin.com/in/heinz-martin/)** 是 IBM 的 DevOps 工程师。作为一名软件开发者，马丁对计算机安全、隐私和密码学充满热情，专注于云计算和无服务器计算，并时刻准备接受新的挑战。

[原文](https://towardsdatascience.com/making-python-programs-blazingly-fast-c1cd79bd1b32)。经允许转载。

**相关内容：**

+   [自动化你 Python 项目的每一个方面](/2020/09/automating-every-aspect-python-project.html)

+   [MIT 免费课程：Python 计算机科学和编程导论](/2020/09/free-mit-intro-computer-science-programming-python.html)

+   [用一行代码进行统计和视觉探索数据分析](/2020/09/statistical-visual-exploratory-data-analysis-one-line-code.html)

### 更多相关内容

+   [托马斯·米勒博士探索西北大学的在线…](https://www.kdnuggets.com/2024/05/nwu/thomas-miller-phd-explores-northwestern-universitys-online-graduate-programs-in-data-science)

+   [通过《快速 Python 数据科学》提升你的 Python 技能！](https://www.kdnuggets.com/2022/06/manning-step-python-game-fast-python-data-science.html)

+   [如何使 Python 代码运行得极快](https://www.kdnuggets.com/2021/06/make-python-code-run-incredibly-fast.html)

+   [预测：Python 中线性回归的初学者指南](https://www.kdnuggets.com/2023/06/making-predictions-beginner-guide-linear-regression-python.html)

+   [BERT在稀疏性下能有多快？](https://www.kdnuggets.com/2022/04/fast-bert-go-sparsity.html)

+   [加速机器学习与快速克里金（FKR）](https://www.kdnuggets.com/2022/06/vmc-speed-machine-learning-fast-kriging.html)
