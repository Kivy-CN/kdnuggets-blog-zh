- en: Why You Should Not Overuse List Comprehensions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/why-you-should-not-overuse-list-comprehensions-in-python](https://www.kdnuggets.com/why-you-should-not-overuse-list-comprehensions-in-python)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Your KDnuggets Post - Why You Should Not Overuse List Comprehensions in Python](../Images/5a6da7b859053098d6de4393508555c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In Python, list comprehensions provide a concise syntax to create new lists
    from existing lists and other iterables. However, once you get used to list comprehensions
    you may be tempted to use them even when you shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, your goal is to write simple and maintainable code; not complex code.
    It’s often helpful to revisit the [Zen of Python](https://peps.python.org/pep-0020/),
    a set of aphorisms for writing clean and elegant Python, especially the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful is better than ugly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple is better than complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readability counts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this tutorial, we’ll code three examples—each more complex than the previous
    one—where list comprehensions make the code super difficult to maintain. We’ll
    then try to write a more maintainable version of the same.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s start coding!
  prefs: []
  type: TYPE_NORMAL
- en: 'Python List Comprehensions: A Quick Review'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by reviewing list comprehensions in Python. Suppose you have an
    existing iterable such as a list or a string. And you’d like to create a new list
    from it. You can loop through the iterable, process each item, and append the
    output to a new list like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But less comprehensions provide a concise one-line alternative to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In addition, you can also add filtering conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Can be replaced by this list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So list comprehensions help you write Pythonic code—often make your code cleaner
    by reducing visual noise.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take three examples to understand why you shouldn't be using list
    comprehensions for tasks that require super complex expressions. Because in such
    cases, list comprehensions—instead of making your code elegant—make your code
    difficult to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Generating Prime Numbers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Problem**: Given a number `upper_limit`, generate a list of all the prime
    numbers up to that number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can break down this problem into two key ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking if a number is prime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating a list with all the prime numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list comprehension expression to do this is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, it is difficult to see what is going on…Let’s make it better.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps, better?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Easier to read, certainly. Now let’s write a *truly* better version.
  prefs: []
  type: TYPE_NORMAL
- en: A Better Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though a list comprehension is actually a good idea to solve this problem, the
    logic to check for primes in the list comprehension is making it noisy.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s write a more maintainable version that moves the logic for checking
    if a number is prime to a separate function `is_prime()`. And call the function
    `is_prime()` in the comprehension expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Is the better version good enough?** This makes the comprehension expression
    much easier to understand. It''s now clear that the expression collects all numbers
    up to `upper_limit` that are prime (where `is_prime()` returns True).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Working with Matrices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Problem**: Given a matrix, find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All the prime numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indices of the prime numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum of the primes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prime numbers sorted in descending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Your KDnuggets Post - Why You Should Not Overuse List Comprehensions in Python](../Images/66942d59b73e757393b55ffbce7f7163.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: To flatten the matrix and collect the list of all prime numbers, we can  use
    a logic similar to the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: However, to find the indices, we have another complex list comprehension expression
    (I’ve formatted the code such that it is easy to read).
  prefs: []
  type: TYPE_NORMAL
- en: You can combine checking for primes and getting their indices in a single comprehension.
    But that will not make things any simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And the corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So what is a better version?
  prefs: []
  type: TYPE_NORMAL
- en: A Better Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now for the better version, we can define a series of functions to separate
    out concerns. So that if there’s a problem, you know which function to go back
    to and fix the logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code also gives the same output as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Is the better version good enough?** While this works for a small matrix
    such as the one in this example, returning a static list is generally not recommended.
    And for generalizing to larger dimensions, you can use [generators](/2023/02/getting-started-python-generators.html)
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Parsing Nested JSON Strings'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Problem**: Parse a given nested JSON string based on conditions and get a
    list of required values.'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing nested JSON strings is challenging because you have to account for the
    different levels of nesting, the dynamic nature of the JSON response, and diverse
    data types in your parsing logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example of parsing a given JSON string based on conditions to
    get a list of all values that are:'
  prefs: []
  type: TYPE_NORMAL
- en: Integers or list of integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings or list of strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can load a JSON string into a Python dictionary using the `loads` function
    from the built-in [json module](https://docs.python.org/3/library/json.html).
    So we’ll have a nested dictionary over which we have a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list comprehension uses nested loops to iterate over the nested dictionary.
    For each value, it constructs a list based on the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value is not a dictionary and the key starts with 'inner_key', it uses
    `[inner_item]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is a dictionary with 'sub_key', it uses `[inner_item['sub_key']]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is a string or integer, it uses `[inner_item]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is a dictionary, it uses `list(inner_item.values())`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the code snippet below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As seen, the list comprehension is very difficult to wrap your head around.
  prefs: []
  type: TYPE_NORMAL
- en: '*Please do yourself and others on the team a favor by never writing such code.*'
  prefs: []
  type: TYPE_NORMAL
- en: A Better Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I think the following snippet using nested for loops and if-elif ladder is better.
    Because it’s easier to understand what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the expected output, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Is the better version good enough?** Well, not really.'
  prefs: []
  type: TYPE_NORMAL
- en: Because if-elif ladders are often considered a code smell. You may repeat logic
    across branches and adding more conditions will only make the code more difficult
    to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: But for this example, the if-elif ladders and nested loops the version is easier
    to understand than the comprehension expression, though.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples we’ve coded thus far should give you an idea of how overusing a
    Pythonic feature such as list comprehension can often become too much of a good
    thing. This is true not just for list comprehensions (they’re the most frequently
    used, though) but also for dictionary and set comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: You should always write code that’s easy to understand and maintain. So try
    to keep things simple even if it means **not** using some Pythonic features. Keep
    coding!
  prefs: []
  type: TYPE_NORMAL
- en: '**[](https://twitter.com/balawc27)**[Bala Priya C](https://www.kdnuggets.com/wp-content/uploads/bala-priya-author-image-update-230821.jpg)****
    is a developer and technical writer from India. She likes working at the intersection
    of math, programming, data science, and content creation. Her areas of interest
    and expertise include DevOps, data science, and natural language processing. She
    enjoys reading, writing, coding, and coffee! Currently, she''s working on learning
    and sharing her knowledge with the developer community by authoring tutorials,
    how-to guides, opinion pieces, and more. Bala also creates engaging resource overviews
    and coding tutorials.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[3 Reasons Why You Should Use Linear Regression Models Instead of…](https://www.kdnuggets.com/2021/08/3-reasons-linear-regression-instead-neural-networks.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 5 Reasons Why You Should Avoid a Data Science Career](https://www.kdnuggets.com/2022/04/top-5-reasons-avoid-data-science-career.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 4 tricks for competing on Kaggle and why you should start](https://www.kdnuggets.com/2022/05/packt-top-4-tricks-competing-kaggle-start.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Reasons Why You Should Get Certified](https://www.kdnuggets.com/2023/05/sas-5-reasons-get-certified.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why You Should Learn SQL in 2024](https://www.kdnuggets.com/why-you-should-learn-sql-in-2024)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Machine learning does not produce value for my business. Why?](https://www.kdnuggets.com/2021/12/machine-learning-produce-value-business.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
