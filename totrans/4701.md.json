["```py\n\ndef mat_to_vector(mat_pop_weights):\n    pop_weights_vector = []\n    for sol_idx in range(mat_pop_weights.shape[0]):\n        curr_vector = []\n        for layer_idx in range(mat_pop_weights.shape[1]):\n            vector_weights = numpy.reshape(mat_pop_weights[sol_idx, layer_idx], newshape=(mat_pop_weights[sol_idx, layer_idx].size))\n            curr_vector.extend(vector_weights)\n        pop_weights_vector.append(curr_vector)\n    return numpy.array(pop_weights_vector)\n\n```", "```py\n\ndef vector_to_mat(vector_pop_weights, mat_pop_weights):\n\n    mat_weights = []\n\n    for sol_idx in range(mat_pop_weights.shape[0]):\n\n        start = 0\n\n        end = 0\n\n        for layer_idx in range(mat_pop_weights.shape[1]):\n\n            end = end + mat_pop_weights[sol_idx, layer_idx].size\n\n            curr_vector = vector_pop_weights[sol_idx, start:end]\n\n            mat_layer_weights = numpy.reshape(curr_vector, newshape=(mat_pop_weights[sol_idx, layer_idx].shape))\n\n            mat_weights.append(mat_layer_weights)\n\n            start = end\n\n    return numpy.reshape(mat_weights, newshape=mat_pop_weights.shape)\n\n```", "```py\n\ndef predict_outputs(weights_mat, data_inputs, data_outputs, activation=\"relu\"):\n\n    predictions = numpy.zeros(shape=(data_inputs.shape[0]))\n\n    for sample_idx in range(data_inputs.shape[0]):\n\n        r1 = data_inputs[sample_idx, :]\n\n        for curr_weights in weights_mat:\n\n            r1 = numpy.matmul(a=r1, b=curr_weights)\n\n            if activation == \"relu\":\n\n                r1 = relu(r1)\n\n            elif activation == \"sigmoid\":\n\n                r1 = sigmoid(r1)\n\n        predicted_label = numpy.where(r1 == numpy.max(r1))[0][0]\n\n        predictions[sample_idx] = predicted_label\n\n    correct_predictions = numpy.where(predictions == data_outputs)[0].size\n\n    accuracy = (correct_predictions/data_outputs.size)*100\n\n    return accuracy, predictions\n\ndef fitness(weights_mat, data_inputs, data_outputs, activation=\"relu\"):\n\n    accuracy = numpy.empty(shape=(weights_mat.shape[0]))\n\n    for sol_idx in range(weights_mat.shape[0]):\n\n        curr_sol_mat = weights_mat[sol_idx, :]\n\n        accuracy[sol_idx], _ = predict_outputs(curr_sol_mat, data_inputs, data_outputs, activation=activation)\n\n    return accuracy\n\n```"]