["```py\nimport pandas as pd\ndata = pd.read_csv('occupancy_data/datatest.txt').reset_index(drop = True)\ndata.head(5)\n```", "```py\ndata.index = pd.to_datetime(data['date'])\npd.DataFrame(data.resample('H').agg({'Temperature':'mean',\n                                     'Humidity':'mean',\n                                     'Light':'last',\n                                     'CO2':'last',\n                                     'HumidityRatio' : 'mean',\n                                     'Occupancy' : 'mean'})).head(5)\n```", "```py\ndata = pd.read_csv('occupancy_data/datatest.txt').reset_index(drop = True)data_missing_records = data[~(pd.to_datetime(data.date).dt.hour == 15)].reset_index(drop = True)data_missing_records.index = pd.to_datetime(data_missing_records['date'])data_missing_records.resample('H', base = 1).agg({'Temperature':'mean',\n        'Humidity':'mean',\n        'Light':'last',\n        'CO2':'last',\n        'HumidityRatio' : 'mean',\n         'Occupancy' : 'mean'}).fillna(method  = 'ffill').head(5)\n```", "```py\nimport plotly.express as px\ndata['Temp_Bands'] = np.round(data['Temperature'])\nfig = px.line(data, x = 'date',\n              y = 'HumidityRatio',\n              color = 'Temp_Bands',\n             title = 'Humidity Ratio across dates as a function of\n             Temperature Bands',\n             labels = {'date' : 'Time Stamp',\n                      'HumidityRatio' : 'Humidity Ratio',\n                      'Temp_Bands' : 'Temperature Band'})\nfig.show()\n```", "```py\ndef custom(num1, num2):\n\n    if num1 > num2:\n        if num1 < 0:\n            return \"Greater Negative\"\n        else:\n            return \"Greater Positive\"\n    elif num2 > num1:\n        if num2 < 0:\n            return \"Less Negative\"\n        else:\n            return \"Less Positive\"\n    else:\n        return \"Rare Equal\"import swifter \nimport pandas as pd\nimport numpy as npdata_sample = pd.DataFrame(np.random.randint(-10000, 10000, size = (50000000, 2)), columns = list('XY'))\n```", "```py\n%%timeresults_arr = data_sample.apply(lambda x : custom(x['X'], x['Y']), axis = 1)\n```", "```py\n%%timeresults_arr = data_sample.swifter.apply(lambda x : custom(x['X'], x['Y']), axis = 1)\n```", "```py\nimport pandas as pd\nimport numpy as np\nimport randomstring =  'AEIOU'data_sample = pd.DataFrame(np.random.randint(-10000, 10000, size = (50000000, 2)), columns = list('XY'))\ndata_sample['random_char'] = random.choices(string, k = data_sample.shape[0])\nunique_char = data_sample['random_char'].unique()\n```", "```py\n%%timearr = []for i in range(len(data_sample)):\n\n    num1 = data_sample.X.iloc[i]\n    num2 = data_sample.Y.iloc[i]\n\n    if num1 > num2:\n        if num1 < 0:\n            arr.append(\"Greater Negative\")\n        else:\n            arr.append(\"Greater Positive\")\n    elif num2 > num1:\n        if num2 < 0:\n            arr.append(\"Less Negative\")\n        else:\n            arr.append(\"Less Positive\")\n    else:\n        arr.append(\"Rare Equal\")\n```", "```py\ndef custom_multiprocessing(i):\n\n    sample = data_sample[data_sample['random_char'] == \\\n    unique_char[i]]\n\n    arr = []\n\n    for j in range(len(sample)):\n        if num1 > num2:\n            if num1 < 0:\n                arr.append(\"Greater Negative\")\n            else:\n                arr.append(\"Greater Positive\")\n        elif num2 > num1:\n            if num2 < 0:\n                arr.append(\"Less Negative\")\n            else:\n                arr.append(\"Less Positive\")\n        else:\n            arr.append(\"Rare Equal\")\n\n    sample['values'] = arr\n\n    return sample\n```", "```py\n %%time \nimport concurrentdef main():\n    aggregated = pd.DataFrame()\n\n    with concurrent.futures.ProcessPoolExecutor(max_workers = 5) as executor:\n        results = executor.map(custom_multiprocessing, range(len(unique_char)))if __name__ == '__main__':\n    main()\n```", "```py\ndef MASE(y_train, y_test, pred): \n\n    naive_error = np.sum(np.abs(np.diff(y_train)))/(len(y_train)-1)        \n    model_error = np.mean(np.abs(y_test - pred))return model_error/naive_error\n```"]