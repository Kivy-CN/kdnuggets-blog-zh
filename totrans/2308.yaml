- en: 'Genetic Programming in Python: The Knapsack Problem'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2023/01/knapsack-problem-genetic-programming-python.html](https://www.kdnuggets.com/2023/01/knapsack-problem-genetic-programming-python.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![The Knapsack Problem Using Genetic Programming: A Python Implementation](../Images/7b463d16bed21ff7a97ece2d230b0111.png)'
  prefs: []
  type: TYPE_IMG
- en: Image created with DALL•E
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_BQ
  - PREF_H2
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Editor''s note:** As pointed out by reader Monem in the comments below, this
    is an example of using a **genetic algorithm** to solve the knapsack problem,
    not genetic programming. I got involved in the production of the article and made
    a very basic error that carried all the way through. For transparency, I''m leaving
    as it, with this correction note. Apologies for the confusion.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this article, we will look at the knapsack problem, a classic in computer
    science. We will explain why it is difficult to solve using traditional computational
    methods, and how genetic programming can help find a "good enough" solution. Afterwards,
    we will look at a Python implementation of just such a solution to test out for
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The Knapsack Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The knapsack problem can be used to illustrate the difficulty of solving complex
    computational problems. In its simplest form, one is given a knapsack of a certain
    capacity, a set of items with their sizes and values, and asked to maximize the
    value of the items placed in the knapsack without exceeding the capacity. The
    knapsack problem can be formulated in many ways, but it is generally considered
    to be a difficult problem to solve when employing traditional algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty of the knapsack problem lies in the fact that it is an NP-complete
    problem, which means that there is no known solution that can guarantee a globally
    optimal solution. Therefore, the problem is intractable and cannot be quickly
    solved using traditional methods. The best known algorithms for solving the knapsack
    problem involve using brute force search or heuristics, which can have lengthy
    run times, and which may not guarantee an optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: Genetic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Genetic programming, however, can provide an alternative method for finding
    a solution to the knapsack problem. Genetic programming is a technique that uses
    evolutionary algorithms to search for solutions to complex problems. By using
    genetic programming, it is possible to quickly find a solution that is “good enough”
    for the given problem. It can also be used to optimize and improve upon solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In genetic programming, a set of possible solutions (or initial generation)
    are randomly generated, and then evaluated based on a set of criteria. Those solutions
    that best fit the criteria are then selected, and genetic mutations are applied
    to create new solution variants (or subsequent generations). This new generation
    of variants is then evaluated and the process is repeated until a satisfactory
    solution is found. The process is repeated until an optimal, or best “good enough”,
    solution is found.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using genetic programming to solve the knapsack problem is
    that a good enough solution can be found quickly without having to exhaustively
    search through all possible solutions. This makes it a much more efficient approach
    than traditional algorithms, and allows for a much faster solution to be found.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an idea of what the knapsack problem is, what genetic programming
    is, and why we would use the latter to try and solve the former, let's have a
    look at a Python implementation of what we have described above.
  prefs: []
  type: TYPE_NORMAL
- en: We will go through the important functions one by one, and then look at the
    holistic program afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: The program is implemented in Python, using no third party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Generate random population
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function generates a random population of a given size. It uses a for loop
    to iterate through the given size, and for each iteration it creates a chromosome.
    This chromosome is a list of 0s and 1s, which is generated using the random.choice()
    function. The chromosome is then appended to the population list. Finally, the
    function prints out a message and returns the population list. This function is
    useful for creating a population of individuals for genetic algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Calculate chromosome fitness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function is used to calculate the fitness of a chromosome. It takes a chromosome
    as an argument and iterates through it. If the value of the chromosome at a given
    index is 1, it adds the corresponding item's weight and value to the total weight
    and total value respectively. If the total weight exceeds the maximum weight,
    the fitness is set to 0\. Otherwise, the fitness is set to the total value. This
    function is used in genetic algorithms to determine the fitness of a given chromosome.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Select chromosomes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function is used to select two chromosomes from a population for crossover.
    It first calculates the fitness values of each chromosome in the population using
    the calculate_fitness() function. It then normalizes the fitness values by dividing
    each value by the sum of all fitness values. Finally, it uses the random.choices()
    function to randomly select two chromosomes from the population based on the normalized
    fitness values. The two selected chromosomes are then returned as the parent chromosomes
    for crossover.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Perform crossover
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function performs crossover between two chromosomes. It takes two parent
    chromosomes as input and randomly selects a crossover point. It then creates two
    child chromosomes by combining the two parent chromosomes at the crossover point.
    The first child chromosome is created by taking the first part of the first parent
    chromosome and the second part of the second parent chromosome. The second child
    chromosome is created by taking the first part of the second parent chromosome
    and the second part of the first parent chromosome. Finally, the two child chromosomes
    are returned as the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Perform mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function performs a mutation on a chromosome. It takes in a chromosome
    as an argument and uses the random module to generate a random number between
    0 and the length of the chromosome. If the value at the mutation point is 0, it
    is changed to 1, and if it is 1, it is changed to 0\. The function then prints
    a message and returns the mutated chromosome. This function can be used to simulate
    genetic mutations in a population of organisms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Get best chromosome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function takes in a population of chromosomes and returns the best chromosome
    from the population. It does this by first creating a list of fitness values for
    each chromosome in the population. It then finds the maximum fitness value and
    its corresponding index in the list. Finally, it returns the chromosome at the
    index of the maximum fitness value. This function is useful for finding the best
    chromosome from a population of chromosomes in order to use it for further operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The control loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code is performing an evolutionary algorithm to evolve a population of
    chromosomes. It starts by looping through the specified number of generations.
    For each generation, two chromosomes are selected from the population, and then
    crossover is performed on them to generate two new chromosomes. Then, the two
    new chromosomes are subjected to mutation with a given probability. The new chromosomes
    are individually subject to a random genetic mutation if the randomly generated
    probability is above the predetermined threshold. Finally, the old population
    is replaced with the new population, which consists of the two new chromosomes
    and the remaining chromosomes from the old population.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Full Python Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we take the above functions and control loop, add a list of item along with
    a few parameters and some output to the console, we get the following full Python
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all of the parameters are hardcoded for simplicity; however, with
    little trouble one could instead accept command line arguments or solicit user
    input for any of them, including the number, value, and weight of available items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Save the above code to the file `knapsack_ga.py`, and then run it by typing
    `python knapsack_ga.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And there you go. You now know how to use genetic programming to solve the knapsack
    problem. With a little ingenuity, the above script could be modified to solve
    all sorts of computationally complex problems for their best "good enough" solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
- en: '*Portions of this article were plotted and/or written with the assistance of
    GPT-3.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Matthew Mayo](https://www.linkedin.com/in/mattmayo13/)** ([**@mattmayo13**](https://twitter.com/mattmayo13))
    is a Data Scientist and the Editor-in-Chief of KDnuggets, the seminal online Data
    Science and Machine Learning resource. His interests lie in natural language processing,
    algorithm design and optimization, unsupervised learning, neural networks, and
    automated approaches to machine learning. Matthew holds a Master''s degree in
    computer science and a graduate diploma in data mining. He can be reached at editor1
    at kdnuggets[dot]com.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Understanding and Implementing Genetic Algorithms in Python](https://www.kdnuggets.com/understanding-and-implementing-genetic-algorithms-in-python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Genetic Algorithm Key Terms, Explained](https://www.kdnuggets.com/2018/04/genetic-algorithm-key-terms-explained.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimizing Genes with a Genetic Algorithm](https://www.kdnuggets.com/2022/04/optimizing-genes-genetic-algorithm.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Range of NLP Applications in the Real World: A Different…](https://www.kdnuggets.com/2022/03/different-solution-problem-range-nlp-applications-real-world.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vanishing Gradient Problem: Causes, Consequences, and Solutions](https://www.kdnuggets.com/2022/02/vanishing-gradient-problem.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[90% of Today''s Code is Written to Prevent Failure, and That''s a Problem](https://www.kdnuggets.com/2022/07/90-today-code-written-prevent-failure-problem.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
