["```py\npip install 'ray[default]'\n```", "```py\nimport os\nimport time\nimport ray\n\n# Normal Python\ndef fibonacci_local(sequence_size):\n    fibonacci = []\n    for i in range(0, sequence_size):\n        if i < 2:\n            fibonacci.append(i)\n            continue\n        fibonacci.append(fibonacci[i-1]+fibonacci[i-2])\n    return sequence_size\n\n# Ray task\n@ray.remote\ndef fibonacci_distributed(sequence_size):\n    fibonacci = []\n    for i in range(0, sequence_size):\n        if i < 2:\n            fibonacci.append(i)\n            continue\n        fibonacci.append(fibonacci[i-1]+fibonacci[i-2])\n    return sequence_size\n```", "```py\nos.cpu_count()\n```", "```py\n# Normal Python\ndef run_local(sequence_size):\n    start_time = time.time()\n    results = [fibonacci_local(sequence_size) for _ in range(os.cpu_count())]\n    duration = time.time() - start_time\n    print('Sequence size: {}, Local execution time: {}'.format(sequence_size, duration))\n\n# Ray\ndef run_remote(sequence_size):\n    # Starting Ray\n    ray.init()\n    start_time = time.time()\n    results = ray.get([fibonacci_distributed.remote(sequence_size) for _ in range(os.cpu_count())])\n    duration = time.time() - start_time\n    print('Sequence size: {}, Remote execution time: {}'.format(sequence_size, duration))\n```", "```py\nrun_local(100000)\nrun_remote(100000)\n```", "```py\n# To explicitly stop or restart Ray, use the shutdown API\nray.shutdown()\n```", "```py\nfrom collections import namedtuple\nimport csv\nimport tarfile\nimport time\n\nimport ray\n\n@ray.remote\nclass GSODActor():\n\n    def __init__(self, year, high_temp):\n        self.high_temp = float(high_temp)\n        self.high_temp_count = None\n        self.rows = []\n        self.stations = None\n        self.year = year\n\n    def get_row_count(self):\n        return len(self.rows)\n\n    def get_high_temp_count(self):\n        if self.high_temp_count is None:\n            filtered = [l for l in self.rows if float(l.TEMP) >= self.high_temp]\n            self.high_temp_count = len(filtered)\n        return self.high_temp_count\n\n    def get_station_count(self):\n        return len(self.stations)\n\n    def get_stations(self):\n        return self.stations\n\n    def get_high_temp_count(self, stations):\n        filtered_rows = [l for l in self.rows if float(l.TEMP) >= self.high_temp and l.STATION in stations]\n        return len(filtered_rows)\n\n    def load_data(self):\n        file_name = self.year + '.tar.gz'\n        row = namedtuple('Row', ('STATION', 'DATE', 'LATITUDE', 'LONGITUDE', 'ELEVATION', 'NAME', 'TEMP', 'TEMP_ATTRIBUTES', 'DEWP',\n                                 'DEWP_ATTRIBUTES', 'SLP', 'SLP_ATTRIBUTES', 'STP', 'STP_ATTRIBUTES', 'VISIB', 'VISIB_ATTRIBUTES',\n                                 'WDSP', 'WDSP_ATTRIBUTES', 'MXSPD', \n                                 'GUST', 'MAX', 'MAX_ATTRIBUTES', 'MIN', 'MIN_ATTRIBUTES', 'PRCP',\n                                 'PRCP_ATTRIBUTES', 'SNDP', 'FRSHTT'))\n\n        tar = tarfile.open(file_name, 'r:gz')\n        for member in tar.getmembers():\n            member_handle = tar.extractfile(member)\n            byte_data = member_handle.read()\n            decoded_string = byte_data.decode()\n            lines = decoded_string.splitlines()\n            reader = csv.reader(lines, delimiter=',')\n\n            # Get all the rows in the member. Skip the header.\n            _ = next(reader)\n            file_rows = [row(*l) for l in reader]\n            self.rows += file_rows\n\n        self.stations = {l.STATION for l in self.rows}\n```", "```py\n# Code assumes you have the 1980.tar.gz and 2020.tar.gz files in your current working directory.\ndef compare_years(year1, year2, high_temp):\n\n    # if you know that you need fewer than the default number of workers,\n    # you can modify the num_cpus parameter\n    ray.init(num_cpus=2)\n\n    # Create actor processes\n    gsod_y1 = GSODActor.remote(year1, high_temp)\n    gsod_y2 = GSODActor.remote(year2, high_temp)\n\n    ray.get([gsod_y1.load_data.remote(), gsod_y2.load_data.remote()])\n\n    y1_stations, y2_stations = ray.get([gsod_y1.get_stations.remote(),\n               \t                    gsod_y2.get_stations.remote()])\n\n    intersection = set.intersection(y1_stations, y2_stations)\n\n    y1_count, y2_count = ray.get([gsod_y1.get_high_temp_count.remote(intersection),\n                                  gsod_y2.get_high_temp_count.remote(intersection)])\n\n    print('Number of stations in common: {}'.format(len(intersection)))\n    print('{} - High temp count for common stations: {}'.format(year1, y1_count))\n    print('{} - High temp count for common stations: {}'.format(year2, y2_count))\n\n#Running the code below will output which year had more extreme temperatures\ncompare_years('1980', '2020', 100)\n```"]