# 数据科学家高效编码指南

> 原文：[https://www.kdnuggets.com/2021/08/data-scientist-guide-efficient-coding-python.html](https://www.kdnuggets.com/2021/08/data-scientist-guide-efficient-coding-python.html)

[comments](#comments)

**由[Dr. Varshita Sher](https://varshitasher.medium.com/)，数据科学家**

在本文中，我想分享一些我在过去一年中吸收的编写更干净代码的技巧——主要是通过配对编程。一般来说，将这些技巧纳入我的日常编码例程中，帮助我生成高质量的Python脚本，这些脚本随着时间的推移容易维护和扩展。

> 是否曾经想过**高级开发人员的代码为何比初级开发人员的代码好得多**？继续阅读以弥合差距……

与其给出如何使用这些技巧的通用示例，不如提供我*实际*使用这些技巧的真实编码场景！如果你想跟着一起操作，这里是[Jupyter Colab Notebook](https://colab.research.google.com/drive/1gSIJd_HY88A_bq-Z0zMMzFYb1hjRI8DO?usp=sharing)。

## 1\. 在使用`for`循环时使用`tqdm`。

想象一下遍历一个*大型*可迭代对象（列表、字典、元组、集合），却不知道代码是否已经运行完！*真糟糕*，*对吧*！在这种情况下，确保使用`tqdm`构造来显示进度条。

例如，为了在读取44个不同目录中的所有文件时显示进度（这些目录的路径已经存储在名为`fpaths`的列表中）：

```py
from tqdm import tqdmfiles = list()
fpaths = ["dir1/subdir1", "dir2/subdir3", ......]

for fpath in tqdm(fpaths, desc="Looping over fpaths")):
         files.extend(os.listdir(fpath))
```

![](../Images/9bcd861ff49e3bd8b0e25a728332679a.png)

使用`tqdm`与“for”循环

*注意：使用`*desc*`参数为循环指定一个简短的描述。*

## 2\. 在编写函数时使用`type hinting`。

简而言之，这意味着在你的Python函数定义中明确声明所有参数的类型。

我希望能够提供一些具体的用例来强调*何时*我使用类型提示，但事实是，我使用它们的频率远高于不使用。

这是一个假设的函数示例`update_df()`。它通过追加一行包含模拟运行中有用信息的数据来更新给定的数据框——例如使用的分类器、准确度评分、训练-测试分割大小，以及该特定运行的附加备注。

```py
def update_df(**df: pd.DataFrame**, 
              **clf: str**, 
              **acc: float**,
              **remarks: List[str] = []**
              **split:float** = 0.5) -> **pd.DataFrame**:

    new_row = {'Classifier':clf, 
               'Accuracy':acc, 
               'split_size':split,
               'Remarks':remarks}

    df = df.append(new_row, ignore_index=True)
    return df
```

![](../Images/930d1b32e90748482182847e086597d5.png)

注意事项：

+   在函数定义中的`->`符号后面的数据类型（例如`def update_df(.......) **->** pd.DataFrame`）指示函数返回值的类型，即在这种情况下为Pandas的数据框。

+   默认值（如果有的话）可以像往常一样以`param:type = value`的形式指定。（例如：`split: float = 0.5`）

+   如果函数没有返回任何内容，可以使用`None`。例如：`def func(a: str, b: int) -> None: print(a,b)`

+   要返回混合类型的值，例如，一个函数可以在设置了`option`标志时打印语句，或者在标志未设置时返回一个`int`：

```py
from typing import Union
def dummy_args(*args: list[int], option = True) -> Union[None, int]:

     if option:

          print(args)

     else:

          return 10
```

*注意：从 Python 3.10 开始，*`*Union*`* 已不再必需，因此你可以简单地使用：*

```py
def dummy_args(*args: list[int], option = True) -> None | int:

     if option:

          print(args)

     else:

          return 10
```

+   在定义参数类型时，你可以尽可能具体，就像我们对 `remarks: List[str]` 的定义一样。我们不仅指定它应该是一个 `List`，而且应该是一个只包含 `str` 的列表。

    为了趣味，尝试在调用函数时将一个整数列表传递给 `remarks`。你会发现没有错误返回！ *这是为什么呢？* 因为 Python 解释器不会根据类型提示强制执行任何类型检查。

> [类型提示对代码的影响仅在于增加文档](https://www.pythonlikeyoumeanit.com/Module5_OddsAndEnds/Writing_Good_Code.html#What-is-It-Good-For?-(Absolutely-Nothing)).

尽管如此，包含它仍然是一个好习惯！我觉得这能在编写函数时让自己更清楚。此外，当有人调用这样的函数时，他们可以看到该函数需要哪些参数的友好提示。

![](../Images/9f1d83d3b0fc37b952d7bfb93d64ea76.png)

带有类型提示的函数调用提示

## 3\. 使用 args 和 kwargs 处理具有不确定参数数量的函数`。`

想象一下：你想编写一个函数，该函数接收 *一些* 目录路径作为输入，并打印每个目录中的文件数量。问题是，我们不知道用户会输入 *多少* 个路径！可能是 2 也可能是 20！所以我们不确定在函数定义中应定义多少个参数。显然，编写一个像 `def count_files(file1, file2, file3, …..file20)` 这样的函数会很愚蠢。在这种情况下，`args` 和（有时 `kwargs`）就非常有用！

> **Args** 用于指定不确定数量的 **位置** 参数。
> 
> **Kwargs** 用于指定不确定数量的 **关键字** 参数。

### Args

这里有一个函数 `count_files_in_dir()` 的示例，它接收 `project_root_dir` 和其中任意数量的文件夹路径（在函数定义中使用 `*fpaths`）。作为输出，它打印每个文件夹中的文件数量。

```py
def count_files_in_dir(project_root_dir, *fpaths: str):

       for path in fpaths:

            rel_path = os.path.join(project_root_dir, path)
            print(path, ":", len(os.listdir(rel_path)))
```

![](../Images/8e8c20d0e9910db055928a7971a3ff0a.png)

计算 Google Colab 目录中文件的数量

在函数调用中，我们传入了 5 个参数。由于函数定义期望一个 *必需* 的位置参数，即 `project_root_dir`，因此它自动知道 `"../usr"` 必须是这个参数。所有其余的参数（在这种情况下是四个）都被 `*fpaths` “吸收”，用于计算文件数量。

*注意：这种“吸收”技术的正确术语是“参数打包”，即剩余的参数被打包到*`**fpaths*`*中。*

### Kwargs

让我们看看那些必须接收不确定数量的 *关键字* 参数的函数。在这种情况下，我们必须使用 `kwargs` 而不是 `args`。这里有一个简短（无用）的示例：

```py
def print_results(**results):

     for key, val in results.items():
        print(key, val)
```

![](../Images/25cd205f9fd4647a869c6dfc99d2f52b.png)

用法与`*args`非常相似，但现在我们可以将任意数量的*关键字*参数传递给函数。这些参数作为键值对存储在`**results`字典中。从此以后，可以使用`.items()`轻松访问该字典中的项目。

我在工作中发现了`kwargs`的两个主要应用：

+   合并字典（*有用但不太有趣*）

```py
dict1 = {'a':2 , 'b': 20}
dict2 = {'c':15 , 'd': 40}

merged_dict = {**dict1, **dict2}

*************************
{'a': 2, 'b': 20, 'c': 15, 'd': 40}
```

+   扩展现有方法（*更有趣*）

```py
def myfunc(a, b, flag, **kwargs):

       if flag:
           a, b = do_some_computation(a,b)

       actual_function(a,b, **kwargs)
```

*注意：查看*[*matplotlib的绘图函数使用*](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib-pyplot-plot)`[*kwargs*](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib-pyplot-plot)`*来指定绘图的可选装饰，如线宽和标签。*

这是我最近一个项目中使用`**kwargs`扩展方法的一个实际用例：

我们经常使用Sklearn的`train_test_split()`来拆分`X`和`y`。在处理一个GAN项目时，我需要将生成的合成图像拆分成与拆分真实图像及其相应标签相同的训练集和测试集。此外，我还希望能够传递通常传递给`train_test_split()`的任何其他参数。最后，由于我在处理人脸识别问题（并且希望所有标签都出现在训练集和测试集中），因此`stratify`必须始终传递。

为了实现这一点，我们创建了一个名为`custom_train_test_split()`的函数。我包含了一些打印语句以展示底层发生的具体情况（为了简洁，省略了一些片段）。

```py
def custom_train_test_split(clf, y, *X, stratify, **split_args):    *print("Classifier used: ", classifier)
    print("Keys:", split_args.keys())
    print("Values: ", split_args.values())
    print(X)
    print(y)
    print("Length of passed keyword arguments: ", len(split_args))*

    trainx,testx,*synthetic,trainy,testy = train_test_split(
                                               *X,
                                               y,
                                               stratify=stratify,
                                               **split_args
                                               ) *######### OMITTED CODE SNIPPET #############
    # Train classifier on train and synthetic ims
    # Calculate accuracy on testx, testy
    ############################################*

    *print("trainx: ", trainx, "trainy: ",trainy, '\n',  "testx: ", 
    testx, "testy:", testy)* *print("synthetic: ", *synthetic)*
```

*注意：在调用此函数时，为了便于理解，我用虚拟数据替代了实际的图像向量和标签（见下图）。不过，这段代码也适用于真实图像！*

![](../Images/5c62be74580ff4d94753b0667954be87.png)

图 A 在函数定义中调用带有kwargs的函数

需要注意的几点：

+   所有的*关键字*参数（**除了**`stratify`），在函数调用语句中使用（如`train_size`和`random_state`），将作为键值对存储在`**split_args`字典中。（要验证，请查看蓝色输出。）

    你可能会问，为什么不使用`stratify`？这是因为根据函数定义，它是一个*必需*的关键字参数，而不是*可选*的。

+   所有的*非关键字*（即位置）参数（如`"SVM"`、`labels`等）会存储在函数定义中的前三个参数中，即`clf`、`y`和`*X`（是的，传递的顺序很重要）。然而，我们在函数调用中有*四个*参数，即`"SVM"`、`labels`、`ims`和`synthetic_ims`。*我们将第四个参数存储在哪里？*

    记住我们在函数定义中使用了 `*X` 作为第三个参数，因此传递给函数的所有参数在前两个参数之后都被 *打包*（浸泡）到 `*X` 中。（要验证，请查看绿色的输出）。

+   在我们的函数中调用 `train_test_split()` 方法时，我们实际上是在使用 `*` 操作符解包 `X` 和 `split_args` 参数（`*X` 和 `**split_args`），以便将它的所有元素作为不同的参数传递。

也就是说，

```py
train_test_split(*X, y, stratify = stratify, **split_args)
```

相当于编写

```py
train_test_split(ims, synthetic_ims, y, stratify = stratify, train_size = 0.6, random_state = 50)
```

+   当存储来自 `train_test_split()` 方法的结果时，我们再次 *打包* `synthetic_train` 和 `synthetic_test` 集合到一个单独的 `*synthetic` 变量中。

![](../Images/eff64186647cd1a947a83aabcbda8884.png)

要检查里面的内容，我们可以使用 `*` 操作符再次解包它（参见粉色的输出）。

*注意：如果你想深入了解使用 *`***`* 操作符进行打包和解包，请查看这篇 *[*文章*](https://realpython.com/python-kwargs-and-args/)*。*

## 4. 使用 pre-commit hooks`。`

我们编写的代码通常很混乱，缺乏适当的格式，比如多余的空格、多余的逗号、未排序的导入语句、缩进中的空格等。

虽然可以手动修复所有这些问题，但使用 [pre-commit hooks](https://pre-commit.com/) 你将节省大量时间。简单来说，这些 hooks 只需一行命令 — `pre-commit run` 即可进行自动格式化。

下面是来自官方文档的一些 [简单步骤](https://pre-commit.com/#install)，以帮助你入门并 [创建一个](https://pre-commit.com/index.html#2-add-a-pre-commit-configuration) `[.pre-commit-config.yaml](https://pre-commit.com/index.html#2-add-a-pre-commit-configuration)` [文件](https://pre-commit.com/index.html#2-add-a-pre-commit-configuration)。它将包含所有你关心的 [hooks](https://pre-commit.com/hooks.html)！

作为个人偏好，我倾向于保持我的 `.pre-commit-config.yaml` 配置文件简单，并使用 [Black 的](https://black.readthedocs.io/en/stable/integrations/source_version_control.html) pre-commit 配置。

*注意：需要记住的一点是，文件必须被暂存，即 *`*git add .*`*，然后才能执行 *`*pre-commit run*`*，否则，你会看到所有文件将被跳过：*

![](../Images/74bb1092d28f8ab78b952edfb55eebad.png)

## 5. 使用 .yml 配置文件来存储常量`。`

如果你的项目包含很多配置变量，如数据库主机名、密码、AWS 凭证等，请使用 `.yml` 文件来跟踪它们。你可以在任何 Jupyter Notebook 或脚本中使用此文件。

由于我的大部分工作旨在为客户提供模型框架，以便他们可以在自己的数据集上重新训练，我通常使用配置文件来存储文件夹和文件的路径。这也是确保客户在运行脚本时只需更改一个文件的好方法。

现在让我们在项目目录中创建一个`fpaths.yml`文件。我们将存储必须存放图片的根目录。此外，还包括文件名、标签、属性等的路径。最后，我们也会存储合成图像的路径。

```py
image_data_dir: path/to/img/dir *# the following paths are relative to images_data_dir*

fnames:

      fnames_fname: fnames.txt

      fnames_label: labels.txt

      fnames_attr: attr.txt

synthetic:

       edit_method: interface_edits

       expression: smile.pkl

       pose: pose.pkl
```

你可以像这样阅读这个文件：

```py
# open the yml file

with open(CONFIG_FPATH) as f:
     dictionary = yaml.safe_load(f)

# print elements in dictionary

for key, value in dictionary.items():
     print(key + " : " + str(value))
     print()
```

*注意：如果你想深入了解，这里有一个精彩的*[*教程*](https://www.cloudbees.com/blog/yaml-tutorial-everything-you-need-get-started)*，可以帮助你入门 YAML。*

## 6. 附加：有用的 VS-Code 扩展`.

虽然对于 Python 编辑器有许多不错的选择，但我必须说 VSCode 是我迄今为止见过的最好的编辑器（*对不起，Pycharm*）。为了更好地利用它，考虑从市场中安装以下扩展：

+   [Bracket Pair Colorizer](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer) — 允许通过颜色识别匹配的括号。

![](../Images/22f7c332c972b0d391e893eca83873db.png)

+   [Path Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense) — 允许自动完成文件名。

![](../Images/bc298c53b24cd3daaed9de47e1e6b762.png)

+   [Python Docstring generator](https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring) — 允许为 Python 函数生成文档字符串。

![](../Images/85c8b32707fe9632374d81b585627221.png)

使用 VSCode 扩展生成文档字符串

*小贴士：在使用类型提示编写函数之后（使用*`*"""*`*），生成文档字符串。这样生成的文档字符串将包含更多信息，如默认值、参数类型等（见右侧图片）。*

+   [Python Indent](https://marketplace.visualstudio.com/items?itemName=KevinRose.vsc-python-indent) — (*我最喜欢的；由* [Kevin Rose](https://marketplace.visualstudio.com/publishers/KevinRose) *发布*) 允许对多行代码/括号进行正确的缩进。

![](../Images/eee5fbeebed8adbf8634e945e0bf7d3d.png)

来源：[VSCode 扩展市场](https://marketplace.visualstudio.com/items?itemName=KevinRose.vsc-python-indent)

+   [Python Type Hint](https://marketplace.visualstudio.com/items?itemName=njqdev.vscode-python-typehint) — 允许在编写函数时自动完成类型提示。

![](../Images/92497f3d02c0316705bc33017a00d027.png)

+   [TODO tree](https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree)：（*第二喜欢的*）跟踪所有插入的`TODO`，集中在一个地方，方便管理脚本中的 TODO 注释。

![](../Images/495629a719138e57c940c0da96e57c0b.png)

跟踪项目中插入的所有 TODO 注释

+   [Pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance) — 允许代码自动完成、参数建议（以及更多功能，帮助更快地编写代码）。

恭喜你距离成为专业 Python 开发者又近了一步。我打算在学习到更多有趣的技巧时继续更新这篇文章。像往常一样，如果你知道有更简单的方法来完成我在文章中提到的一些事情，请告诉我。

下次见 :)

### 关于如何在数据科学面试中解释你的 ML 项目的逐步指南。

### 面试官最喜欢的问题 - 你如何“扩展你的 ML 模型？”

### 使用 Pandas 进行时间序列分析

### Podurama: 播客播放器

### 阅读 Varshita Sher 博士的所有故事（以及 Medium 上其他成千上万的作者的故事）

**简介： [Varshita Sher 博士](https://varshitasher.medium.com/)** 是艾伦·图灵研究所的数据科学家，同时也是牛津大学和 SFU 的校友。

[原文](https://towardsdatascience.com/data-scientists-guide-to-efficient-coding-in-python-670c78a7bf79)。获得许可后转载。

**相关：**

+   [编写干净 R 代码的 5 个技巧](/2021/08/5-tips-writing-clean-r-code.html)

+   [Python 数据结构比较](/2021/07/python-data-structures-compared.html)

+   [GitHub Copilot 开源替代品](/2021/07/github-copilot-open-source-alternatives-code-generation.html)

* * *

## 我们的前三个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析能力

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织 IT

* * *

### 更多相关话题

+   [KDnuggets 新闻，5 月 4 日：9 门免费哈佛课程学习数据…](https://www.kdnuggets.com/2022/n18.html)

+   [15 个数据科学必须知道的 Python 编程面试问题](https://www.kdnuggets.com/2022/04/15-python-coding-interview-questions-must-know-data-science.html)

+   [3 个困难的 Python 编程面试问题数据科学](https://www.kdnuggets.com/2023/03/3-hard-python-coding-interview-questions-data-science.html)

+   [免费 Python 项目编码课程](https://www.kdnuggets.com/2022/08/free-python-project-coding-course.html)

+   [7 个编程面试中必须知道的 Python 技巧](https://www.kdnuggets.com/2023/03/7-mustknow-python-tips-coding-interviews.html)

+   [通过 Ruff 提升你的 Python 编码风格](https://www.kdnuggets.com/enhance-your-python-coding-style-with-ruff)
