- en: 5 Common Python Gotchas (And How To Avoid Them)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://www.kdnuggets.com/5-common-python-gotchas-and-how-to-avoid-them](https://www.kdnuggets.com/5-common-python-gotchas-and-how-to-avoid-them)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![5 Common Python Gotchas (And How To Avoid Them)](../Images/0dd7eeede41f544136175d06e3de1e51.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Python is a beginner-friendly and versatile programming language known for its
    simplicity and readability. Its elegant syntax, however, is not immune to quirks
    that can surprise even experienced Python developers. And understanding these
    is essential for writing bug-free codeâ€”or pain-free debugging if you will.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'This tutorial explores some of these gotchas: mutable defaults, variable scope
    in loops and comprehensions, tuple assignment, and more. Weâ€™ll code simple examples
    to see *why* things work the way they do, and also look at *how* we can avoid
    these (if we actually can ðŸ™‚).'
  prefs: []
  type: TYPE_NORMAL
- en: So letâ€™s get started!
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Mutable Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, mutable defaults are common sharp corners. Youâ€™ll run into unexpected
    behavior anytime you define a function with mutable objects, like lists or dictionaries,
    as default arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**The default value is evaluated only once, when the function is defined, and
    not each time the function is called**. This can lead to unexpected behavior if
    you mutate the default argument within the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `add_to_cart` is a function that takes an item and appends
    it to a list `cart`. The default value of `cart` is an empty list. Meaning calling
    the function without an item to add returns an empty cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here are a couple of function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This works as expected. But what happens now?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because the default argument is a listâ€”a mutable objectâ€”it retains its state
    between function calls. So each time you call `add_to_cart`, it appends the value
    to the same list object created during the function definition. In this example,
    itâ€™s like all users sharing the same cart.
  prefs: []
  type: TYPE_NORMAL
- en: How To Avoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a workaround, you can set `cart` to `None` and initialize the cart inside
    the function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So each user now has a separate cart. ðŸ™‚
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a refresher on Python functions and function arguments, read [Python
    Function Arguments: A Definitive Guide](/2023/02/python-function-arguments-definitive-guide.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Variable Scope in Loops and Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's scope oddities call for a tutorial of their own. But weâ€™ll look at
    one such oddity here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The variable `x` is set to 10\. But `x` is also the looping variable. But weâ€™d
    assume that the looping variableâ€™s scope is limited to the for loop block, yes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We see that `x` is now 4, the final value it takes in the loop, and not the
    initial value of 10 we set it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now letâ€™s see what happens if we replace the for loop with a comprehension
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `x` is 10, the value we set it to before the comprehension expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How To Avoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid unexpected behavior: If youâ€™re using loops, ensure that you donâ€™t
    name the looping variable the same as another variable youâ€™d want to access later.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Integer Identity Quirk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, we use the `is` keyword for checking object identity. Meaning it
    checks whether two variables reference the same object in memory. And to check
    for equality, we use the `==` operator. Yes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start a Python REPL and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Wait, why does this happen?** Well, this is due to "integer caching" or "interning"
    in CPython, the standard implementation of Python.'
  prefs: []
  type: TYPE_NORMAL
- en: CPython [caches integer objects](https://stackoverflow.com/questions/15171695/whats-with-the-integer-cache-maintained-by-the-interpreter)
    in the range of -5 to 256\. **Meaning every time you use an integer within this
    range, Python will use the same object in memory.** Therefore, when you compare
    two integers within this range using the `is` keyword, the result is `True` because
    they *refer to the same object in memory*.
  prefs: []
  type: TYPE_NORMAL
- en: Thatâ€™s why `a is b` returns `True`. You can also verify this by printing out
    `id(a)` and `id(b)`.
  prefs: []
  type: TYPE_NORMAL
- en: However, integers outside this range are not cached. And each occurrence of
    such integers creates a new object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: So when you compare two integers outside the cached range using the `is` keyword
    (yes, `x` and `y` both set to 280 in our example), the result is `False` because
    they are indeed two different objects in memory.
  prefs: []
  type: TYPE_NORMAL
- en: How To Avoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This behavior shouldnâ€™t be a problem unless you try to use the `is` for comparing
    equality of two objects. So always use the `==` operator to check if any two Python
    objects have the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Tuple Assignment and Mutable Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If youâ€™re familiar with built-in data structures in Python, you know that tuples
    are **immutable**. So you *cannot* modify them in place. Data structures like
    lists and dictionaries, on the other hand, are **mutable**. Meaning you *can*
    change them in place.
  prefs: []
  type: TYPE_NORMAL
- en: '**But what about tuples that contain one or more mutable objects?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s helpful to started a Python REPL and run this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first element of the tuple is a list with two elements. We try appending
    3 to the first list and it works fine! Well, did we just modify a tuple in place?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now letâ€™s try to add two more elements to the list, but this time using the
    += operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, you get a TypeError which says the tuple object does not support item
    assignment. Which is expected. But letâ€™s check the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We see that elements 4 and 5 have been added to the list! Did the program just
    throw an error and succeed at the same time?
  prefs: []
  type: TYPE_NORMAL
- en: Well the += operator internally works by calling the `__iadd__()` method which
    performs in-place addition and modifies the list in place. The assignment raises
    a TypeError exception, but the addition of elements to the end of the list has
    already succeeded. += is perhaps the sharpest corner!
  prefs: []
  type: TYPE_NORMAL
- en: How To Avoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To avoid such quirks in your program, try using tuples *only* for immutable
    collections. And avoid using mutable objects as tuple elements as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Shallow Copies of Mutable Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutability has been a recurring topic in our discussion thus far. So hereâ€™s
    another one to wrap up this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you may need to create independent copies of lists. But what happens
    when you create a copy using a syntax similar to `list2 = list1` where `list1`
    is the original list?
  prefs: []
  type: TYPE_NORMAL
- en: Itâ€™s a shallow copy that gets created. So it only copies the references to the
    original elements of the list. Modifying elements through the shallow copy will
    affect *both* the original list *and* the shallow copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the changes to the shallow copy also affect the original list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we modify the first element of the first nested list in the shallow copy:
    `shallow_copy[0][0] = 100`. But we see that the modification affects both the
    original list and the shallow copy.'
  prefs: []
  type: TYPE_NORMAL
- en: How To Avoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid this, you can create a deep copy like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, any modification to the deep copy leaves the original list unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And thatâ€™s a wrap! In this tutorial, we''ve explored several oddities in Python:
    from the surprising behavior of mutable defaults to the subtleties of shallow
    copying lists. This is only an introduction to Pythonâ€™s oddities and is by no
    means an exhaustive list. You can find all the code examples [on GitHub](https://github.com/balapriyac/python-basics/tree/main/common-gotchas).'
  prefs: []
  type: TYPE_NORMAL
- en: As you keep coding for longer in Pythonâ€”and understand the language betterâ€”youâ€™ll
    perhaps run into many more of these. So, keep coding, keep exploring!
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and let us know in the comments if youâ€™d like to read a sequel to this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: '**[](https://twitter.com/balawc27)**[Bala Priya C](https://www.kdnuggets.com/wp-content/uploads/bala-priya-author-image-update-230821.jpg)****
    is a developer and technical writer from India. She likes working at the intersection
    of math, programming, data science, and content creation. Her areas of interest
    and expertise include DevOps, data science, and natural language processing. She
    enjoys reading, writing, coding, and coffee! Currently, she''s working on learning
    and sharing her knowledge with the developer community by authoring tutorials,
    how-to guides, opinion pieces, and more. Bala also creates engaging resource overviews
    and coding tutorials.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[5 Common Data Science Mistakes and How to Avoid Them](https://www.kdnuggets.com/5-common-data-science-mistakes-and-how-to-avoid-them)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3 Crucial Challenges in Conversational AI Development and How to Avoid Them](https://www.kdnuggets.com/3-crucial-challenges-in-conversational-ai-development-and-how-to-avoid-them)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoid These 5 Common Mistakes Every Novice in AI Makes](https://www.kdnuggets.com/avoid-these-5-common-mistakes-every-novice-in-ai-makes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10 Most Common Data Quality Issues and How to Fix Them](https://www.kdnuggets.com/2022/11/10-common-data-quality-issues-fix.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News, August 24: Implementing DBSCAN in Python â€¢ How toâ€¦](https://www.kdnuggets.com/2022/n34.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common Data Problems (and Solutions)](https://www.kdnuggets.com/2022/02/common-data-problems-solutions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
