- en: 'Essential Math for Data Science: Integrals And Area Under The Curve'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据科学中的基础数学：积分与曲线下的面积
- en: 原文：[https://www.kdnuggets.com/2020/11/essential-math-data-science-integrals-area-under-curve.html](https://www.kdnuggets.com/2020/11/essential-math-data-science-integrals-area-under-curve.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2020/11/essential-math-data-science-integrals-area-under-curve.html](https://www.kdnuggets.com/2020/11/essential-math-data-science-integrals-area-under-curve.html)
- en: '[comments](#comments)[![Image](../Images/45c05efbbd9635efb62adde614427da4.png)](https://www.essentialmathfordatascience.com/)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](#comments)[![图片](../Images/45c05efbbd9635efb62adde614427da4.png)](https://www.essentialmathfordatascience.com/)'
- en: 'Calculus is a branch of mathematics that gives tools to study the rate of change
    of functions through two main areas: derivatives and integrals. In the context
    of machine learning and data science, you might use integrals to calculate the
    area under the curve (for instance, to evaluate the performance of a model with
    the ROC curve, or to calculate probability from densities.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分是数学的一个分支，提供了研究函数变化率的工具，通过两个主要领域：导数和积分。在机器学习和数据科学的背景下，你可能会使用积分来计算曲线下的面积（例如，用于评估模型的性能与ROC曲线，或从密度中计算概率）。
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our Top 3 Course Recommendations
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的前三个课程推荐
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity)
    - 快速进入网络安全职业生涯。'
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics)
    - 提升你的数据分析技能'
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌IT支持专业证书](https://www.kdnuggets.com/google-itsupport)
    - 支持你的组织的IT'
- en: '* * *'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In this article, you’ll learn about integrals and the area under the curve using
    the practical data science example of the area under the ROC curve used to compare
    the performances of two machine learning models. Building from this example, you’ll
    see the notion of the area under the curve and integrals from a mathematical point
    of view (from my book Essential Math for Data Science).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，你将通过使用ROC曲线下的面积这一实际数据科学示例来学习积分和曲线下的面积。以此示例为基础，你将从数学角度了解曲线下的面积和积分（参考我的书《数据科学中的基础数学》）。
- en: Practical Project
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践项目
- en: Let’s say that you would like to predict the quality of wines from various of
    their chemical properties. You want to do a binary classification of the quality
    (distinguishing very good wines from not very good ones). You’ll develop methods
    allowing you to evaluate your models considering imbalanced data with the area
    under the Receiver Operating Characteristics (ROC) curve.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想根据红酒的各种化学属性预测其质量。你希望对质量进行二分类（区分非常好的酒和不是很好的酒）。你将开发方法来评估考虑到不平衡数据的模型，利用接收者操作特征（ROC）曲线下的面积。
- en: '**Dataset**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据集**'
- en: 'To do this, we’ll use a dataset showing various chemical properties of red
    wines and ratings of their quality. The dataset comes from here: https://archive.ics.uci.edu/ml/datasets/wine+quality.
    The related paper is Cortez, Paulo, et al. ”Modeling wine preferences by data
    mining from physicochemical properties.” Decision Support Systems 47.4 (2009):
    547-553.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '为此，我们将使用一个数据集，展示红酒的各种化学性质及其质量评分。数据集来源于此：https://archive.ics.uci.edu/ml/datasets/wine+quality。相关论文为Cortez,
    Paulo, et al. ”通过从物理化学性质中挖掘数据建模酒类偏好。” Decision Support Systems 47.4 (2009): 547-553。'
- en: '![Figure](../Images/622f9846821726cb0886d511fd86d51c.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/622f9846821726cb0886d511fd86d51c.png)'
- en: '*Figure 1: Illustration of wine quality modeling.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1：酒质建模的示意图。*'
- en: 'As illustrated in Figure 1, the dataset represents chemical analyses of wines
    (the features) and ratings of their quality. This rating is the target: this is
    what you’ll try to estimate.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如图1所示，数据集表示了酒的化学分析（特征）和质量评分。这个评分是目标：这是你将尝试估计的内容。
- en: 'First, let’s load the data and have a look at the features:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们加载数据并查看特征：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last column `quality` is important as you’ll use it as the target of your
    classification. The quality is described by ratings from 3 to 8:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一列`quality`很重要，因为你将把它作为分类的目标。质量通过从3到8的评级来描述：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the goal is to classify red wines of *very good* quality, let’s decide
    that the wines are very good when ratings are 7 or 8 and not very good otherwise.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标是对*非常好的*红酒进行分类，让我们决定当评分为7或8时葡萄酒是非常好的，否则不是非常好。
- en: Let’s create the dataset with `y` being the quality (the dependent variable,
    0 for ratings less than 7 and 1 for ratings greater than or equal 7) and `X` containing
    all the other features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个数据集，其中`y`为质量（因变量，评分低于7为0，评分大于或等于7为1），`X`包含所有其他特征。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing to do, before looking at the data, is to split it in a part
    for training your algorithms (the training set) and a part for testing them (the
    test set). This will allow you to evaluate the performance of your model on data
    unseen during the training.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看数据之前，首先要做的事情是将数据分为训练集（用于训练算法）和测试集（用于测试算法）。这将允许你评估模型在训练过程中未见过的数据上的表现。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Preprocessing**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**预处理**'
- en: As a first step, let’s standardize the data to help the convergence of the algorithm.
    You can use the class `StandardScaler` from Sklearn.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对数据进行标准化，以帮助算法的收敛。你可以使用Sklearn中的`StandardScaler`类。
- en: Note that you don’t want to consider the data from the test set to do the standardization.
    The method `fit_transform()` calculates the parameters needed for the standardization
    and apply it at the same time. Then, you can apply the same standardization to
    the test set without fitting again.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不想考虑测试集的数据来进行标准化。方法`fit_transform()`计算标准化所需的参数并同时应用它。然后，你可以将相同的标准化应用于测试集，而无需再次拟合。
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**First Model**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一个模型**'
- en: 'As a first model, let’s train a logistic regression on the training set and
    calculate the classification accuracy (the percentage of correct classifications)
    on the test set:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个模型，让我们在训练集上训练一个逻辑回归模型，并计算测试集上的分类准确率（正确分类的百分比）：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The accuracy is about 0.87, meaning that 87% of the test examples have been
    correctly classified. Should you be happy with this result?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 准确率约为0.87，这意味着87%的测试样本被正确分类。你应该对这个结果感到满意吗？
- en: Metrics for Imbalanced Datasets
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不平衡数据集的指标
- en: '**Imbalanced Dataset**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**不平衡数据集**'
- en: 'Since we separated the data into very good wines and not very good wines, the
    dataset is *imbalanced*: there are different quantities of data corresponding
    to each target class.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将数据分为非常好的葡萄酒和不太好的葡萄酒，数据集是*不平衡的*：每个目标类别的数据量不同。
- en: 'Let’s check how many observations you have in the negative (not very good wines)
    and positive classes (very good wines):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下负类（不太好的葡萄酒）和正类（非常好的葡萄酒）的观察数量：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It shows that there are around 86.5% of the examples corresponding to class
    0 and 13.5% to class 1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明大约有86.5%的样本对应于类别0，13.5%对应于类别1。
- en: '**Simple Model**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单模型**'
- en: To illustrate this point about accuracy and imbalanced datasets, let’s creates
    a model as a baseline and look at its performance. It will help you to see the
    advantages to use other metrics than accuracy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明关于准确率和不平衡数据集的这一点，让我们创建一个基线模型并查看其性能。这将帮助你看到使用其他指标而非准确率的优点。
- en: A very simple model using the fact that the dataset is imbalanced would always
    estimate the class with the largest number of observations. In your case, such
    a model would always estimate that all wines are bad and get a decent accuracy
    doing that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的模型利用数据集不平衡的事实，会总是估计具有最多观察数量的类别。在你的案例中，这样的模型总是会估计所有葡萄酒都很差，并且得到不错的准确率。
- en: Let’s simulate this model by creating random probabilities below 0.5 (for instance,
    a probability of 0.15 means that there is a 15% chance that the class is positive).
    We need these probabilities to calculate both the accuracy and other metrics.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建低于0.5的随机概率来模拟这个模型（例如，0.15的概率表示类别为正的机会是15%）。我们需要这些概率来计算准确率和其他指标。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s say that if the probability is above 0.5, the class is estimated as positive:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设如果概率高于0.5，则类别被估计为正：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The variable `y_pred_random` contains only zeros. Let’s evaluate the accuracy
    of this random model:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`y_pred_random`仅包含零。让我们评估这个随机模型的准确性：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This shows that, even with a random model, the accuracy is not bad at all:
    it doesn’t mean that the model is good.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，即使使用随机模型，准确度也并不差：这并不意味着模型很好。
- en: To summarize, having a different number of observations corresponding to each
    class, you can’t rely on the accuracy to evaluate your model’s performance. In
    our example, the model could output only zeros and you would get around 86% accuracy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，拥有不同数量的每个类别的观察样本时，你不能仅依靠准确度来评估模型的性能。在我们的例子中，模型可能只输出零，你会得到大约86%的准确度。
- en: You need other metrics to assess the performance of models with imbalanced datasets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要其他指标来评估在不平衡数据集上的模型性能。
- en: '**ROC Curves**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROC曲线**'
- en: 'A good alternative to the accuracy is the Receiver Operating Characteristics
    (ROC) curve. You can check the very good explanations of Aurélien Géron about
    ROC curves in Géron, Aurélien. Hands-on machine learning with Scikit-Learn, Keras,
    and TensorFlow: Concepts, tools, and techniques to build intelligent systems.
    O’Reilly Media, 2019.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '准确度的一个很好的替代指标是接收者操作特征（ROC）曲线。你可以查看Aurélien Géron对ROC曲线的非常好的解释，详见Géron, Aurélien.
    *Hands-on machine learning with Scikit-Learn, Keras, and TensorFlow: Concepts,
    tools, and techniques to build intelligent systems*. O’Reilly Media, 2019。'
- en: 'The main idea is to separate the estimations from the model into four categories:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是将模型的估计结果分成四类：
- en: 'The true positives (TP): the prediction is 1 and the true class is 1.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正类（TP）：预测为1且真实类别为1。
- en: 'The false positives (FP): the prediction is 1 but the true class is 0.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假阳性（FP）：预测为1但真实类别为0。
- en: 'The true negatives (TN): the prediction is 0 and the true class is 0.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真负类（TN）：预测为0且真实类别为0。
- en: 'The false negatives (FN): the prediction is 0 but the true class is 1.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假负类（FN）：预测为0但真实类别为1。
- en: 'Let’s calculate these values for your first logistic regression model. You
    can use the function `confusion_matrix` from Sklearn. It presents a table organized
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算一下你第一个逻辑回归模型的这些值。你可以使用Sklearn中的函数`confusion_matrix`。它呈现的表格组织如下：
- en: '![Figure](../Images/3da6c540c32f461e174300a202c16a44.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/3da6c540c32f461e174300a202c16a44.png)'
- en: '*Figure 2: Illustration of a confusion matrix.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2：混淆矩阵的示意图。*'
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see that there is no positive observation that has been correctly classified
    (TP) with the random model.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在随机模型下，没有正类观察被正确分类（TP）。
- en: '**Decision Threshold**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**决策阈值**'
- en: In classification tasks, you want to estimate the class of data samples. For
    models like logistic regression which outputs probabilities between 0 and 1, you
    need to convert this score to the class 0 or 1 using a *decision threshold*, or
    just *threshold*. A probability above the threshold is considered as a positive
    class. For instance, using the default choice of the decision threshold at 0.5,
    you consider that the estimated class is 1 when the model outputs a score above
    0.5.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在分类任务中，你需要估计数据样本的类别。对于像逻辑回归这样的模型，它输出的是0到1之间的概率，你需要使用*决策阈值*或简称*阈值*将这个分数转换为类别0或1。超过阈值的概率被视为正类。例如，使用默认的决策阈值0.5时，当模型输出的分数超过0.5时，你认为估计类别是1。
- en: However, you can choose other thresholds, and the metrics you use to evaluate
    the performance of your model will depend on this threshold.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以选择其他阈值，你用来评估模型性能的指标将取决于这个阈值。
- en: With the ROC curve, you consider multiple thresholds between 0 and 1 and calculate
    the true positive rate as a function of the false positive rate for each of them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ROC曲线，你会考虑0到1之间的多个阈值，并计算每个阈值下的真正率与假阳性率的关系。
- en: You can use the function `roc_curve` from Sklearn to calculate the false positive
    rate (fpr) and the true positive rate (tpr). The function outputs also the corresponding
    thresholds. Let’s try it with our simulated random model where outputs are only
    values bellow 0.5 (`y_pred_random_proba`).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Sklearn中的函数`roc_curve`来计算假阳性率（fpr）和真正率（tpr）。该函数还输出相应的阈值。让我们用我们模拟的随机模型尝试一下，其中输出值仅在0.5以下（`y_pred_random_proba`）。
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s have a look at the outputs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下输出结果：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can now plot the ROC curve from these values:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以根据这些值绘制ROC曲线：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Figure](../Images/0551fd39a886a7516aa8de613be795ad.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/0551fd39a886a7516aa8de613be795ad.png)'
- en: '*Figure 3: ROC curve corresponding to the random model.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3：对应于随机模型的ROC曲线。*'
- en: Figure 3 shows the ROC curve corresponding to the random model. It gives you
    the true positive rate as a function of the false positive rate for each threshold.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图3显示了对应于随机模型的ROC曲线。它给出了每个阈值下真正正例率作为假阳性率的函数。
- en: 'However, be careful, the thresholds are from 1 to 0\. For instance, the point
    at the bottom left corresponds to a threshold of 1: there is 0 true positive and
    0 false positive because it is not possible to have a probability above 1, so
    with a threshold of 1, no observation can be categorized as positive. At the top
    right, the threshold is 0, so all observations are categorized as positive, leading
    to 100% of true positive but also 100% of false positive.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，阈值范围从1到0。例如，左下角的点对应于阈值为1：此时没有真正的正例和假阳性，因为概率不可能超过1，因此在阈值为1的情况下，没有观测值可以被分类为正例。在右上角，阈值为0，因此所有观测值都被归类为正例，导致真正的正例和假阳性都达到100%。
- en: A ROC curve around the diagonal means that the model is not better than random
    which is the case here. A perfect model would be associated with a ROC curve with
    a true positive rate of 1 for all values of false positive rate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ROC曲线接近对角线意味着模型不比随机模型好，这就是这里的情况。一个完美的模型应该与一个ROC曲线相关联，该曲线在所有假阳性率的值下的真正正例率为1。
- en: 'Let’s now look at the ROC curve corresponding to the logistic regression model
    you trained earlier. You’ll need probabilities from the model, that you can get
    using `predict_proba()` instead of `predict`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下你之前训练的逻辑回归模型对应的ROC曲线。你需要模型的概率，这可以通过使用`predict_proba()`而不是`predict`来获取：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first column is the score for the class 0 and the second column for the
    score 1 (thus, the total of each row is 1), so you can keep the second column
    only.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是类别0的分数，第二列是类别1的分数（因此每行的总和为1），所以你可以只保留第二列。
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Figure](../Images/e3c42300bd0d64dc35a743fc87c27ab1.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/e3c42300bd0d64dc35a743fc87c27ab1.png)'
- en: '*Figure 4: ROC curve corresponding to the logistic model.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4：对应于逻辑模型的ROC曲线。*'
- en: 'You can see in Figure 4 that your model is actually better than a random model,
    which is not something you were able to know from the model accuracies (they were
    equivalent: around 0.86 for the random model and 0.87 for your model).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图4中看到你的模型实际上比随机模型要好，这不是你从模型准确率中能够得出的结论（它们是等效的：随机模型约为0.86，你的模型约为0.87）。
- en: Visual inspection is good, but it would also be crucial to have a single numerical
    metric to compare your models. This is usually provided by the area under the
    ROC curve. You’ll see what is the area under the curve and how you can calculate
    in the next sections.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉检查是好的，但拥有一个单一的数值指标来比较你的模型也至关重要。这通常由ROC曲线下的面积提供。你将在接下来的章节中看到曲线下的面积是什么以及如何计算。
- en: Integrals
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 积分
- en: '*Integration* is the inverse operation of differentiation. Take a function *f(x)* and
    calculate its derivative *f′(x)*, the *indefinite integral* (also called *antiderivative*)
    of *f′(x)* gives you back *f(x)* (up to a constant, as you’ll soon see).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*积分*是微分的逆操作。取一个函数*f(x)*并计算其导数*f′(x)*，*不定积分*（也称为*反导数*）的*f′(x)*会恢复*f(x)*（除了一个常数，如你将很快看到的那样）。'
- en: You can use integration to calculate the *area under the curve*, which is the
    area of the shape delimited by the function, as shown in Figure 5.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用积分来计算*曲线下的面积*，这就是由函数限定的形状的面积，如图5所示。
- en: '![Figure](../Images/f07a129e494d5752224664b14379ba83.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/f07a129e494d5752224664b14379ba83.png)'
- en: '*Figure 5: Area under the curve.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5：曲线下的面积。*'
- en: A *definite integral* is the integral over a specific interval. It corresponds
    to the area under the curve in this interval.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*定积分*是特定区间上的积分。它对应于该区间内的曲线下的面积。'
- en: Example
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: You’ll see through this example how to understand the relationship between the
    integral of a function and the area under the curve. To illustrate the process,
    you’ll approximate the integral of the function *g(x)=2x* using a discretization
    of the area under the curve.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，你将了解函数的积分与曲线下的面积之间的关系。为了说明这个过程，你将使用曲线下的面积的离散化来近似函数*g(x)=2x*的积分。
- en: '**Example Description**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例描述**'
- en: Let’s take again the example of the moving train. You saw that speed as a function
    of time was the derivative of distance as a function of time. These functions
    are represented in Figure 6.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次以移动火车为例。你看到速度作为时间的函数是距离作为时间的函数的导数。这些函数在图6中表示。
- en: '![Figure](../Images/3111fddbf419701aa8e167755e97a86c.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/3111fddbf419701aa8e167755e97a86c.png)'
- en: '*Figure 6: The left panel shows *f(x)* which is the distance as a function
    of time, and the right panel its derivative *g(x)*, which is the speed as a function
    of time.*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6：左侧面板显示*f(x)*，它是时间函数的距离，右侧面板显示其导数*g(x)*，它是时间函数的速度。*'
- en: The function shown in the left panel of Figure 6 is defined as *f(x)=x²*. Its
    derivative is defined as *g(x)=2x*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6左侧面板中显示的函数定义为*f(x)=x²*。它的导数定义为*g(x)=2x*。
- en: In this example, you’ll learn how to find an approximation of the area under
    the curve of *g(x)*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将学习如何找到*g(x)*曲线下方区域的近似值。
- en: '**Slicing the Function**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数切片**'
- en: 'To approximate the area of a shape, you can use the slicing method: you cut
    the shape into small slices with an easy shape like rectangles, calculate the
    area of each of these slices and sum them.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要近似一个形状的面积，你可以使用切片方法：将形状切成小的矩形，计算这些矩形的面积并求和。
- en: You’ll do exactly that to find an approximation of the area under the curve
    of *g(x)*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将完全按照这种方法来找到*g(x)*曲线下方区域的近似值。
- en: '![Figure](../Images/1908cc700b096a7ac86f4da2dd4fb59c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图形](../Images/1908cc700b096a7ac86f4da2dd4fb59c.png)'
- en: '*Figure 7: Approximation of the area under the curve by discretizing the area
    under the curve of speed as a function of time.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7：通过将速度曲线下方的区域离散化来近似曲线下方的面积。*'
- en: Figure 7 shows the area under the curve of *f′(x)* sliced as one-second rectangles
    (let’s call this difference *Δx*). Note that we underestimate the area (look at
    the missing triangles), but we’ll fix that later.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7显示了*f′(x)*曲线下方的区域被切成了一秒的矩形（我们称这种差异为*Δx*）。请注意，我们低估了该区域（查看缺失的三角形），但我们稍后会修正这个问题。
- en: 'Let’s try to understand the meaning of the slices. Take the first one: its
    area is defined as 2⋅12⋅1\. The height of the slice is the speed at one second
    (the value is 2). So there are two units of speed by one unit of time for this
    first slice. The area corresponds to a multiplication between speed and time:
    this is a distance.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解切片的含义。以第一个切片为例：它的面积定义为2⋅12⋅1。切片的高度是一个秒钟内的速度（值为2）。因此，第一个切片在单位时间内有两个速度单位。面积对应于速度和时间的乘积：这就是距离。
- en: 'For instance, if you drive at 50 miles per hour (speed) for two hours (time),
    you traveled *50⋅2=100 miles* (distance). This is because the unit of speed corresponds
    to a ratio between distance and time (like miles *per* hour). You get:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你以每小时50英里的速度行驶两小时（时间），你 traveled *50⋅2=100 miles*（距离）。这是因为速度的单位对应于距离和时间之间的比率（如每小时英里）。你可以得到：
- en: '![Image](../Images/215aa2a2d5a353ae41f3c673251339f1.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/215aa2a2d5a353ae41f3c673251339f1.png)'
- en: To summarize, the derivative of the distance by time function is the speed by
    time function, and the area under the curve of the speed by time function (its
    integral) gives you a distance. This is how derivatives and integrals are related.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，距离对时间函数的导数是速度对时间函数，而速度对时间函数的曲线下方的面积（它的积分）给你一个距离。这就是导数和积分之间的关系。
- en: '**Implementation**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现**'
- en: 'Let’s use slicing to approximate the integral of the function *g(x)=2x*. First,
    let’s define the function *g(x)*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用切片来近似*g(x)=2x*的积分。首先，让我们定义函数*g(x)*：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As illustrated in Figure 7, you’ll consider that the function is discrete and
    take a step of *Δx=1*. You can create an *x*-axis with values from zero to six,
    and apply the function `g_2x()` for each of these values. You can use the Numpy
    method `arange(start, stop, step)` to create an array filled with values from `start` to `stop` (not
    included):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7所示，你将考虑函数是离散的，并取步长为*Δx=1*。你可以创建一个值从零到六的*x*轴，并对每一个这些值应用函数`g_2x()`。你可以使用Numpy方法`arange(start,
    stop, step)`来创建一个包含从`start`到`stop`（不包括）的值的数组：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can then calculate the slice’s areas by iterating and multiplying the width
    (*Δx*) by the height (the value of *y* at this point). of the slice. As you saw,
    this area (`delta_x * y[i-1]` in the code below) corresponds to a distance (the
    distance of the moving train traveled during the *i*th slice). You can finally
    append the results to an array (`slice_area_all` in the code below).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以通过迭代计算切片的面积，将宽度（*Δx*）乘以高度（该点的*y*值）。如你所见，这个面积（`delta_x * y[i-1]`在下面的代码中）对应于距离（移动列车在第*i*个切片中行驶的距离）。最后，你可以将结果附加到一个数组中（`slice_area_all`在下面的代码中）。
- en: Note that the index of `y` is `i-1` because the rectangle is on the left of
    the *x* value we estimate. For instance, the area is zero for *x=0* and *x=1*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`y`的索引是`i-1`，因为矩形在我们估计的*x*值的左侧。例如，*x=0*和*x=1*的面积为零。
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These values are the slice’s areas.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是切片的面积。
- en: 'To calculate the distance traveled from the beginning to the corresponding
    time point (and not corresponding to each slice), you can calculate the cumulative
    sum of `slice_area_all` with the Numpy function `cumsum()`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算从开始到相应时间点的行驶距离（而不是每个切片），可以使用 Numpy 函数`cumsum()`计算`slice_area_all`的累积和：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is the estimated values of the area under the curve of *g(x)* as a function
    of *x*. We know that the function *g(x)* is the derivative of *f(x)=x²*, so we
    should get back *f(x)* by the integration of *g(x)*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*【g(x)】* 在*【x】*上的曲线下的面积的估计值。我们知道函数*【g(x)】* 是*f(x)=x²* 的导数，因此我们应该通过对*g(x)*的积分得到*f(x)*。
- en: 'Let’s plot our estimation and f(x)f(x), which we’ll call the “true function”,
    to compare them:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制我们的估计和*f(x)*，我们称之为“真实函数”，以进行比较：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Figure](../Images/7d1175a378bc8901953ffa92884e9a31.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/7d1175a378bc8901953ffa92884e9a31.png)'
- en: '*Figure 8: Comparison of estimated and original function.*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8：估计函数与原始函数的比较。*'
- en: The estimation represented in Figure 8 shows that the estimation is not bad,
    but could be improved. This is because we missed all these triangles represented
    in red in Figure
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8 中所示的估计结果表明估计值还不错，但可以改进。这是因为我们遗漏了图中红色表示的所有这些三角形。
- en: One way to reduce the error is to take a smaller value for ΔxΔx, as illustrated
    in the right panel in Figure 9.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少误差的一种方法是取更小的*Δx*值，如图 9 右侧面板所示。
- en: '![Figure](../Images/ac06608555a71e705993b2faafb6a93e.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/ac06608555a71e705993b2faafb6a93e.png)'
- en: '*Figure 9: Missing parts in slices of the speed function (in red). The error
    is smaller with a smaller *Δx*.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9：速度函数切片中的缺失部分（红色标记）。误差随着*Δx*的减小而变小。*'
- en: 'Let’s estimate the integral function with *Δx=0.1*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用*Δx=0.1*来估计积分函数：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Figure](../Images/eb7532de963fc9ab64b708791ecd6004.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/eb7532de963fc9ab64b708791ecd6004.png)'
- en: '*Figure 10: Smaller slice widths lead to a better estimation of the original
    function.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10：较小的切片宽度导致对原始函数的更好估计。*'
- en: As shown in Figure 10, we recovered (at least, up to an additive constant) the
    original function whose derivative we integrated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 10 所示，我们恢复了（至少，加上一个常数）我们积分的原始函数。
- en: '**Extension**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展**'
- en: In our previous example, you integrated the function *2x*, which is a linear
    function, but the principle is the same for any continuous function (see Figure
    11 for instance).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，你对函数*2x*进行了积分，这是一个线性函数，但对任何连续函数原则是相同的（例如，见图 11）。
- en: '![Figure](../Images/baae33f15e4740d3b6e55eb126e4e935.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/baae33f15e4740d3b6e55eb126e4e935.png)'
- en: '*Figure 11: The slicing method can be used with many linear or nonlinear function,
    including all continuous functions.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11：切片方法可以用于许多线性或非线性函数，包括所有连续函数。*'
- en: Riemann Sum
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 黎曼和
- en: Approximating an integral using this slicing method is called a *Riemann sum*.
    Riemann sums can be calculated in different ways, as you can see in Figure 12.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种切片方法来近似积分被称为*黎曼和*。黎曼和可以通过不同的方式计算，如图 12 所示。
- en: '![Figure](../Images/479e0604f9d8c94823f9a2b6ebf7a091.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/479e0604f9d8c94823f9a2b6ebf7a091.png)'
- en: '*Figure 12: Four kinds of Riemann sums for integral approximation.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12：四种用于积分逼近的黎曼和。*'
- en: As pictured in Figure 12, with the left Riemann sum, the curve is aligned with
    the left corner of the rectangle. With the right Riemann sum, the curve is aligned
    with the right corner of the rectangle. With the midpoint rule, the curve is aligned
    with the center of the rectangle. With the trapezoidal rule, a trapezoidal shape
    is used instead of a rectangle. The curve crosses both top corners of the trapezoid.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 12 所示，左侧黎曼和中，曲线与矩形的左角对齐；右侧黎曼和中，曲线与矩形的右角对齐；中点规则中，曲线与矩形的中心对齐；梯形规则中，使用梯形代替矩形，曲线穿过梯形的两个上角。
- en: Mathematical Definition
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学定义
- en: In the last section, you saw the relationship between the area under the curve
    and integration (you got back the original function from the derivative). Let’s
    see now the mathematical definition of integrals.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到了曲线下的面积与积分之间的关系（你通过导数恢复了原始函数）。现在我们来看一下积分的数学定义。
- en: 'The integrals of the function *f(x)* with respect to *x* is denoted as following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数*f(x)* 相对于*x* 的积分表示为：
- en: '*∫f(x)dx*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*∫f(x)dx*'
- en: The symbol *dx* is called the *differential* of *x* and refers to the idea of
    an infinitesimal change of *x*. It is a difference in *x* that approaches 0\.
    The main idea of integrals is to sum an infinite number of slices which have an
    infinitely small width.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 符号*dx*称为*x*的*differential*，指的是*x*的一个微小变化。它是接近0的*x*的差异。积分的主要思想是对无限多个宽度极小的切片进行求和。
- en: The symbol *∫* is the integral sign and refers to the sum of an infinite number
    of slices.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 符号*∫*是积分符号，指的是对无限多个切片的和。
- en: The height of each slice is the value *f(x)*. The multiplication of *f(x)* and *dx* is
    thus the area of each slice. Finally, *∫f(x):dx* is the sum of the slice areas
    over an infinite number of slices (the width of the slices tending to zero). This
    is the *area under the curve*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个切片的高度是*f(x)*的值。*f(x)*与*dx*的乘积就是每个切片的面积。最后，*∫f(x):dx*是对无限多个切片（切片宽度趋近于零）的切片面积的和。这就是*曲线下的面积*。
- en: 'You saw in the last section how to approximate function integrals. But if you
    know the derivative of a function, you can retrieve the integral knowing that
    it is the inverse operation. For example, if you know that:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一部分中看到过如何近似函数积分。但如果你知道一个函数的导数，你可以通过知道它是反操作来检索积分。例如，如果你知道：
- en: '*d(x2)dx=2x*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*d(x²)dx=2x*'
- en: You can conclude that the integral of *2x* is *x2*. However, there is a problem.
    If you add a constant to our function the derivative is the same because the derivative
    of a constant is zero. For instance,
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以得出*2x*的积分是*x²*。然而，这里有一个问题。如果你在函数中加上一个常数，导数仍然相同，因为常数的导数为零。例如，
- en: '*d(x²+3)dx=2x*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*d(x²+3)dx=2x*'
- en: 'It is impossible to know the value of the constant. For this reason, you need
    to add an unknown constant to the expression, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 常数的值是不可能知道的。因此，你需要在表达式中添加一个未知常数，如下所示：
- en: '*∫2xdx=x²+c*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*∫2xdx=x²+c*'
- en: with cc being a constant.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其中cc是一个常数。
- en: '**Definite Integrals**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**定积分**'
- en: 'In the case of *definite integrals*, you denote the interval of integration
    with numbers below and above the integral symbol, as following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在*定积分*的情况下，你用积分符号下方和上方的数字来表示积分区间，如下：
- en: '*∫baf(x)dx*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*∫baf(x)dx*'
- en: It corresponds to the area under the curve of the function *f(x)* between *x=a* and *x=b*,
    as illustrated in Figure 13.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它对应于图13中展示的在*x=a*和*x=b*之间的函数*f(x)*下的面积。
- en: '![Figure 13: Area under the curve between $x=a$ and $x=b$.](../Images/3449d551c9a611e27e7626847a3037bc.png)*Figure
    13: Area under the curve between *x=a* and *x=b*.*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13：$x=a$和$x=b$之间的曲线下的面积。](../Images/3449d551c9a611e27e7626847a3037bc.png)*图13：*x=a*和*x=b*之间的曲线下的面积。*'
- en: Area Under the ROC Curve
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ROC曲线下的面积
- en: Now that you know how the area under the curve relates to integration, let’s
    see how to calculate it to compare numerically your models.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道了曲线下的面积与积分的关系，让我们看看如何计算它以便对比你的模型。
- en: 'Remember that you had the ROC curves represented in Figure 14:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你在图14中展示的ROC曲线：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Figure](../Images/00654d9a1a7a07306947b512ebcec2f4.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/00654d9a1a7a07306947b512ebcec2f4.png)'
- en: '*Figure 14: ROC curves of the random model (blue) and the logistic regression
    model (green).*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14：随机模型（蓝色）和逻辑回归模型（绿色）的ROC曲线。*'
- en: 'Let’s start with the random model. You want to sum each value of true positive
    rate multiplied by the width on the *x*-axis that is the difference between the
    corresponding value of false positive rate and the one before. You can obtain
    these differences with:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从随机模型开始。你需要将每个真实正率值与*x*轴上的宽度相乘，这个宽度是相应的假正率值与之前值之间的差异。你可以通过以下方法获得这些差异：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So the area under the ROC curve of the random model is:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所以随机模型的ROC曲线下的面积是：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or you can simply use the function `roc_auc_score()` from Sklearn using the
    true target values and the probabilities as input:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以简单地使用Sklearn中的函数`roc_auc_score()`，通过真实目标值和概率作为输入：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: An area under the ROC curve of 0.5 corresponds to a model that is not better
    than random and an area of 1 corresponds to perfect predictions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ROC曲线下的面积为0.5对应于一个不比随机更好的模型，而面积为1对应于完美的预测。
- en: 'Now, let’s compare this value to the area under the ROC curve of your model:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个值与模型的ROC曲线下的面积进行比较：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This shows that your model is actually not bad and your predictions of the quality
    of the wine are not random.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你的模型实际上并不差，你对葡萄酒质量的预测并非随机。
- en: In machine learning, you can use a few lines of code to train complex algorithms.
    However, as you saw here, a bit of math can help you to make the most of it and
    speed up your work. It will give you more ease in various aspects of your discipline,
    even, for instance, understanding the documentation of machine learning libraries
    like Sklearn.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，你可以用几行代码来训练复杂的算法。然而，正如你在这里看到的，掌握一些数学知识可以帮助你充分利用这些算法，并加快你的工作进度。它将使你在多个领域中更加得心应手，例如，理解像Sklearn这样的机器学习库的文档。
- en: '**Bio: [Hadrien Jean](https://hadrienj.github.io/)** is a machine learning
    scientist. He owns a Ph.D in cognitive science from the Ecole Normale Superieure,
    Paris, where he did research on auditory perception using behavioral and electrophysiological
    data. He previously worked in industry where he built deep learning pipelines
    for speech processing. At the corner of data science and environment, he works
    on projects about biodiversity assessement using deep learning applied to audio
    recordings. He also periodically creates content and teaches at Le Wagon (data
    science Bootcamp), and writes articles in his blog ([hadrienj.github.io](http://hadrienj.github.io)).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**简介：[哈德里安·让](https://hadrienj.github.io/)** 是一位机器学习科学家。他拥有巴黎高等师范学院的认知科学博士学位，研究领域包括使用行为和电生理数据进行听觉感知研究。他曾在工业界工作，构建了用于语音处理的深度学习管道。在数据科学与环境交汇的领域，他从事利用深度学习分析音频记录的生物多样性评估项目。他还定期在Le
    Wagon（数据科学训练营）创建内容并授课，并在他的博客（[hadrienj.github.io](http://hadrienj.github.io)）上撰写文章。'
- en: '[Original](https://hadrienj.github.io/posts/Essential-Math-Integrals/). Reposted
    with permission.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[原文](https://hadrienj.github.io/posts/Essential-Math-Integrals/)。经授权转载。'
- en: '**Related:**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关：**'
- en: '[Boost your data science skills. Learn linear algebra.](/2018/05/boost-data-science-skills-learn-linear-algebra.html)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提升你的数据科学技能。学习线性代数。](/2018/05/boost-data-science-skills-learn-linear-algebra.html)'
- en: '[Preprocessing for Deep Learning: From covariance matrix to image whitening](/2018/10/preprocessing-deep-learning-covariance-matrix-image-whitening.html)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[深度学习的预处理：从协方差矩阵到图像白化](/2018/10/preprocessing-deep-learning-covariance-matrix-image-whitening.html)'
- en: '[Essential Math for Data Science:  ‘Why’ and ‘How’](/2018/09/essential-math-data-science.html)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学的基础数学：‘为什么’和‘如何’](/2018/09/essential-math-data-science.html)'
- en: More On This Topic
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多相关话题
- en: '[How To Overcome The Fear of Math and Learn Math For Data Science](https://www.kdnuggets.com/2021/03/overcome-fear-learn-math-data-science.html)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何克服对数学的恐惧并学习数据科学中的数学](https://www.kdnuggets.com/2021/03/overcome-fear-learn-math-data-science.html)'
- en: '[Essential Math for Data Science: Eigenvectors and Application to PCA](https://www.kdnuggets.com/2022/06/essential-math-data-science-eigenvectors-application-pca.html)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学的基础数学：特征向量及其在PCA中的应用](https://www.kdnuggets.com/2022/06/essential-math-data-science-eigenvectors-application-pca.html)'
- en: '[Essential Math for Data Science: Visual Introduction to Singular…](https://www.kdnuggets.com/2022/06/essential-math-data-science-visual-introduction-singular-value-decomposition.html)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学的基础数学：奇异值分解的可视化介绍](https://www.kdnuggets.com/2022/06/essential-math-data-science-visual-introduction-singular-value-decomposition.html)'
- en: '[How Much Math Do You Need in Data Science?](https://www.kdnuggets.com/2020/06/math-data-science.html)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学中你需要多少数学知识？](https://www.kdnuggets.com/2020/06/math-data-science.html)'
- en: '[5 Free Courses to Master Math for Data Science](https://www.kdnuggets.com/5-free-courses-to-master-math-for-data-science)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5个免费课程掌握数据科学的数学](https://www.kdnuggets.com/5-free-courses-to-master-math-for-data-science)'
- en: '[5 Free MIT Courses to Learn Math for Data Science](https://www.kdnuggets.com/5-free-mit-courses-to-learn-math-for-data-science)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5个免费MIT课程学习数据科学数学](https://www.kdnuggets.com/5-free-mit-courses-to-learn-math-for-data-science)'
