["```py\nimport d6tjoin\nj = d6tjoin.Prejoin([df_price,df_score],['ticker','date'])\n\ntry:\n    assert j.is_all_matched() # fails\nexcept:\n    print('assert fails!') \n```", "```py\nj.match_quality() \n```", "```py\nresult=d6tjoin.top1.MergeTop1(df_price,df_score,fuzzy_left_on=['ticker','date'],fuzzy_right_on=['ticker','date']).merge() \n```", "```py\nresult['top1']['ticker']\nresult['merged'] \n```", "```py\nimport datetime\ndf_price[\"date\"]=df_price[\"date\"].apply(lambda x: datetime.datetime.strptime(x,'%Y-%m-%d'))\ndf_score[\"date\"]=df_score[\"date\"].apply(lambda x: datetime.datetime.strptime(x,'%Y-%m-%d')) \n```", "```py\nresult=d6tjoin.top1.MergeTop1(df_price,df_score,fuzzy_left_on=['ticker','date'],fuzzy_right_on=['ticker','date'],top_limit=[3,None]).merge() \n```", "```py\nresult['top1']['ticker']\nresult['merged'] \n```", "```py\nimport numpy as np\n\ndef diff_customized(x,y):\n    if np.busday_count(x,y)>0: #x is left_date and y is right_date,np_busday_count>0 means left_date is previous to right date\n        diff_= 10000000000   #as large enough\n    else:\n        diff_=np.busday_count(x,y)    \n    return abs(diff_) \n```", "```py\nresult=d6tjoin.top1.MergeTop1(df_price,df_score,fuzzy_left_on=['ticker','date'],fuzzy_right_on=['ticker','date'],fun_diff=[None,diff_customized],top_limit=[3,300]).merge() \n```", "```py\nresult['top1']['date']\nresult['merged'] \n```"]