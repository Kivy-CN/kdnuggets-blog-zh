- en: 'SQL Group By and Partition By Scenarios: When and How to Combine Data in Data
    Science'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/sql-group-by-and-partition-by-scenarios-when-and-how-to-combine-data-in-data-science](https://www.kdnuggets.com/sql-group-by-and-partition-by-scenarios-when-and-how-to-combine-data-in-data-science)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![SQL Group By and Partition By Scenarios: When and How to Combine Data in
    Data Science](../Images/b5b2d952dee44687f4b69129f0697533.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [Freepik](https://www.freepik.com/free-vector/abstract-technology-sql-illustration_21743443.htm#query=sql&position=14&from_view=search&track=sph&uuid=27f89b21-e929-4fca-80ed-4c8c1cefdaa0)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: SQL (Structured Query Language) is a programming language used for managing
    and manipulating data. That is why SQL queries are very essential for interacting
    with databases in a structured and efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping in SQL serves as a powerful tool for organizing and analyzing data.
    It helps in extraction of meaningful insights and summaries from complex datasets.
    The best use case of grouping is to summarize and understand data characteristics,
    thus helping businesses in analytical and reporting tasks.
  prefs: []
  type: TYPE_NORMAL
- en: We generally have a lot of requirements where we need to combine the dataset
    records by common data to calculate statistics in the group. Most of these instances
    can be generalized into common scenarios. These scenarios can then be applied
    whenever a requirement of similar kind comes up.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Clause: Group By'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GROUP BY clause in SQL is used for
  prefs: []
  type: TYPE_NORMAL
- en: grouping data on some columns
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: reducing the group to a single row
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: performing aggregation operations on other columns of the groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grouping Column = The value in the Grouping column should be same for all rows
    in the group
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation Column = Values in the Aggregation column are generally different
    over which a function is applied like sum, max etc.
  prefs: []
  type: TYPE_NORMAL
- en: The Aggregation column should not be the Grouping Column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 1: Grouping to find the sum of Total'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we want to calculate the total sales of every category in the sales
    table.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will group by category and aggregate individual sales in every category.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Grouping column = category
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation column = amount
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation function = sum()
  prefs: []
  type: TYPE_NORMAL
- en: '| **category** | **sales** |'
  prefs: []
  type: TYPE_TB
- en: '| toys | 10,700 |'
  prefs: []
  type: TYPE_TB
- en: '| books | 4,200 |'
  prefs: []
  type: TYPE_TB
- en: '| gym equipment | 2,000 |'
  prefs: []
  type: TYPE_TB
- en: '| stationary | 1,400 |'
  prefs: []
  type: TYPE_TB
- en: 'Scenario 2: Grouping to find Count'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to calculate the count of employees in each department.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will group by the department and calculate the count of employees
    in every department.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Grouping column = department
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation column = empid
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation function = count
  prefs: []
  type: TYPE_NORMAL
- en: '| **department** | **emp_count** |'
  prefs: []
  type: TYPE_TB
- en: '| finance | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| marketing | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| technology | 20 |'
  prefs: []
  type: TYPE_TB
- en: 'Scenario 3: Grouping to find the Average'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to calculate the average salary of employees in each department
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we will again group them by department and calculate the average
    salaries of employees in every department separately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Grouping column = department
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation column = salary
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation function = avg
  prefs: []
  type: TYPE_NORMAL
- en: '| **department** | **avg_salary** |'
  prefs: []
  type: TYPE_TB
- en: '| finance | 2,500 |'
  prefs: []
  type: TYPE_TB
- en: '| marketing | 4,700 |'
  prefs: []
  type: TYPE_TB
- en: '| technology | 10,200 |'
  prefs: []
  type: TYPE_TB
- en: 'Scenario 4: Grouping to find Maximum / Minimum'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to calculate the highest salary of employees in each department.
  prefs: []
  type: TYPE_NORMAL
- en: We will group the departments and calculate the maximum salary in every department.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Grouping column = department
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation column = salary
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation function = max
  prefs: []
  type: TYPE_NORMAL
- en: '| **department** | **max_salary** |'
  prefs: []
  type: TYPE_TB
- en: '| finance | 4,000 |'
  prefs: []
  type: TYPE_TB
- en: '| marketing | 9,000 |'
  prefs: []
  type: TYPE_TB
- en: '| technology | 12,000 |'
  prefs: []
  type: TYPE_TB
- en: 'Scenario 5: Grouping to Find Duplicates'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to find duplicate or same customer names in our database.
  prefs: []
  type: TYPE_NORMAL
- en: We will group by the customer name and use count as an aggregation function.
    Further we will use having a clause over the aggregation function to filter only
    those counts that are greater than one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Grouping column = name
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation column = *
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation function = count
  prefs: []
  type: TYPE_NORMAL
- en: Having = filter condition to be applied over aggregation function
  prefs: []
  type: TYPE_NORMAL
- en: '| **name** | **duplicate_count** |'
  prefs: []
  type: TYPE_TB
- en: '| Jake Junning | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Mary Moone | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Peter Parker | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| Oliver Queen | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'SQL Clause: Partition By'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PARTITION BY clause in SQL is used for
  prefs: []
  type: TYPE_NORMAL
- en: grouping/partitioning data on some columns
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Individual rows are retained and **not** combined into one
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: performing ranking and aggregation operations on other columns of the group/partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partitioning column = we select a column on which we group the data. The data
    in the partition column must be the same for each group. If not specified, the
    complete table is considered as a single partition.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering column = With each group created based on the Partitioning Column,
    we will order/sort the rows in the group
  prefs: []
  type: TYPE_NORMAL
- en: Ranking function = A ranking function or an aggregation function will be applied
    to the rows in the partition
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 6: Partitioning to find the Highest record in a Group'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to calculate which book in every category has the highest
    sales - along with the amount that the top seller book has made.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we cannot use a group by clause - because grouping will reduce
    the records in every category to a single row.
  prefs: []
  type: TYPE_NORMAL
- en: However, we need the record details such as book name, amount, etc., along with
    category to see which book has made the highest sales in each category.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Partitioning column = category
  prefs: []
  type: TYPE_NORMAL
- en: Ordering column = amount
  prefs: []
  type: TYPE_NORMAL
- en: Ranking function = row_number()
  prefs: []
  type: TYPE_NORMAL
- en: This query gives us all the rows in the book_sales table, and the rows are ordered
    in every book category, with the highest-selling book as row number 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to filter only row number 1 rows to get the top-selling books in
    each category
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The above filter will give us only the top seller books in each category along
    with the sale amount each top-seller book has made.
  prefs: []
  type: TYPE_NORMAL
- en: '| **category** | **book_name** | **amount** |'
  prefs: []
  type: TYPE_TB
- en: '| science | The hidden messages in water | 20,700 |'
  prefs: []
  type: TYPE_TB
- en: '| fiction | Harry Potter | 50,600 |'
  prefs: []
  type: TYPE_TB
- en: '| spirituality | Autobiography of a Yogi | 30,800 |'
  prefs: []
  type: TYPE_TB
- en: '| self-help | The 5 Love Languages | 12,700 |'
  prefs: []
  type: TYPE_TB
- en: 'Scenario 7: Partitioning to Find Cumulative Totals in a Group'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to calculate the running total (cumulative total) of the sale
    as they are sold. We need a separate cumulative total for every product.
  prefs: []
  type: TYPE_NORMAL
- en: We will partition by product_id and sort the partition by date
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Partitioning column = product_id
  prefs: []
  type: TYPE_NORMAL
- en: Ordering column = date
  prefs: []
  type: TYPE_NORMAL
- en: Ranking function = sum()
  prefs: []
  type: TYPE_NORMAL
- en: '| **product_id** | **date** | **amount** | **running_total** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2023-12-25 | 3,900 | 3,900 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2023-12-24 | 3,000 | 6,900 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2023-12-23 | 2,700 | 9,600 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2023-12-22 | 1,800 | 11,400 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2023-12-25 | 2,000 | 2,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2023-12-24 | 1,000 | 3,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2023-12-23 | 7,00 | 3,700 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2023-12-25 | 1,500 | 1,500 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2023-12-24 | 4,00 | 1,900 |'
  prefs: []
  type: TYPE_TB
- en: 'Scenario 8: Partitioning to Compare Values within a Group'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to compare the salary of every employee with the average salary
    of his department.
  prefs: []
  type: TYPE_NORMAL
- en: So we will partition the employees based on department and find the average
    salary of each department.
  prefs: []
  type: TYPE_NORMAL
- en: The average can be further easily subtracted from the employee's individual
    salary to calculate if employee's salary is higher or below the average.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Partitioning column = department
  prefs: []
  type: TYPE_NORMAL
- en: Ordering column = no order
  prefs: []
  type: TYPE_NORMAL
- en: Ranking function = avg()
  prefs: []
  type: TYPE_NORMAL
- en: '| **employee_id** | **salary** | **department** | **avg_dept_sal** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 7,200 | finance | 6,400 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 8,000 | finance | 6,400 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 4,000 | finance | 6,400 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 12,000 | technology | 11,300 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 15,000 | technology | 11,300 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 7,000 | technology | 11,300 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 4,000 | marketing | 5,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 6,000 | marketing | 5,000 |'
  prefs: []
  type: TYPE_TB
- en: 'Scenario 9: Partitioning to divide results into equal groups'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to divide the employees into 4 equal (or nearly equal) groups
    based on their salary.
  prefs: []
  type: TYPE_NORMAL
- en: So we will derive another logical column tile_id, which will have the numeric
    id of each group of employees.
  prefs: []
  type: TYPE_NORMAL
- en: The groups will be created based on salary - the first tile group will have
    the highest salary, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Partitioning column = no partition - complete table is in the same partition
  prefs: []
  type: TYPE_NORMAL
- en: Ordering column = salary
  prefs: []
  type: TYPE_NORMAL
- en: Ranking function = ntile()
  prefs: []
  type: TYPE_NORMAL
- en: '| **employee_id** | **salary** | **tile_id** |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 12,500 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 11,000 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 10,500 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 9,000 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 8,500 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 8,000 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 7,000 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 7,000 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 6,500 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 6,000 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 5,000 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 4,000 | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'Scenario 10: Partitioning to identify islands or gaps in data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we have a sequential product_id column, and we want to identify gaps
    in this.
  prefs: []
  type: TYPE_NORMAL
- en: So we will derive another logical column island_id, which will have the same
    number if product_id is sequential. When a break is identified in product_id,
    then the island_id is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Partitioning column = no partition - complete table is in the same partition
  prefs: []
  type: TYPE_NORMAL
- en: Ordering column = product_id
  prefs: []
  type: TYPE_NORMAL
- en: Ranking function = row_number()
  prefs: []
  type: TYPE_NORMAL
- en: '| **product_id** | **row_num** | **island_id** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 4 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 5 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 6 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 7 | 2 |'
  prefs: []
  type: TYPE_TB
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Group By and Partition By are used to solve many problems like:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summarizing Information:** Grouping allows you to aggregate data and summarize
    information in every group.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing Patterns:** It helps in identifying patterns or trends within data
    subsets, providing insights into various aspects of the dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Statistical Analysis:** Enables the calculation of statistical measures such
    as averages, counts, maximums, minimums, and other aggregate functions within
    the groups.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Cleansing:** Helps identify duplicates, inconsistencies, or anomalies
    within groups, making data cleansing and quality improvement more manageable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cohort Analysis:** Useful in cohort-based analysis, tracking and comparing
    groups of entities over time etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Hanu](https://helpercodes.com/)** runs the [HelperCodes Blog](https://helpercodes.com/) which
    mainly deals with [SQL Cheat Sheets](https://helpercodes.com/sql-query-cheatsheet-tutorial/).
    I am a full stack developer and interested in creating reusable assets.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Overcoming Imbalanced Data Challenges in Real-World Scenarios](https://www.kdnuggets.com/2023/07/overcoming-imbalanced-data-challenges-realworld-scenarios.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exploring the Potential of Transfer Learning in Small Data Scenarios](https://www.kdnuggets.com/exploring-the-potential-of-transfer-learning-in-small-data-scenarios)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Visual ChatGPT: Microsoft Combine ChatGPT and VFMs](https://www.kdnuggets.com/2023/03/visual-chatgpt-microsoft-combine-chatgpt-vfms.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News, June 8: 21 Cheat Sheets for Data Science…](https://www.kdnuggets.com/2022/n23.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News, December 7: Top 10 Data Science Myths Busted • 4…](https://www.kdnuggets.com/2022/n47.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets™ News 22:n03, Jan 19: A Deep Look Into 13 Data…](https://www.kdnuggets.com/2022/n03.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
