# 数据可观察性，第 II 部分：如何使用 SQL 构建自己的数据质量监控器

> 原文：[https://www.kdnuggets.com/2021/02/data-observability-part-2-build-data-quality-monitors-sql.html](https://www.kdnuggets.com/2021/02/data-observability-part-2-build-data-quality-monitors-sql.html)

[评论](#comments)

**作者：[Barr Moses](https://www.linkedin.com/in/barrmoses/)，Monte Carlo 的首席执行官兼联合创始人，以及 [Ryan Kearns](https://www.linkedin.com/in/ryan-kearns-203686a9)，Monte Carlo 的机器学习工程师**

*在这系列文章中，我们将介绍如何从头开始创建自己的数据可观察性监视器，并映射到*[***数据健康的五个关键支柱***](https://towardsdatascience.com/introducing-the-five-pillars-of-data-observability-e73734b263d5)*。第一部分可以在*[*这里*](https://www.montecarlodata.com/data-observability-in-practice-using-sql-1/)*找到。*

* * *

## 我们的三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity Certificate](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support Professional Certificate](https://www.kdnuggets.com/google-itsupport) - 支持你的组织在 IT 领域

* * *

*这一系列的第二部分改编自 Barr Moses 和 Ryan Kearns 的 O’Reilly 培训课程*[***管理数据停机：将可观察性应用于你的数据管道***](https://www.oreilly.com/live-training/courses/managing-data-downtime/0636920508717/)*，这是行业首个数据可观察性课程。相关练习可以在*[*这里*](https://github.com/monte-carlo-data/data-downtime-challenge)*找到，本文展示的改编代码可以在*[*这里*](https://github.com/monte-carlo-data/data-observability-in-practice)*找到。*

随着世界对数据的需求增加，强大的数据管道变得更加重要。当数据出现故障时——无论是由于模式变化、空值、重复还是其他原因——数据工程师需要了解情况。

最重要的是，我们需要迅速评估故障的根本原因，以免影响下游系统和消费者。我们使用“[**数据停机**](https://towardsdatascience.com/the-rise-of-data-downtime-841650cedfd5)”来指代数据缺失、错误或其他不准确的时间段。如果你是数据专业人员，可能会熟悉以下问题：

+   数据是否最新？

+   数据是否完整？

+   字段是否在预期范围内？

+   空值率是否高于或低于预期？

+   模式是否有变化？

为了有效回答这些问题，我们可以借鉴软件工程师的做法：[**监控和可观察性**](https://observability.workshop.aws/en/anomalydetection.html)**。**

为了刷新你对第一部分的记忆，我们将[**数据可观察性**](https://towardsdatascience.com/what-is-data-observability-40b337971e3e)定义为组织回答这些问题并评估其数据生态系统健康状况的能力。反映数据健康的关键变量，数据可观察性的五大支柱是：

+   **新鲜度**：我的数据是否是最新的？我的数据是否有时间间隔没有更新？

+   **分布**：我的数据在字段级别的健康状况如何？我的数据是否在预期范围内？

+   **数据量**：我的数据摄取是否达到预期阈值？

+   **架构**：我的数据管理系统的正式结构是否发生了变化？

+   **血统**：如果我的部分数据出现故障，上游和下游会受到什么影响？我的数据源之间如何相互依赖？

在这系列文章中，我们感兴趣的是揭开帷幕，调查数据可观察性是什么样的——*在代码中*。

在[第一部分](https://medium.com/swlh/data-observability-building-your-own-data-quality-monitors-using-sql-a4c848b6882d)中，我们查看了前两个支柱，新鲜度和分布，并展示了如何通过一些SQL代码使这些概念具象化。这些是我们所谓的“经典”[**异常检测问题**](https://en.wikipedia.org/wiki/Anomaly_detection)——给定一个稳定的数据流，是否有任何异常？良好的异常检测确实是数据可观察性的一部分，但这不是全部。

> 同样重要的是[***上下文***](https://www.montecarlodata.com/data-teams-your-metadata-is-useless/)。如果发生了异常，那很好。但发生在何处？哪些上游管道可能是原因？哪些下游仪表板会受到影响？我的数据的正式结构是否发生了变化？良好的数据可观察性依赖于我们能够适当地利用元数据来回答这些问题——以及许多其他问题——以便我们能够找到根本原因并在问题变得更严重之前解决它。

在这篇文章中，我们将关注两个旨在为我们提供关键上下文的数据可观察性支柱——**架构**和**血统**。我们将再次使用轻量级工具，如Jupyter和SQLite，以便你可以轻松启动我们的环境并自己尝试这些练习。让我们开始吧。

### 我们的数据环境

*本教程基于*[*练习 2 和 3*](https://github.com/monte-carlo-data/data-downtime-challenge/blob/master/exercise_text/ex2.md)*的内容，来自我们的 O'Reilly 课程*[*Managing Data Downtime*](https://www.oreilly.com/live-training/courses/managing-data-downtime/0636920508717/)*。你可以使用 Jupyter Notebook 和 SQL 自行尝试这些练习。我们将在未来的文章中深入探讨，包括练习*[*4*](https://github.com/monte-carlo-data/data-downtime-challenge/blob/master/exercise_text/ex4.md)*。

如果你阅读了[第一部分](https://medium.com/swlh/data-observability-building-your-own-data-quality-monitors-using-sql-a4c848b6882d)，你应该对我们的数据有所了解。和以前一样，我们将处理关于适居外行星的[模拟天文数据](https://github.com/monte-carlo-data/data-observability-in-practice/blob/main/EXOPLANETS.db)。我们使用 Python 生成了数据集，数据和异常基于我在生产环境中遇到的实际事件。这个数据集完全免费使用，如果你感兴趣，[utils 文件夹](https://github.com/monte-carlo-data/data-downtime-challenge/tree/master/data/utils) 包含生成数据的代码。

我使用的是 SQLite 3.32.3，这应该使数据库能够从命令提示符或 SQL 文件中访问，设置非常简单。这些概念适用于几乎任何查询语言，[这些实现](https://github.com/monte-carlo-data/data-observability-in-practice/tree/main/queries) 可以扩展到 MySQL、Snowflake 和其他数据库环境，几乎不需要更改。

再次，我们有我们的 EXOPLANETS 表：

```py
$ sqlite3 EXOPLANETS.db
sqlite> PRAGMA TABLE_INFO(EXOPLANETS);
0 | _id            | TEXT | 0 | | 0
1 | distance       | REAL | 0 | | 0
2 | g              | REAL | 0 | | 0
3 | orbital_period | REAL | 0 | | 0
4 | avg_temp       | REAL | 0 | | 0
5 | date_added     | TEXT | 0 | | 0
```

EXOPLANETS 中的数据库条目包含以下信息：

0. `_id`：对应行星的UUID。

1. `distance`：距离地球的光年数。

2. `g`：表面重力，以g为单位的倍数，g为引力常数。

3. `orbital_period`：单个轨道周期的天数。

4. `avg_temp`：平均表面温度，单位为开尔文。

5. `date_added`：我们系统发现行星并自动添加到数据库的日期。

注意，由于数据缺失或错误，`distance`、`g`、`orbital_period` 和 `avg_temp` 之一或多个可能会对某个行星为 `NULL`。

`sqlite> SELECT * FROM EXOPLANETS LIMIT 5;`

注意，本练习是追溯性的——我们正在查看历史数据。在生产数据环境中，数据可观察性是实时的，并且在数据生命周期的每个阶段应用，因此实施方式会有所不同。

看起来我们最早的数据日期为2020–01–01（*注意*：大多数数据库不会存储单个记录的时间戳，因此我们的 `DATE_ADDED` 列在为我们跟踪）。我们的最新数据……

```py
sqlite> SELECT DATE_ADDED FROM EXOPLANETS ORDER BY DATE_ADDED DESC LIMIT 1;
2020–07–18
```

…看起来是从2020年07月18日开始的。当然，这与我们在过去的文章中使用的表是一样的。如果我们想要深入探索模式和血统的更多背景内容，我们需要扩展我们的环境。

现在，除了`EXOPLANETS`外，我们还有一个名为`EXOPLANETS_EXTENDED`的表，它是我们过去表的超集。将这些表视为在*不同时间点*的相同表是有用的。实际上，`EXOPLANETS_EXTENDED`的数据可以追溯到2020年01月01日…

```py
sqlite> SELECT DATE_ADDED FROM EXOPLANETS_EXTENDED ORDER BY DATE_ADDED ASC LIMIT 1;
2020–01–01
```

…但也包含数据直到2020年09月06日，比`EXOPLANETS`更早：

```py
sqlite> SELECT DATE_ADDED FROM EXOPLANETS_EXTENDED ORDER BY DATE_ADDED DESC LIMIT 1;
2020–09–06
```

### 可视化模式变化

这些表之间还有其他不同之处：

```py
sqlite> PRAGMA TABLE_INFO(EXOPLANETS_EXTENDED);
0 | _ID            | VARCHAR(16777216) | 1 | | 0
1 | DISTANCE       | FLOAT             | 0 | | 0
2 | G              | FLOAT             | 0 | | 0
3 | ORBITAL_PERIOD | FLOAT             | 0 | | 0
4 | AVG_TEMP       | FLOAT             | 0 | | 0
5 | DATE_ADDED     | TIMESTAMP_NTZ(6)  | 1 | | 0
6 | ECCENTRICITY   | FLOAT             | 0 | | 0
7 | ATMOSPHERE     | VARCHAR(16777216) | 0 | | 0
```

除了`EXOPLANETS`中的6个字段外，`EXOPLANETS_EXTENDED`表还包含两个额外字段：

6. `eccentricity`: 行星绕其宿主恒星的[轨道离心率](https://en.wikipedia.org/wiki/Orbital_eccentricity)。

7. `atmosphere`: 行星大气层的主要化学成分。

请注意，像`distance`、`g`、`orbital_period`和`avg_temp`一样，`eccentricity`和`atmosphere`也可能因数据缺失或错误而对某些行星为`NULL`。例如，[流浪行星](https://en.wikipedia.org/wiki/Rogue_planet)的轨道离心率未定义，许多行星根本没有大气层。

另请注意，数据没有回填，这意味着表开始时的数据条目（`EXOPLANETS`表中也包含的数据）将没有离心率和大气层信息。

```py
sqlite> SELECT
   ...>     DATE_ADDED,
   ...>     ECCENTRICITY,
   ...>     ATMOSPHERE
   ...> FROM
   ...>     EXOPLANETS_EXTENDED
   ...> ORDER BY
   ...>     DATE_ADDED ASC
   ...> LIMIT 10;
2020–01–01 | |
2020–01–01 | |
2020–01–01 | |
2020–01–01 | |
2020–01–01 | |
2020–01–01 | |
2020–01–01 | |
2020–01–01 | |
2020–01–01 | |
2020–01–01 | |
```

添加两个字段是一个[**模式** **变化**](https://www.educative.io/blog/what-are-database-schemas-examples)的例子——我们数据的正式蓝图已经被修改。模式变化发生在对数据结构进行更改时，并且手动调试可能会很烦人。模式变化可能会指示有关数据的许多事情，包括：

+   新API端点的添加

+   可能被弃用但尚未… 被弃用的字段

+   列、行或整个表的增加或减少

在理想情况下，我们希望记录下这个变化，因为它代表了我们管道可能出现问题的一个向量。不幸的是，我们的数据库并没有自然配置来跟踪这些变化。它没有版本历史。

我们在[第一部分](https://medium.com/swlh/data-observability-building-your-own-data-quality-monitors-using-sql-a4c848b6882d)中遇到过这个问题，当时查询单个记录的年龄，并添加了`DATE_ADDED`列来应对。在这种情况下，我们将做类似的事情，只不过是添加一个完整的表：

```py
sqlite> PRAGMA TABLE_INFO(EXOPLANETS_COLUMNS);
0 | DATE    | TEXT | 0 | | 0
1 | COLUMNS | TEXT | 0 | | 0
```

`EXOPLANETS_COLUMNS`表通过记录`EXOPLANETS_EXTENDED`中任意日期的列来“版本化”我们的模式。查看最早和最晚的条目，我们可以看到列确实在某个时间点发生了变化：

```py
sqlite> SELECT * FROM EXOPLANETS_COLUMNS ORDER BY DATE ASC LIMIT 1;
2020–01–01 | [
              (0, ‘_id’, ‘TEXT’, 0, None, 0),
              (1, ‘distance’, ‘REAL’, 0, None, 0),
              (2, ‘g’, ‘REAL’, 0, None, 0),
              (3, ‘orbital_period’, ‘REAL’, 0, None, 0),
              (4, ‘avg_temp’, ‘REAL’, 0, None, 0),
              (5, ‘date_added’, ‘TEXT’, 0, None, 0)
             ]sqlite> SELECT * FROM EXOPLANETS_COLUMNS ORDER BY DATE DESC LIMIT 1;
2020–09–06 | 
[
              (0, ‘_id’, ‘TEXT’, 0, None, 0),
              (1, ‘distance’, ‘REAL’, 0, None, 0),
              (2, ‘g’, ‘REAL’, 0, None, 0),
              (3, ‘orbital_period’, ‘REAL’, 0, None, 0),
              (4, ‘avg_temp’, ‘REAL’, 0, None, 0),
              (5, ‘date_added’, ‘TEXT’, 0, None, 0),
              (6, ‘eccentricity’, ‘REAL’, 0, None, 0),
              (7, ‘atmosphere’, ‘TEXT’, 0, None, 0)
             ]
```

现在，回到我们最初的问题：模式究竟何时发生了变化？由于我们的列列表按日期索引，我们可以通过一个简单的SQL脚本找到变化的日期：

这是返回的数据，我已重新格式化以便于阅读：

```py
DATE:         2020–07–19
NEW_COLUMNS:  [
               (0, ‘_id’, ‘TEXT’, 0, None, 0),
               (1, ‘distance’, ‘REAL’, 0, None, 0),
               (2, ‘g’, ‘REAL’, 0, None, 0),
               (3, ‘orbital_period’, ‘REAL’, 0, None, 0),
               (4, ‘avg_temp’, ‘REAL’, 0, None, 0),
               (5, ‘date_added’, ‘TEXT’, 0, None, 0),
               (6, ‘eccentricity’, ‘REAL’, 0, None, 0),
               (7, ‘atmosphere’, ‘TEXT’, 0, None, 0)
              ]
PAST_COLUMNS: [
               (0, ‘_id’, ‘TEXT’, 0, None, 0),
               (1, ‘distance’, ‘REAL’, 0, None, 0),
               (2, ‘g’, ‘REAL’, 0, None, 0),
               (3, ‘orbital_period’, ‘REAL’, 0, None, 0),
               (4, ‘avg_temp’, ‘REAL’, 0, None, 0),
               (5, ‘date_added’, ‘TEXT’, 0, None, 0)
              ]
```

通过这个查询，我们返回了问题日期：2020–07–19。与新鲜度和分布可观察性一样，实现模式可观察性遵循一种模式：我们识别[有用的元数据](https://towardsdatascience.com/metadata-is-useless-535e43311cd8)来信号管道健康，跟踪它，并建立探测器以警告我们潜在的问题。提供像`EXOPLANETS_COLUMNS`这样的额外表是跟踪模式的一种方式，但还有很多其他方法。我们鼓励你思考如何为自己的数据管道实现模式变更探测器！

### 可视化谱系

我们将谱系描述为[数据可观察性的五大支柱中最全面的](https://towardsdatascience.com/introducing-the-five-pillars-of-data-observability-e73734b263d5)，这有充分的理由。

> 谱系通过告诉我们（1）哪些下游来源可能受到影响，以及（2）哪些上游来源可能是根本原因，来为事件提供背景。虽然用SQL代码“可视化”谱系并不直观，但一个简单的示例可以说明它如何有用。

为此，我们需要再次扩展我们的数据环境。

### 介绍：HABITABLES

让我们在数据库中添加另一张表。到目前为止，我们一直在记录系外行星的数据。这里有一个有趣的问题要问：这些行星中有多少可能拥有生命？

`HABITABLES`表从`EXOPLANETS`中获取数据，以帮助我们回答这个问题：

```py
sqlite> PRAGMA TABLE_INFO(HABITABLES);
0 | _id          | TEXT | 0 | | 0
1 | perihelion   | REAL | 0 | | 0
2 | aphelion     | REAL | 0 | | 0
3 | atmosphere   | TEXT | 0 | | 0
4 | habitability | REAL | 0 | | 0
5 | min_temp     | REAL | 0 | | 0
6 | max_temp     | REAL | 0 | | 0
7 | date_added   | TEXT | 0 | | 0
```

`HABITABLES`中的条目包含以下内容：

`_id`: 与行星对应的UUID。

`perihelion`: [在轨道周期中](https://en.wikipedia.org/wiki/Apsis#Perihelion_and_aphelion)离天体最近的距离。

`aphelion`: [在轨道周期中](https://en.wikipedia.org/wiki/Apsis#Perihelion_and_aphelion)离天体最远的距离。

`atmosphere`: 行星大气的主要化学成分。

`habitability`: 一个介于0和1之间的实数，表示行星可能拥有生命的可能性。

`min_temp`: 行星表面的最低温度。

`max_temp`: 行星表面的最高温度。

`date_added`: 我们系统发现该行星并自动将其添加到我们的数据库中的日期。

像`EXOPLANETS`中的列一样，`perihelion`、`aphelion`、`atmosphere`、`min_temp`和`max_temp`的值可以为`NULL`。事实上，对于`EXOPLANETS`中`eccentricity`为`NULL`的任何`_id`，`perihelion`和`aphelion`将为`NULL`，因为你使用轨道偏心率来计算这些指标。这解释了为什么这两个字段在我们较旧的数据条目中总是`NULL`：

```py
sqlite> SELECT * FROM HABITABLES LIMIT 5;
```

因此，我们知道`HABITABLES`依赖于`EXOPLANETS`（或同样的`EXOPLANETS_EXTENDED`）中的值，`EXOPLANETS_COLUMNS`也是如此。我们数据库的依赖关系图如下：

![图](../Images/d71210e8268ae60c9ab0032bc91921ee.png)

图片来源：[Monte Carlo](http://www.montecarlodata.com/)。

非常简单的传承信息，但已经很有用。让我们在这个图表的背景下看看`HABITABLES`中的异常，看看我们可以学到什么。

### 调查异常

当我们有一个关键指标，比如`HABITABLES`中的habitability时，我们可以通过几种方式评估该指标的健康状况。首先，在某一天的新数据中，`habitability`的平均值是多少？

查看这些数据，我们看到有些地方出错了。`habitability`的平均值通常在0.5左右，但在记录的数据后期减少到约0.25。

![图像](../Images/cbc0ab591e234f730b65dc895ab2426a.png)

一种分布异常……但是什么导致了它？

这是一个明显的分布异常，但到底发生了什么？换句话说，这个异常的*根本原因*是什么？

为什么我们不查看`habitability`的`NULL`率，就像我们在[第一部分](https://ryanothnielkearns.medium.com/data-observability-building-your-own-data-quality-monitors-using-sql-a4c848b6882d)中做的那样？

幸运的是，这里没有显得不合常规的情况：

但这看起来并不是问题的有力原因。如果我们查看另一个分布健康指标，即**零值率**呢？

这里显然有些更明显的问题：

历史上，`habitability`几乎从未为零，但在后来的日期里，它平均飙升至近40%。这对字段的平均值产生了降低的检测效果。

![图像](../Images/ca0aa0e21a7d21ac69d342c325b39a5d.png)

一种分布异常……但是什么导致了它？

我们可以使用在第一部分中构建的分布探测器之一来获取`habitability`字段中显著零值的第一次出现日期：

我通过命令行运行了这个查询：

```py
$ sqlite3 EXOPLANETS.db < queries/lineage/habitability-zero-rate-detector.sql
DATE_ADDED | HABITABILITY_ZERO_RATE | PREV_HABITABILITY_ZERO_RATE
2020–07–19 | 0.369047619047619      | 0.0
```

2020–07–19是零值率开始出现异常结果的第一个日期。请记住，这与`EXOPLANETS_EXTENDED`中的架构变更检测是同一天。`EXOPLANETS_EXTENDED`在`HABITABLES`上游，所以这两个事件很可能是相关的。

以这种方式，传承信息可以帮助我们识别**根本原因**，并更快地解决问题。比较一下`HABITABLES`中对这一事件的两个解释：

1.  在2020–07–19，`HABITABLES`表中可居住性列的零值率从0%跃升至37%。

1.  在2020–07–19，我们开始在`EXOPLANETS`表中跟踪两个额外字段，`eccentricity`和`atmosphere`。这对下游表`HABITABLES`产生了不利影响，每当`eccentricity`不为`NULL`时，通常会将字段`min_temp`和`max_temp`设置为极端值。这反过来导致了`habitability`字段零值率的激增，我们检测到这是平均值的异常下降。

解释（1）仅使用了异常发生的事实。解释（2）则利用了数据表和字段之间的依赖关系来将事件置于上下文中，并确定根本原因。实际上，（2）中的一切都是正确的，我鼓励你在环境中尝试以了解情况。虽然这些只是简单的例子，但一个掌握（2）的人将更快地*理解*和*解决*潜在的问题，这一切都归功于适当的可观察性。

### 接下来是什么？

跟踪模式变化和数据血统可以让你以前所未有的方式了解数据的健康状况和使用模式，提供有关你的数据是如何被使用的的至关重要的背景信息，包括谁、什么、哪里、为什么以及如何。在了解数据停机的下游（以及往往是现实世界）影响时，模式和数据血统是最重要的两大数据可观察性支柱。

总结：

+   观察我们数据的**模式**意味着理解数据的正式结构，以及它何时何故发生变化。

+   观察我们数据的**血统**意味着理解我们管道中的上下游依赖关系，并将孤立的事件放在更大的背景中。

+   这两项**数据可观察性**的支柱都涉及到跟踪正确的元数据，并以一种使异常现象易于理解的方式转化我们的数据。

+   更好的可观察性意味着**更好地理解数据为何以及如何中断**，减少检测时间和解决时间。

我们希望“数据可观察性背景下”这一部分对你有所帮助。

直到第三部分，祝你没有数据停机！

***想了解更多关于 Monte Carlo 数据可观察性的方法吗？请联系*** [***Ryan***](https://www.linkedin.com/in/ryan-kearns-203686a9)***、***[***Barr***](https://www.linkedin.com/in/barrmoses/)*** 和 ***[***Monte Carlo 团队***](http://www.montecarlodata.com/)***。***

**[Barr Moses](https://www.linkedin.com/in/barrmoses/)** 是 Monte Carlo 的首席执行官兼联合创始人。在此之前，她曾担任 Gainsight 的运营副总裁。

**[Ryan Kearns](https://www.linkedin.com/in/ryan-kearns-203686a9)** 是 Monte Carlo 的数据和机器学习工程师，同时也是斯坦福大学的升年级学生。

[原文](https://towardsdatascience.com/data-observability-in-practice-using-sql-part-ii-schema-lineage-5ca6c8f4f56a)。经许可转载。

**相关：**

+   [数据可观察性：使用 SQL 构建数据质量监控器](/2021/02/data-observability-building-data-quality-monitors-using-sql.html)

+   [数据目录已死；数据发现万岁](/2020/12/data-catalogs-dead-long-live-data-discovery.html)

+   [SQL 中的数据清理和整理](/2021/01/data-cleaning-wrangling-sql.html)

### 更多相关话题

+   [数据质量维度：用Great Expectations保证你的数据质量](https://www.kdnuggets.com/2023/03/data-quality-dimensions-assuring-data-quality-great-expectations.html)

+   [数据治理与可观察性，解释](https://www.kdnuggets.com/2022/08/data-governance-observability-explained.html)

+   [IMPACT 2022：数据可观察性峰会，将于10月25-26日举行](https://www.kdnuggets.com/2022/09/monte-carlo-impact-2022-data-observability-summit.html)

+   [IMPACT：数据可观察性峰会将于11月8日回归](https://www.kdnuggets.com/2023/10/monte-carlo-impact-the-data-observability-summit-is-back)

+   [LangChain 101：构建你自己的GPT驱动应用程序](https://www.kdnuggets.com/2023/04/langchain-101-build-gptpowered-applications.html)

+   [使用LlamaIndex构建你自己的PandasAI](https://www.kdnuggets.com/build-your-own-pandasai-with-llamaindex)
