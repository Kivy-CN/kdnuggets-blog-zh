["```py\n@ray.remote\ndef slow(record):\n    new_record = expensive_process(record)\n    return new_record\n```", "```py\nray.init() # Arguments can specify the cluster location, etc.\nfutures = [slow.remote(r) for r in records]\n```", "```py\nwhile len(futures) > 0:\n     finished, rest = ray.wait(futures)\n     # Do something with “finished”, which has 1 value:\n     value = ray.get(finished[0]) # Get the value from the future\n     print(value)\n     futures = rest \n```", "```py\n@ray.remote\nclass CountedSlows:\n    def __init__(self, initial_count = 0):\n        self.count = initial_count\n    def slow(self, record):\n        self.count += 1\n        new_record = expensive_process(record)\n        return new_record\n    def get_count(self):\n        return self.count\n```", "```py\ncs = CountedSlows.remote() # Note how actor construction works\nfutures = [cs.slow.remote(r) for r in records]\n\nwhile len(futures) > 0:\n     finished, rest = ray.wait(futures)\n     value = ray.get(finished[0])\n     print(value)\n     futures = rest\n\ncount_future_id = cs.get_count.remote()\nray.get(count_future_id)\n```", "```py\nfrom multiprocessing.pool import Pool\n```", "```py\nfrom ray.experimental.multiprocessing.pool import Pool\n```"]