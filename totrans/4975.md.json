["```py\n# Load and Store both data and groundtruth of Zachary's Karate Club\nG = nx.karate_club_graph()\ngroundTruth = [0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1]\n\n```", "```py\ndef graphToEdgeMatrix(G):\n\n    # Initialize Edge Matrix\n    edgeMat = [[0 for x in range(len(G))] for y in range(len(G))]\n\n    # For loop to set 0 or 1 ( diagonal elements are set to 1)\n    for node in G:\n        tempNeighList = G.neighbors(node)\n        for neighbor in tempNeighList:\n            edgeMat[node][neighbor] = 1\n        edgeMat[node][node] = 1\n\n    return edgeMat\n\n```", "```py\ndef drawCommunities(G, partition, pos):\n    # G is graph in networkx form\n    # Partition is a dict containing info on clusters\n    # Pos is base on networkx spring layout (nx.spring_layout(G))\n\n    # For separating communities colors\n    dictList = defaultdict(list)\n    nodelist = []\n    for node, com in partition.items():\n        dictList[com].append(node)\n\n    # Get size of Communities\n    size = len(set(partition.values()))\n\n    # For loop to assign communities colors\n    for i in range(size):\n\n        amplifier = i % 3\n        multi = (i / 3) * 0.3\n\n        red = green = blue = 0\n\n        if amplifier == 0:\n            red = 0.1 + multi\n        elif amplifier == 1:\n            green = 0.1 + multi\n        else:\n            blue = 0.1 + multi\n\n        # Draw Nodes\n        nx.draw_networkx_nodes(G, pos,\n                               nodelist=dictList[i],\n                               node_color=[0.0 + red, 0.0 + green, 0.0 + blue],\n                               node_size=500,\n                               alpha=0.8)\n\n    # Draw edges and final plot\n    plt.title(\"Zachary's Karate Club\")\n    nx.draw_networkx_edges(G, pos, alpha=0.5)\n\n```", "```py\n# K-means Clustering Model\nkmeans = cluster.KMeans(n_clusters=kClusters, n_init=200)\nkmeans.fit(edgeMat)\n\n# Transform our data to list form and store them in results list\nresults.append(list(kmeans.labels_))\n\n```", "```py\n# Agglomerative Clustering Model\nagglomerative = cluster.AgglomerativeClustering(n_clusters=kClusters, linkage=\"ward\")\nagglomerative.fit(edgeMat)\n\n# Transform our data to list form and store them in results list\nresults.append(list(agglomerative.labels_))\n\n```", "```py\n# Spectral Clustering Model\nspectral = cluster.SpectralClustering(n_clusters=kClusters, affinity=\"precomputed\", n_init= 200)\nspectral.fit(edgeMat)\n\n# Transform our data to list form and store them in results list\nresults.append(list(spectral.labels_))\n\n```", "```py\n# Affinity Propagation Clustering Model\naffinity = cluster.affinity_propagation(S=edgeMat, max_iter=200, damping=0.6)\n\n# Transform our data to list form and store them in results list\nresults.append(list(affinity[1]))\n\n```", "```py\n# Append the results into lists\nfor x in results:\n    nmiResults.append(normalized_mutual_info_score(groundTruth, x))\n    arsResults.append(adjusted_rand_score(groundTruth, x))\n\n```", "```py\n# Code for plotting results\n\n# Average of NMI and ARS\ny = [sum(x) / 2 for x in zip(nmiResults, arsResults)]\n\nxlabels = ['Spectral', 'Agglomerative', 'Kmeans', 'Affinity Propagation']\n\nfig = plt.figure()\nax = fig.add_subplot(111)\n\n# Set parameters for plotting\nind = np.arange(len(y))\nwidth = 0.35\n\n# Create barchart and set the axis limits and titles\nax.bar(ind, y, width,color='blue', error_kw=dict(elinewidth=2, ecolor='red'))\nax.set_xlim(-width, len(ind)+width)\nax.set_ylim(0,2)\nax.set_ylabel('Average Score (NMI, ARS)')\nax.set_title('Score Evaluation')\n\n# Add the xlabels to the chart\nax.set_xticks(ind + width / 2)\nxtickNames = ax.set_xticklabels(xlabels)\nplt.setp(xtickNames, fontsize=12)\n\n# Add the actual value on top of each chart\nfor i, v in enumerate(y):\n    ax.text( i, v, str(round(v, 2)), color='blue', fontweight='bold')\n\n# Show the final plot\nplt.show()\n\n```"]