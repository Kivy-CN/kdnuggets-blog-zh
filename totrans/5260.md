# 如何编写更好的 SQL 查询：权威指南 – 第二部分

> 原文：[https://www.kdnuggets.com/2017/08/write-better-sql-queries-definitive-guide-part-2.html](https://www.kdnuggets.com/2017/08/write-better-sql-queries-definitive-guide-part-2.html)

**作者：Karlijn Willems，数据科学记者 & [DataCamp](https://www.datacamp.com/) 贡献者**。

> **编辑说明：** 本文是第一部分的续集，[第一部分昨天发布，可以在这里找到](/2017/08/write-better-sql-queries-definitive-guide-part-1.html)。虽然这里的内容可以被视为独立于第一部分，但在继续阅读之前阅读第一部分肯定会有所裨益。
> 
> * * *
> 
> ## 我们的前三个课程推荐
> ## 
> ![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。
> 
> ![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析能力
> 
> ![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织 IT
> 
> * * *
> 
> 第一篇文章的介绍段落如下，以设定教程的一般氛围。

结构化查询语言（SQL）是数据科学行业中必不可少的技能，通常来说，学习这项技能相对简单。然而，大多数人忽略了 SQL 不仅仅是编写查询，这只是前进道路上的第一步。确保查询的性能或它们是否适合你所工作的上下文是完全不同的事情。

### 基于集合的方法与过程方法的查询

上述反模式中隐含的事实是，它们实际上归结为基于集合的方法与过程方法的差异。

过程方法的查询就像编程一样：你告诉系统做什么以及如何做。

例如，在联接中的冗余条件或滥用 `HAVING` 子句的情况，如上面的示例中，你通过执行一个函数查询数据库，然后调用另一个函数，或者使用包含循环、条件、用户定义函数（UDFs）、游标等逻辑来获得最终结果。在这种方法中，你经常会发现自己在请求数据的一个子集，然后从数据中请求另一个子集，依此类推。

不足为奇的是，这种方法常被称为“逐步”或“逐行”查询。

另一种方法是基于集合的方法，你只需指定要做什么。你的角色是指定查询结果集的条件或要求。如何检索数据，你将交给内部机制来决定查询的实现：你让数据库引擎决定执行查询的最佳算法或处理逻辑。

由于SQL是基于集合的，这种方法比过程型方法更有效也就不足为奇，这也解释了为什么在某些情况下SQL能比代码更快地工作。

**提示** 基于集合的查询方法也是数据科学行业中大多数顶级雇主要求你掌握的方法！你经常需要在这两种方法之间切换。

**注意** 如果你遇到过程型查询，你应该考虑重写或重构它。

### 从查询到执行计划

了解到反模式并非静态的，并随着你作为SQL开发人员的成长而演变，并且在考虑替代方案时需要考虑很多因素，也意味着避免查询反模式和重写查询可能是一项相当困难的任务。任何帮助都会派上用场，这就是为什么使用一些工具进行结构化优化查询可能是可行的方式。

**注意** 另外，上一节提到的一些反模式源于性能问题，比如`AND`、`OR`和`NOT`运算符及其缺乏索引的使用。考虑性能不仅需要更有结构的方法，还需要更深入的方法。

无论如何，这种结构化且深入的方法主要基于查询计划，正如你记得的那样，查询计划是查询首先解析成“解析树”的结果，并精确地定义了每个操作使用的算法以及操作的执行如何协调。

### 查询优化

正如你在介绍中所读到的，你可能需要手动检查和调整优化器生成的计划。在这种情况下，你需要通过查看查询计划再次分析你的查询。

要掌握这个计划，你需要使用你的数据库管理系统提供的工具。你可能可以使用的一些工具包括：

+   一些软件包提供了生成查询计划图形表示的工具。看看这个例子：

![](../Images/a67bb6d903a9f081ed2d79f225552560.png)

+   其他工具能够提供查询计划的文本描述。例如，Oracle中的`EXPLAIN PLAN`语句，但指令的名称因你使用的RDBMS而异。在其他地方，你可能会找到`EXPLAIN`（MySQL、PostgreSQL）或`EXPLAIN QUERY PLAN`（SQLite）。

**注意**，如果你在使用PostgreSQL，你需要区分`EXPLAIN`和`EXPLAIN ANALYZE`。`EXPLAIN`只是描述了规划器如何打算执行查询的想法，而不实际运行它，而`EXPLAIN ANALYZE`则实际执行查询，并返回预期与实际查询计划的分析。一般来说，实际执行计划是你实际运行查询时的计划，而估算执行计划则是对未执行查询的预估。虽然逻辑上等价，实际执行计划更有用，因为它包含了关于查询实际执行情况的额外细节和统计信息。

在本节的剩余部分，你将学习更多关于`EXPLAIN`和`ANALYZE`的信息，以及如何利用这两个工具了解你的查询计划和查询性能。为此，你将从一些示例开始，其中你将使用两个表：`one_million`和`half_million`。

你可以通过`EXPLAIN`检索表`one_million`的当前信息；确保将其放在查询的最上方，当查询运行时，它会返回查询计划：

```py
EXPLAIN
SELECT *
FROM one_million;

QUERY PLAN
____________________________________________________
Seq Scan on one_million
(cost=0.00..18584.82 rows=1025082 width=36)
(1 row)
```

在这种情况下，你会看到查询的成本是`0.00..18584.82`，行数是`1025082`。列数的宽度是`36`。

此外，你可以通过`ANALYZE`来更新你的统计信息。

```py
ANALYZE one_million;
EXPLAIN
SELECT *
FROM one_million;

QUERY PLAN
____________________________________________________
Seq Scan on one_million
(cost=0.00..18334.00 rows=1000000 width=37)
(1 row)
```

除了`EXPLAIN`和`ANALYZE`，你还可以通过`EXPLAIN ANALYZE`检索实际执行时间：

```py
EXPLAIN ANALYZE
SELECT *
FROM one_million;

QUERY PLAN
___________________________________________________________
Seq Scan on one_million
(cost=0.00..18334.00 rows=1000000 width=37)
(actual time=0.015..1207.019 rows=1000000 loops=1)
Total runtime: 2320.146 ms
(2 rows)
```

使用`EXPLAIN ANALYZE`的缺点显然是查询会实际执行，所以要小心！

直到现在，你看到的所有算法都是`Seq Scan`（顺序扫描）或全表扫描：这是对数据库进行的一种扫描，其中每一行表数据都按顺序（串行）读取，并检查找到的列是否满足条件。在性能方面，顺序扫描显然不是最佳的执行计划，因为你仍在进行*全表*扫描。然而，当表数据无法全部加载到内存时，这种扫描也不算太糟糕：即使是慢速磁盘，顺序读取也能比较快。

当你讨论索引扫描时，你会看到更多相关内容。

然而，还有一些其他的算法。例如，考虑这个用于联接的查询计划：

```py
EXPLAIN ANALYZE
SELECT *
FROM one_million JOIN half_million
ON (one_million.counter=half_million.counter);

QUERY PLAN
_________________________________________________________________
Hash Join (cost=15417.00..68831.00 rows=500000 width=42)
(actual time=1241.471..5912.553 rows=500000 loops=1)
Hash Cond: (one_million.counter = half_million.counter)
    -> Seq Scan on one_million
    (cost=0.00..18334.00 rows=1000000 width=37)
    (actual time=0.007..1254.027 rows=1000000 loops=1)
    -> Hash (cost=7213.00..7213.00 rows=500000 width=5)
    (actual time=1241.251..1241.251 rows=500000 loops=1)
    Buckets: 4096 Batches: 16 Memory Usage: 770kB
    -> Seq Scan on half_million
    (cost=0.00..7213.00 rows=500000 width=5)
(actual time=0.008..601.128 rows=500000 loops=1)
Total runtime: 6468.337 ms
```

你会看到查询优化器选择了`Hash Join`！记住这个操作，因为你将需要它来估计查询的时间复杂度。目前要注意的是，`half_million.counter`上没有索引，你可以在下一个示例中添加它：

```py
CREATE INDEX ON half_million(counter);
EXPLAIN ANALYZE
SELECT *
FROM one_million JOIN half_million
ON (one_million.counter=half_million.counter);

QUERY PLAN
________________________________________________________________
Merge Join (cost=4.12..37650.65 rows=500000 width=42)
(actual time=0.033..3272.940 rows=500000 loops=1)
Merge Cond: (one_million.counter = half_million.counter)
    -> Index Scan using one_million_counter_idx on one_million
    (cost=0.00..32129.34 rows=1000000 width=37)
    (actual time=0.011..694.466 rows=500001 loops=1)
    -> Index Scan using half_million_counter_idx on half_million
    (cost=0.00..14120.29 rows=500000 width=5)
(actual time=0.010..683.674 rows=500000 loops=1)
Total runtime: 3833.310 ms
(5 rows)
```

你会看到，通过创建索引，查询优化器现在决定使用`Merge join`，其中`Index Scan`正在进行。

**注意** 区分索引扫描和全表扫描或顺序扫描：前者，也称为“表扫描”，扫描数据或索引页以找到适当的记录，而后者扫描表的每一行。

你会看到总运行时间减少了，性能应该更好，但有两个索引扫描，这意味着内存变得更重要，特别是当表无法完全放入内存时。在这种情况下，你首先要进行全索引扫描，这些是快速的顺序读取，没有问题，但随后你有大量的随机读取来通过索引值提取行。正是这些随机读取通常比顺序读取慢几个数量级。在这些情况下，全表扫描确实比全索引扫描更快。

**提示**：如果你想更多了解`EXPLAIN`或详细查看示例，可以考虑阅读由 Guillaume Lelarge 编写的书籍 [“理解 Explain”](http://www.dalibo.org/_media/understanding_explain.pdf)。

### 更多相关主题

+   [转行数据科学的终极指南](https://www.kdnuggets.com/2022/05/definitive-guide-switching-career-data-science.html)

+   [Python 函数参数：终极指南](https://www.kdnuggets.com/2023/02/python-function-arguments-definitive-guide.html)

+   [解决 MySQL 中幻读问题的终极指南](https://www.kdnuggets.com/2022/06/definitive-guide-solving-phantom-read-mysql.html)

+   [逐步阅读和理解 SQL 查询的指南](https://www.kdnuggets.com/a-step-by-step-guide-to-reading-and-understanding-sql-queries)

+   [如何在本地 Python 中编写 SQL](https://www.kdnuggets.com/2022/02/easy-sql-native-python.html)

+   [KDnuggets 新闻，12 月 7 日：十大数据科学误区揭示 • 4…](https://www.kdnuggets.com/2022/n47.html)
