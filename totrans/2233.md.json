["```py\nX, y = datasets.make_regression(\n        n_samples=500, n_features=1, noise=15, random_state=4)\n```", "```py\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self, lr: int = 0.01, n_iters: int = 1000) -> None:\n        self.lr = lr\n        self.n_iters = n_iters\n        self.weights = None\n        self.bias = None\n```", "```py\ndef fit(self, X, y):\n        num_samples, num_features = X.shape     # X shape [N, f]\n        self.weights = np.random.rand(num_features)  # W shape [f, 1]\n        self.bias = 0\n```", "```py\n# y_pred shape should be N, 1\ny_pred = np.dot(X, self.weights) + self.bias\n```", "```py\n# X -> [ N, f ]\n# y_pred -> [ N ]\n# dw -> [ f ]\ndw = (1 / num_samples) * np.dot(X.T, y_pred - y)\ndb = (1 / num_samples) * np.sum(y_pred - y)\n```", "```py\nself.weights = self.weights - self.lr * dw\nself.bias = self.bias - self.lr * db\n```", "```py\nfor i in range(self.n_iters):\n\n            # y_pred shape should be N, 1\n            y_pred = np.dot(X, self.weights) + self.bias\n\n            # X -> [N,f]\n            # y_pred -> [N]\n            # dw -> [f]\n            dw = (1 / num_samples) * np.dot(X.T, y_pred - y)\n            db = (1 / num_samples) * np.sum(y_pred - y)\n\n            self.weights = self.weights - self.lr * dw\n            self.bias = self.bias - self.lr * db\n```", "```py\ndef predict(self, X):\n        return np.dot(X, self.weights) + self.bias\n```", "```py\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self, lr: int = 0.01, n_iters: int = 1000) -> None:\n        self.lr = lr\n        self.n_iters = n_iters\n        self.weights = None\n        self.bias = None\n\n    def fit(self, X, y):\n        num_samples, num_features = X.shape     # X shape [N, f]\n        self.weights = np.random.rand(num_features)  # W shape [f, 1]\n        self.bias = 0\n\n        for i in range(self.n_iters):\n\n            # y_pred shape should be N, 1\n            y_pred = np.dot(X, self.weights) + self.bias\n\n            # X -> [N,f]\n            # y_pred -> [N]\n            # dw -> [f]\n            dw = (1 / num_samples) * np.dot(X.T, y_pred - y)\n            db = (1 / num_samples) * np.sum(y_pred - y)\n\n            self.weights = self.weights - self.lr * dw\n            self.bias = self.bias - self.lr * db\n\n        return self\n\n    def predict(self, X):\n        return np.dot(X, self.weights) + self.bias\n```"]