- en: SQL Window Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 窗口函数
- en: 原文：[https://www.kdnuggets.com/2022/04/sql-window-functions.html](https://www.kdnuggets.com/2022/04/sql-window-functions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2022/04/sql-window-functions.html](https://www.kdnuggets.com/2022/04/sql-window-functions.html)
- en: '![SQL Window Functions](../Images/62145a3f36ad392a97a34e92073393bd.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 窗口函数](../Images/62145a3f36ad392a97a34e92073393bd.png)'
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Writing well-structured, efficient SQL queries is no easy task. It requires
    a thorough knowledge of all SQL functions and statements, so that you can apply
    them in your everyday job to solve problems efficiently. In this article, we’ll
    talk about SQL window functions, which offer a lot of utility to solve common
    problems, but they are often overlooked.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写结构良好、有效的 SQL 查询并非易事。它需要对所有 SQL 函数和语句有深入的了解，以便你能在日常工作中高效地应用它们来解决问题。在这篇文章中，我们将讨论
    SQL 窗口函数，它们提供了很多实用的功能来解决常见问题，但常常被忽视。
- en: '* * *'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our Top 3 Course Recommendations
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的三大课程推荐
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity)
    - 快速进入网络安全职业。'
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics)
    - 提升你的数据分析技能'
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport)
    - 支持你的组织的 IT'
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: SQL window functions are very versatile, and can be used to address many different
    problems in SQL.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 窗口函数非常多功能，可以用于解决 SQL 中的许多不同问题。
- en: Almost all companies ask interview questions that require at least some knowledge
    of window functions to answer. So if you’re [preparing for a data science interview](https://www.stratascratch.com/blog/5-tips-to-prepare-for-a-data-science-interview/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets),
    it’s a good idea to refresh your knowledge of window functions in SQL. In this
    article, we will focus on the basics. If you’d like to gain a deeper understanding,
    read [this ultimate guide to SQL window functions](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-window-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有公司在面试中都会提问一些需要了解窗口函数的知识的问题。因此，如果你正在[准备数据科学面试](https://www.stratascratch.com/blog/5-tips-to-prepare-for-a-data-science-interview/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)，重新复习一下
    SQL 中的窗口函数是个不错的主意。在这篇文章中，我们将重点介绍基础知识。如果你想深入了解，可以阅读[这篇 SQL 窗口函数终极指南](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-window-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)。
- en: Having a good grasp of window functions can also help you [write efficient and
    optimized SQL queries](https://www.stratascratch.com/blog/best-practices-to-write-sql-queries-how-to-structure-your-code/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    to address problems you encounter in your everyday job.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对窗口函数有一个良好的掌握也有助于你[编写高效和优化的 SQL 查询](https://www.stratascratch.com/blog/best-practices-to-write-sql-queries-how-to-structure-your-code/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)来解决你在日常工作中遇到的问题。
- en: What is a Window Function in SQL?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 SQL 中的窗口函数？
- en: In simple words, window functions in SQL are used to access all other rows of
    the table to generate a value for the current row.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，SQL 中的窗口函数用于访问表中的所有其他行，以生成当前行的值。
- en: SQL Window functions get their name because their syntax allows you to define
    a specific portion, or window of data to work on. First, we define a function,
    which will run on all rows, and then we use the OVER clause to specify the window
    of data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 窗口函数之所以得名，是因为其语法允许你定义特定的部分或数据窗口来进行操作。首先，我们定义一个函数，这个函数会在所有行上运行，然后使用 OVER
    子句来指定数据窗口。
- en: '![What is a Window Function in SQL](../Images/0dd2a39698ed79bc0bd109d820c5fe2b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![什么是 SQL 中的窗口函数](../Images/0dd2a39698ed79bc0bd109d820c5fe2b.png)'
- en: Window functions are considered an ‘advanced’ feature of SQL. At first glance,
    junior data scientists might be scared by the syntax, but with a little practice,
    SQL window functions can become much less scary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数被认为是 SQL 的“高级”功能。乍一看，初级数据科学家可能会对其语法感到畏惧，但经过一些练习，SQL 窗口函数会变得不那么令人害怕。
- en: SQL Window Function Types
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 窗口函数类型
- en: '![SQL Window Function Types](../Images/843f9118d6c90041e43e2d7461b105e6.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![SQL窗口函数类型](../Images/843f9118d6c90041e43e2d7461b105e6.png)'
- en: '**Aggregate Window Functions** are necessary to do calculations or find the
    lowest or highest extremes of data within the window of data. These are the same
    as regular aggregate functions, but they are applied to specific windows of data,
    so their behavior is different.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合窗口函数**是进行计算或找到数据窗口内最低或最高极值所必需的。它们与常规聚合函数相同，但它们应用于特定的数据窗口，因此行为有所不同。'
- en: '**Ranking Window Functions** give us the ability to assign rank numbers to
    a window of data. Each of the 6 major functions ranks rows differently. The ranking
    also depends on the use of ORDER BY statement.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**排名窗口函数**使我们能够为数据窗口分配排名号码。六种主要函数中的每一种对行的排名方式不同。排名还取决于ORDER BY语句的使用。'
- en: '**Value Window Functions** allow us to find the values based on their position
    relative to the current row. They are useful for getting the value from previous
    or following rows, and for analysis of time-series data.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**值窗口函数**允许我们根据其相对于当前行的位置找到值。它们对于获取前一行或后一行的值，以及分析时间序列数据非常有用。'
- en: This is just a short overview of three types of SQL window functions. We’ll
    discuss them in detail in later parts of the article.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对三种SQL窗口函数的简要概述。我们将在文章的后续部分详细讨论它们。
- en: How and When To Use Them?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何以及何时使用它们？
- en: Once you understand all the window functions and their use cases, it will become
    a powerful tool at your disposal. They can save you from writing many unnecessary
    lines of code to solve the problems that can be solved by a single window function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了所有窗口函数及其使用案例，它们将成为你手中的强大工具。它们可以避免你编写许多不必要的代码行来解决可以通过一个窗口函数解决的问题。
- en: SQL Window Functions VS Group By Statement
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL窗口函数与Group By语句
- en: Beginners who read the description of window functions are often confused about
    what it’s supposed to do and how they’re different from the Group By statement,
    which seems to work in the exact same way. However, the confusion will go away
    if you write window functions and see their actual output.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者在阅读窗口函数的描述时，常常会对其作用和与Group By语句的区别感到困惑，因为后者似乎以完全相同的方式工作。然而，如果你编写窗口函数并查看其实际输出，困惑会消失。
- en: The most significant difference between the Window functions and the Group By
    statement is that the former allows us to summarize the values while keeping all
    of the original data. The GROUP BY statement also lets us generate the aggregate
    values, but the rows are collapsed into a few groups of data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数与Group By语句之间最显著的区别在于，前者允许我们在保留所有原始数据的同时总结值。GROUP BY语句也允许我们生成聚合值，但行被压缩成几个数据组。
- en: Use Cases
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用案例
- en: '[Getting a job as a data scientist](https://www.stratascratch.com/blog/how-to-get-a-data-science-job-the-ultimate-guide/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    is only the beginning. In your everyday job you’ll encounter problems that need
    to be solved efficiently. Window functions are very versatile and they will be
    invaluable as long as you know how to use them.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[成为数据科学家的职业路径](https://www.stratascratch.com/blog/how-to-get-a-data-science-job-the-ultimate-guide/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)仅仅是开始。在你日常工作中，你会遇到需要高效解决的问题。窗口函数非常多才多艺，只要你知道如何使用它们，它们将是无价的。'
- en: For instance, if you’re working for a company like Apple, you might need to
    analyze inner sales data to find the most popular, or the least popular products
    in their portfolio. One of the most common use cases of window functions is to
    track time-series data. For instance, you might have to calculate month-over-month
    growth or decline of specific Apple products, or bookings on Airbnb platform.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，如果你在像苹果公司这样的公司工作，你可能需要分析内部销售数据，以找到其产品组合中最受欢迎或最不受欢迎的产品。窗口函数最常见的用例之一是跟踪时间序列数据。例如，你可能需要计算特定苹果产品的月度增长或下降，或Airbnb平台上的预订情况。
- en: Data scientists who work for SaaS companies are often tasked with calculating
    user churn rate, and track its changes over time. As long as you have user data,
    you can use window functions to keep track of churn rate.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在SaaS公司工作的数据科学家经常被要求计算用户流失率，并跟踪其随时间的变化。只要你有用户数据，就可以使用窗口函数来跟踪流失率。
- en: Aggregate window functions, such as **SUM()** can be useful for calculating
    running totals. Let’s imagine that we have sales data for all 12 months of the
    year. With window functions, we can write a query to calculate a running total
    (current month + the total of previous months) of the sales data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合窗口函数，如 **SUM()**，对于计算累计总数非常有用。假设我们有一整年的12个月销售数据，使用窗口函数，我们可以编写查询来计算销售数据的累计总数（当前月份+之前月份的总数）。
- en: Window functions have many other use cases. For example, if you’re working with
    user data, you can order users by when they signed up, the number of sent messages
    or other similar metrics.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数有许多其他用途。例如，如果你正在处理用户数据，你可以按用户注册时间、发送的消息数量或其他类似指标来排序用户。
- en: Window functions also allow us to keep track of health statistics, such as changes
    in the virus spread, the severity of cases, or other similar insights.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数还允许我们跟踪健康统计数据，例如病毒传播的变化、病例的严重程度或其他类似的见解。
- en: With Other SQL Keywords
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与其他SQL关键字
- en: In order to effectively use window functions, you must first understand the
    order of operations in SQL. You can only use window functions with the operations
    that come after the window functions, not before them. In accordance with this
    rule, it’s possible to use window functions with the SELECT and ORDER BY statements,
    but not with others, such as WHERE and GROUP BY.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效使用窗口函数，必须首先理解SQL中的操作顺序。你只能在窗口函数之后使用窗口函数，而不能在之前使用。根据这一规则，可以在SELECT和ORDER
    BY语句中使用窗口函数，但不能在WHERE和GROUP BY等其他语句中使用。
- en: Typically SQL developers use window functions with the SELECT statement, and
    the main query can include the ORDER BY statement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，SQL开发者使用窗口函数与SELECT语句，主查询可以包括ORDER BY语句。
- en: Ranking Window Functions in SQL
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL中的排名窗口函数
- en: These functions allow SQL developers to assign numerical rank to rows.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数允许SQL开发者为行分配数字排名。
- en: 'There are six functions of this type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 共有六种此类函数：
- en: '**ROW_NUMBER()** simply numerates the rows starting from 1\. The order of rows
    depends on the ORDER BY statement. If there is none, the **ROW_NUMBER()** function
    will simply numerate the rows in their initial state.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROW_NUMBER()** 只是简单地从1开始对行进行编号。行的顺序取决于ORDER BY语句。如果没有ORDER BY，**ROW_NUMBER()**
    函数将按行的初始状态进行编号。'
- en: '**RANK()** is a more nuanced version of the **ROW_NUMBER()** function. **RANK()**
    considers if the values are equal and assigns them the same rank. For instance,
    if the values in the third and fourth rows are equal, it will assign them both
    ranks of three, and, starting from the fifth row, it will continue counting from
    5.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**RANK()** 是 **ROW_NUMBER()** 函数的一个更细致的版本。**RANK()** 会考虑值是否相等并分配相同的排名。例如，如果第三行和第四行的值相等，它们都将被分配为第三名，从第五行开始，将从5继续计数。'
- en: '**DENSE_RANK()** works just like the **RANK()** function, except for one difference.
    In the same example, if the values in third and fourth columns are tied, both
    will be assigned the rank of three. However, the fifth row will not start counting
    from 5, but from 4, considering the fact that previous rows have a rank of three.
    To learn more about the differences, check this post ? [An Introduction to the
    SQL Rank Functions](https://www.stratascratch.com/blog/an-introduction-to-the-sql-rank-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**DENSE_RANK()** 的工作方式与 **RANK()** 函数类似，唯一的区别是：在同一个例子中，如果第三列和第四列的值相同，它们都会被分配为三的排名。然而，第五行不会从5开始计数，而是从4开始，考虑到之前的行排名为三。要了解更多差异，请查看这篇文章
    [SQL排名函数简介](https://www.stratascratch.com/blog/an-introduction-to-the-sql-rank-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)。'
- en: '**PERCENT_RANK()** uses a different approach to ranking. It creates a new column
    to display the rank values in percentages (from 0 to 1).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**PERCENT_RANK()** 采用不同的排名方法。它创建一个新列，以百分比（从0到1）显示排名值。'
- en: '**NTILE()** is a function that takes one numerical argument, which will create
    batches to divide the data. For instance, **NTILE(20)** will create 20 buckets
    of rows, and assign the rank accordingly.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTILE()** 是一个函数，它接受一个数值参数，用于创建批次以划分数据。例如，**NTILE(20)** 将创建20个数据桶，并相应地分配排名。'
- en: '**CUME_DIST()** function calculates cumulative distribution of the current
    row. In other words, it goes through every record in the window and returns the
    portion of the rows with values that are less than or equal to the value in the
    current row. The relative size of these rows is between 0 (none) and 1 (all).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**CUME_DIST()** 函数计算当前行的累积分布。换句话说，它会遍历窗口中的每一条记录，并返回当前行值小于或等于的行所占的比例。这些行的相对大小介于
    0（无）和 1（全部）之间。'
- en: Ranking Data With RANK()
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 RANK() 排名数据
- en: Ranking Window Functions often come up during the interviews at major tech companies.
    For example, interviewers at Facebook/Meta often ask candidates to [find the most
    active users on Messenger](https://platform.stratascratch.com/coding/10295-most-active-users-on-messenger?python=&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 排名窗口函数在大型科技公司面试中经常出现。例如，Facebook/Meta 的面试官常常会要求候选人 [找到 Messenger 上最活跃的用户](https://platform.stratascratch.com/coding/10295-most-active-users-on-messenger?python=&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)。
- en: '![Ranking Data With RANK](../Images/b9f508afefd00d4f17a5205dc3eb1132.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![使用 RANK 排名数据](../Images/b9f508afefd00d4f17a5205dc3eb1132.png)'
- en: 'To answer this question, we must first look at the available data. We have
    one table with multiple different columns. The values of **user1** and **user2**
    columns are usernames, and the **msg_count** column represents the number of messages
    exchanged between them. According to the name of the question, we must find the
    users with the highest number of recorded activities. To do that, we must first
    think about what the activity is: in this context, both sending and receiving
    a message counts as an activity.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们必须首先查看可用的数据。我们有一个包含多个不同列的表格。**user1** 和 **user2** 列的值是用户名，**msg_count**
    列代表它们之间交换的消息数量。根据问题的名称，我们必须找出记录活动次数最多的用户。为了做到这一点，我们必须首先考虑什么是活动：在这个上下文中，发送和接收消息都算作活动。
- en: After looking at the data, we see that the **msg_count** does not represent
    a total number of messages sent and received by each user in the record. There
    may be other users they are chatting with. In order to get the total number of
    activities for each user, we must get the value in the **msg_count** column where
    they are at least on the sending or receiving end of the messages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看数据后，我们发现**msg_count**并不代表每个用户在记录中的总消息数量。可能还有其他用户他们正在聊天。为了获取每个用户的总活动数量，我们必须获取**msg_count**列中用户至少是发送或接收消息的一方的值。
- en: 'Let’s take a look at the sample of data from this task:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看一下这项任务的数据样本：
- en: '![table](../Images/ce984d5c012161dca68bb806da5e373c.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![表格](../Images/ce984d5c012161dca68bb806da5e373c.png)'
- en: As you can see, the user called **sgoodman** is a part of two conversations
    - one is with the username **wangdenise** and the other with **wolfelizabeth**.
    In real life, people can have online conversations with dozens of people. Our
    query should capture the number of messages exchanged between them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，用户**sgoodman**参与了两个对话 - 一个是与用户名**wangdenise**的对话，另一个是与**wolfelizabeth**的对话。在现实生活中，人们可能与数十人进行在线对话。我们的查询应该捕获他们之间交换的消息数量。
- en: Solution
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '**Step 1: Combine users in one column**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1：将用户合并到一列中**'
- en: First, we select usernames in the **user1** column with their corresponding
    **msg_count** value. Then we do the same for users in the **user2** column and
    combine them in one column. We use the UNION ALL operator to do so. This will
    ensure that all of the users, with their corresponding, sent or received **msg_count**
    values are kept in place.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择**user1** 列中的用户名及其相应的**msg_count** 值。然后对**user2** 列中的用户做相同的操作，并将它们合并到一个列中。我们使用
    UNION ALL 操作符来完成这个操作。这将确保所有用户及其相应的发送或接收的**msg_count** 值都被保留。
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We must keep in mind that in order for **UNION ALL** statements to combine the
    values, the number of columns in both SELECT statements and their respective value
    types must be the same. So we use the **AS** statement to rename them to **username**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，为了使**UNION ALL**语句能够合并值，两个 SELECT 语句中的列数及其相应的值类型必须相同。因此，我们使用**AS**语句将它们重命名为**username**。
- en: 'If we run this code, we’ll get the following result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会得到以下结果：
- en: '![result](../Images/b726ca832be6ea32cb69081d5e181349.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![结果](../Images/b726ca832be6ea32cb69081d5e181349.png)'
- en: '**Step 2: Order the users in decreasing order**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：按降序排列用户**'
- en: Once we have the list of all the users, we must select the **username** column
    from the above table and add up the **msg_count** values of every individual user.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有用户的列表，我们必须从上述表中选择**username**列，并将每个用户的**msg_count**值相加。
- en: Then we’ll use the **RANK()** window function to enumerate every record. In
    this case, we want to use this specific function, instead of **DENSE_RANK()**
    because of possible ties in the number of messages within the TOP 10.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用**RANK()**窗口函数对每条记录进行编号。在这种情况下，我们想使用这个特定的函数，而不是**DENSE_RANK()**，因为在前10名中的消息数量可能存在并列情况。
- en: The accuracy of ranking window functions depends on the **ORDER BY** statement,
    which is used to arrange the values within the window of input data, not the output
    of the function. In this case, we must use the **DESC** keyword to make sure that
    the number of messages is arranged in descending order. This way, **RANK()** function
    is applied to the highest input values first.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 排名窗口函数的准确性依赖于**ORDER BY**语句，它用于在输入数据窗口内排列值，而不是函数的输出。在这种情况下，我们必须使用**DESC**关键字，以确保消息数量按降序排列。这样，**RANK()**
    函数会首先应用于最高的输入值。
- en: The OVER keyword is an essential part of window functions syntax. It is used
    to connect the ranking function to the window of data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: OVER 关键字是窗口函数语法中的一个重要部分。它用于将排名函数连接到数据窗口。
- en: 'So far, our SQL query should look something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 SQL 查询应该类似于这样：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To solve our question, we must find the 10 most active users. Using the **RANK()**
    window function is necessary to handle the cases when there are any ties within
    that group of 10 users.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的问题，我们必须找到10个最活跃的用户。使用**RANK()**窗口函数是必要的，以处理在这10个用户组中可能出现的任何并列情况。
- en: '**Step 3:** **Display the TOP 10**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：** **显示前10名**'
- en: In the final step, we should get **username** and **total_msg_count** values
    from the **sq** subquery, and display the ones that have a **rank** value of 10
    or less. Then arrange them in descending order.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们应该从**sq**子查询中获取**username**和**total_msg_count**值，并显示排名值为10或更小的记录。然后按降序排列它们。
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we run this code, we’ll see that it works as it should. And we potentially
    avoid any errors in case some of the users had identical **total_msg_count** values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会看到它按预期工作。同时，我们可以避免在某些用户的**total_msg_count**值相同的情况下出现任何错误。
- en: '![result](../Images/a66ec3bc52048727550aca06d8c43d35.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![result](../Images/a66ec3bc52048727550aca06d8c43d35.png)'
- en: Finding the Top 5 Percentile Values
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 找到前5百分位数值
- en: Here is an example of another interview [question](https://platform.stratascratch.com/coding/10303-top-percentile-fraud?python=&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    asked at Netflix. A fictional insurance company has developed an algorithm to
    determine the chances of an insurance claim being fraudulent. Candidates must
    find the claims in the TOP 5 percentile that are the most likely to be a fraud.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个 Netflix 面试中问到的 [问题](https://platform.stratascratch.com/coding/10303-top-percentile-fraud?python=&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    的例子。一个虚构的保险公司开发了一个算法来确定保险索赔的欺诈可能性。候选人必须找到前5百分位中最有可能欺诈的索赔。
- en: '![](../Images/b9f9b92881edd323f4ee82af058edb88.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b9f9b92881edd323f4ee82af058edb88.png)'
- en: As you might’ve noticed, this question revolves around finding percentile values.
    The easiest way to do so is using the **NTILE()** ranking window function in SQL.
    In this case, we are looking for a percentile value, so the argument to **NTILE()**
    would be 100.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，这个问题涉及到寻找百分位数值。最简单的方法是使用 SQL 中的**NTILE()**排名窗口函数。在这种情况下，我们正在寻找百分位数值，所以**NTILE()**的参数将是100。
- en: The instructions say that we have to identify the top 5 percentile of fraudulent
    claims from each state. To do that, our window definition should include the **PARTITION
    BY** statement. Partition is a way to specify how to group values within the window.
    For instance, if you had a spreadsheet of users, you could partition them based
    on the month they signed up.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 指令说我们需要确定每个州前5百分位的欺诈性索赔。为此，我们的窗口定义应该包括**PARTITION BY**语句。分区是一种指定如何在窗口内分组值的方法。例如，如果你有一个用户的电子表格，你可以根据他们注册的月份进行分区。
- en: In this case, we must partition the values in the **state** column. This means
    calculating percentiles of each claim from each state. We use the **ORDER BY**
    statement to arrange the values in the **fraud_score** column in descending order.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须对**state**列中的值进行分区。这意味着计算每个州每个索赔的百分位数。我们使用**ORDER BY**语句将**fraud_score**列中的值按降序排列。
- en: Note that because the **ORDER BY** and **PARTITION BY** statements are used
    within the window definition, they only apply to each ‘group’ of records, each
    group representing one state. For instance, the records from California are arranged
    based on the value in their **fraud_score column,** the rows with highest values
    coming first. As soon as there are no more rows for California, the order is reset
    and starts over from the highest scoring record in another state, Florida.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为 **ORDER BY** 和 **PARTITION BY** 语句用于窗口定义中，它们仅适用于每个记录的“组”，每个组代表一个状态。例如，加州的记录根据其
    **fraud_score 列** 的值进行排列，值最高的行排在最前面。当加州的记录用尽时，顺序会重置，从另一个州佛罗里达州的最高分记录开始。
- en: '![second highest salary](../Images/a26c1e7034bdd6a8cb4f10ce6d6bd8d0.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![第二高薪水](../Images/a26c1e7034bdd6a8cb4f10ce6d6bd8d0.png)'
- en: Finding the Nth Highest Value
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找第 N 高的值
- en: 'There is another [question](https://platform.stratascratch.com/coding/9892-second-highest-salary?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets),
    often asked at Amazon to gauge the candidate’s proficiency in Ranking Window Functions.
    The task is simple: you are given a single table with many different columns.
    The question asks us to find the second highest salary of all employee records.
    After analyzing the available data, it becomes obvious that the most important
    is the **salary** column.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个[问题](https://platform.stratascratch.com/coding/9892-second-highest-salary?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)，经常在亚马逊用来评估候选人对排名窗口函数的熟练程度。任务很简单：你会得到一个包含许多不同列的单一表格。问题要求我们找出所有员工记录中的第二高薪水。分析可用数据后，最重要的列显然是
    **salary** 列。
- en: '![result](../Images/f55ad12a33e67524a18abb2f497e0d5a.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![结果](../Images/f55ad12a33e67524a18abb2f497e0d5a.png)'
- en: In this case, the wording of the question tells us to find the second highest
    salary at the company. So if five employees all have a salary of 100 000$ per
    year, and it is the highest salary, we’ll have to access the sixth employee, who
    is next in the descending order of salaries.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，问题的措辞告诉我们要找出公司中第二高的薪水。因此，如果五名员工的年薪都是 100,000 美元，并且这是最高薪水，我们需要查找第六名员工，他在薪水降序中排在后面。
- en: If you look at the current [solution](https://platform.stratascratch.com/coding/9892-second-highest-salary?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    on StrataScratch, we use the **DENSE_RANK()** window function to get the second-highest
    value. Also, we use the DISTINCT keyword to weed out duplicates, in case multiple
    employees have the same salary. We want to rank every remaining record individually,
    so there’s no need to use the PARTITION BY statement to separate groups of employees.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看当前在 StrataScratch 上的[解决方案](https://platform.stratascratch.com/coding/9892-second-highest-salary?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)，我们使用
    **DENSE_RANK()** 窗口函数来获取第二高的值。此外，我们使用 DISTINCT 关键字来排除重复项，以防多个员工拥有相同的薪水。我们希望对每个剩余记录进行单独排名，因此不需要使用
    PARTITION BY 语句来分隔员工组。
- en: Aggregate Window Functions in SQL
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 中的聚合窗口函数
- en: The default behavior of aggregate functions in SQL is to aggregate the data
    of all records into a few groups. However, when used as window functions, all
    rows are kept intact. Instead, aggregate window functions create a separate column
    for storing the results of aggregation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，聚合函数的默认行为是将所有记录的数据聚合到几个组中。然而，当作为窗口函数使用时，所有行都会保持不变。相反，聚合窗口函数会创建一个单独的列来存储聚合结果。
- en: 'There are five aggregate window functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种聚合窗口函数：
- en: '**AVG() -** returns the average of values in a specific column or subset of
    data'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**AVG()** - 返回特定列或数据子集中的值的平均值'
- en: '**MAX()** - returns the highest value in a specific column or subset of data'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**MAX()** - 返回特定列或数据子集中的最高值'
- en: '**MIN()** -  returns the lowest value in a specific column or subset of data'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**MIN()** - 返回特定列或数据子集中的最低值'
- en: '**SUM()** - returns the sum of all values in a specific column or subset of
    data'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**SUM()** - 返回特定列或数据子集中的所有值的总和'
- en: '**COUNT()** - returns the number of rows in a column or a subset of data'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**COUNT()** - 返回列或数据子集中的行数'
- en: Interview questions often revolve around aggregate window functions. For instance,
    it’s a common task to calculate a running sum and create a new column to display
    the running sum for every record. For common uses of this SQL window function
    during interviews, refer to this [ultimate guide to SQL aggregate functions](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-aggregate-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 面试问题经常围绕聚合窗口函数。例如，计算运行总和并创建一个新列来显示每条记录的运行总和是一项常见任务。有关面试中常用的 SQL 窗口函数的更多信息，请参阅这个
    [SQL 聚合函数终极指南](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-aggregate-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)。
- en: '**Finding the Latest Date**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找最新日期**'
- en: To better understand aggregate window functions, let’s look at one [interview
    question](https://platform.stratascratch.com/coding/2003-recent-refinance-submissions?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    from Credit Karma.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解聚合窗口函数，让我们看看一个来自 Credit Karma 的 [面试问题](https://platform.stratascratch.com/coding/2003-recent-refinance-submissions?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)。
- en: '![ref](../Images/a135af3bf163007c1acb788f0b2fe00d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![ref](../Images/a135af3bf163007c1acb788f0b2fe00d.png)'
- en: 'In this question, we have to find and output the most recent balance for every
    user’s ‘Refinance’ submission. To better understand the question, we must analyze
    the available data, made up of two tables: **loans** and **submissions**.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要找到并输出每个用户‘Refinance’提交的最新余额。为了更好地理解问题，我们必须分析可用的数据，这些数据由两个表组成：**loans**
    和 **submissions**。
- en: 'Let’s take a look at the **loans** table:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 **loans** 表：
- en: '![loan table](../Images/667c909629697676ade01f90d9151499.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![loan table](../Images/667c909629697676ade01f90d9151499.png)'
- en: 'Next, the **submissions** table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 **submissions** 表：
- en: '![submission](../Images/911a3b77fa5ee641f79d22d3aab853e4.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![submission](../Images/911a3b77fa5ee641f79d22d3aab853e4.png)'
- en: 'To answer this question successfully, it’s essential to analyze both tables
    and the data within them. Then we can use aggregate window functions to solve
    key pieces of the puzzle: find the most recent submission for each user.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功回答这个问题，分析这两个表及其数据是必不可少的。然后我们可以使用聚合窗口函数解决关键问题：为每个用户找到最近的提交。
- en: To do this, a candidate must understand that the **MAX()** aggregate function
    will return the ‘highest’ date, which in SQL is equivalent to the latest date.
    **MAX()** window function must be applied to the **created_at** column in the
    **loans** table, where every record represents a single submission.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，候选人必须了解 **MAX()** 聚合函数将返回‘最高’日期，这在 SQL 中等同于最新日期。**MAX()** 窗口函数必须应用于 **loans**
    表中的 **created_at** 列，其中每条记录代表一个单独的提交。
- en: Another key piece of the puzzle is that the rows should be partitioned by **user_id**
    value, to make sure we generate the latest date for every unique user, in case
    they’ve made multiple submissions. The question specifies that we should find
    the latest submission of the ‘Refinance’ type, so our SQL query should include
    that condition.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键点是行应该按 **user_id** 值进行分区，以确保我们为每个唯一用户生成最新日期，以防他们进行了多次提交。问题指定我们应该找到‘Refinance’类型的最新提交，因此我们的
    SQL 查询应包括该条件。
- en: Value Window Functions in SQL
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 中的值窗口函数
- en: 'SQL developers can use these functions to take values from other rows in the
    table. Like the other two types of window functions, there are five distinct functions
    of this kind. These are exclusively for window functions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 开发者可以使用这些函数从表中的其他行中获取值。像其他两种类型的窗口函数一样，这些函数有五种不同的类型。这些函数专用于窗口函数：
- en: '**LAG()** function allows us to access values from previous rows.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**LAG()** 函数允许我们访问前一行的值。'
- en: '**LEAD()** is the opposite of **LAG()**, and allows us to access values from
    records that come after the current row.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**LEAD()** 是 **LAG()** 的对立面，允许我们访问当前行之后的记录中的值。'
- en: '**FIRST_VALUE()** function returns the first value from the dataset and allows
    us to set the condition for ordering the data, so the developer can control which
    value will come first.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIRST_VALUE()** 函数从数据集中返回第一个值，并允许我们设置数据排序条件，以便开发者可以控制哪个值将首先出现。'
- en: The **LAST_VALUE()** function works the same way as the previous function, but
    it returns the last value instead of the first.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**LAST_VALUE()** 函数的工作方式与之前的函数相同，但它返回的是最后一个值而不是第一个。'
- en: '**NTH_VALUE()** function allows developers to specify which value in the order
    should be returned.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTH_VALUE()** 函数允许开发者指定在排序中应返回哪个值。'
- en: Time Series Analysis
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间序列分析
- en: Functions like **LAG()** and **LEAD()** allow you to extract values from the
    rows that follow or precede each row. For this reason, SQL developers often use
    them to work with time-series data, tracking daily or monthly growth, and other
    use-cases. Let’s look at a [question](https://platform.stratascratch.com/coding/10319-monthly-percentage-difference?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    asked at Amazon interviews that can be solved using the **LAG()** function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像**LAG()**和**LEAD()**这样的函数允许你从每行的后续或前面的行中提取值。因此，SQL开发人员经常使用它们来处理时间序列数据，跟踪每日或每月的增长及其他应用场景。让我们看看在Amazon面试中提出的一个[问题](https://platform.stratascratch.com/coding/10319-monthly-percentage-difference?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)，它可以通过**LAG()**函数解决。
- en: '![monthly diff](../Images/a3f66ccad63fe3ded5bbb74bb8069df5.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![monthly diff](../Images/a3f66ccad63fe3ded5bbb74bb8069df5.png)'
- en: 'In this question, candidates have a fairly simple task: calculate monthly revenue
    growth based on the provided data. Ultimately, the output table should include
    a percentage value that represents month-over-month growth.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，候选人的任务相当简单：根据提供的数据计算每月的收入增长。**最终**，输出表应包括一个表示月度增长的百分比值。
- en: 'The **LAG()** window function allows us to solve this difficult question in
    just a few lines of code. Let’s take a look at the actual recommended solution:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**LAG()**窗口函数允许我们仅用几行代码解决这个难题。让我们看看实际推荐的解决方案：'
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The date values in the table are ordered from earlier to later. Therefore, all
    we have to do is calculate the total revenue for every month, and use the **LAG()**
    function to access the income value from the previous month and use it, along
    with current month’s revenue to calculate the monthly difference expressed in
    percentages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的日期值按时间顺序排列。因此，我们只需计算每个月的总收入，使用**LAG()**函数访问前一个月的收入值，并将其与当前月的收入一起使用，以计算以百分比表示的月度差异。
- en: In the solution above, we use the **round()** function to round the results
    of our equation. First, we define the window of data, where we arrange the date
    values and organize them in a specific format. We could do this directly in the
    window functions, but we will have to use it in multiple places. It’s more efficient
    to define the window once, and simply reference it as **w**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述解决方案中，我们使用**round()**函数对方程的结果进行四舍五入。首先，我们定义数据窗口，其中我们排列日期值并以特定格式组织它们。我们可以直接在窗口函数中做到这一点，但我们将不得不在多个地方使用它。一次定义窗口并简单地引用它为**w**会更高效。
- en: First, by subtracting lag(sum(value), 1) from sum(value) we find the numerical
    difference between each month and its previous month (except for the first, which
    doesn’t have a previous month). We divide this number by the previous month’s
    revenue, which we find using the **lag()** function. Finally, we multiply the
    result by 100 to get the percentage value, and specify that the value needs to
    be rounded to two decimal points.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过从sum(value)中减去lag(sum(value), 1)，我们找到了每个月与其前一个月之间的数值差（第一个月除外，因为它没有前一个月）。我们将这个数字除以前一个月的收入，该收入由**lag()**函数找出。最后，我们将结果乘以100，以获得百分比值，并指定该值需要四舍五入到小数点后两位。
- en: Final Words
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束语
- en: It shouldn’t be a surprise that many interview questions test the candidate’s
    knowledge of SQL window functions. Employers know that to perform at the highest
    level, data scientists must understand this part of SQL very well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 许多面试问题测试候选人对SQL窗口函数的知识，这并不奇怪。雇主知道，要在最高水平上表现，数据科学家必须非常了解SQL的这一部分。
- en: If you aspire to the role where you’ll be writing advanced SQL queries, a thorough
    understanding of SQL window functions can help you find easy solutions to complicated
    problems.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你渴望承担编写高级SQL查询的角色，对SQL窗口函数的透彻理解可以帮助你找到复杂问题的简单解决方案。
- en: '**[Nate Rosidi](https://www.stratascratch.com)** is a data scientist and in
    product strategy. He''s also an adjunct professor teaching analytics, and is the
    founder of [StrataScratch](https://www.stratascratch.com/), a platform helping
    data scientists prepare for their interviews with real interview questions from
    top companies. Connect with him on [Twitter: StrataScratch](https://twitter.com/StrataScratch)
    or [LinkedIn](https://www.linkedin.com/in/nathanrosidi/).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**[Nate Rosidi](https://www.stratascratch.com)** 是一位数据科学家和产品策略专家。他还是一位兼职教授，教授分析课程，并且是[StrataScratch](https://www.stratascratch.com/)的创始人，该平台帮助数据科学家通过来自顶级公司的真实面试问题为面试做准备。在[Twitter:
    StrataScratch](https://twitter.com/StrataScratch)或[LinkedIn](https://www.linkedin.com/in/nathanrosidi/)上与他联系。'
- en: More On This Topic
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解更多主题
- en: '[Top Five SQL Window Functions You Should Know For Data Science Interviews](https://www.kdnuggets.com/2022/01/top-five-sql-window-functions-know-data-science-interviews.html)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[你应该知道的五大 SQL 窗口函数用于数据科学面试](https://www.kdnuggets.com/2022/01/top-five-sql-window-functions-know-data-science-interviews.html)'
- en: '[KDnuggets™ News 22:n03, Jan 19: A Deep Look Into 13 Data…](https://www.kdnuggets.com/2022/n03.html)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[KDnuggets™ 新闻 22:n03, 1月19日：深入了解 13 个数据…](https://www.kdnuggets.com/2022/n03.html)'
- en: '[In-Database Analytics: Leveraging SQL''s Analytic Functions](https://www.kdnuggets.com/2023/07/indatabase-analytics-leveraging-sql-analytic-functions.html)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库内分析：利用 SQL 的分析函数](https://www.kdnuggets.com/2023/07/indatabase-analytics-leveraging-sql-analytic-functions.html)'
- en: '[Loss Functions: An Explainer](https://www.kdnuggets.com/2022/03/loss-functions-explainer.html)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[损失函数：解释](https://www.kdnuggets.com/2022/03/loss-functions-explainer.html)'
- en: '[How Activation Functions Work in Deep Learning](https://www.kdnuggets.com/2022/06/activation-functions-work-deep-learning.html)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[深度学习中的激活函数如何工作](https://www.kdnuggets.com/2022/06/activation-functions-work-deep-learning.html)'
- en: '[Understanding Functions for Data Science](https://www.kdnuggets.com/2022/06/understanding-functions-data-science.html)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学中的函数理解](https://www.kdnuggets.com/2022/06/understanding-functions-data-science.html)'
