- en: 24 SQL Questions You Might See on Your Next Interview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可能会在下次面试中遇到的 24 道 SQL 问题
- en: 原文：[https://www.kdnuggets.com/2022/06/24-sql-questions-might-see-next-interview.html](https://www.kdnuggets.com/2022/06/24-sql-questions-might-see-next-interview.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2022/06/24-sql-questions-might-see-next-interview.html](https://www.kdnuggets.com/2022/06/24-sql-questions-might-see-next-interview.html)
- en: '![24 SQL Questions You Might See on Your Next Interview](../Images/d697b944ff0af5e67e057054a1e211c1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![你可能会在下次面试中遇到的 24 道 SQL 问题](../Images/d697b944ff0af5e67e057054a1e211c1.png)'
- en: When talking about the [SQL interview questions](https://www.stratascratch.com/blog/sql-interview-questions-you-must-prepare-the-ultimate-guide/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    that come up most often at job interviews, I’m not talking about giving you the
    specific question. That would be an impossible task because there are thousands
    and thousands of them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到最常出现在工作面试中的 [SQL 面试题](https://www.stratascratch.com/blog/sql-interview-questions-you-must-prepare-the-ultimate-guide/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)时，我并不是说给你具体的问题。这将是一个不可能完成的任务，因为问题的数量成千上万。
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our Top 3 Course Recommendations
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的前三大课程推荐
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity)
    - 快速进入网络安全职业生涯。'
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics)
    - 提升你的数据分析技能'
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport)
    - 支持你的组织的 IT'
- en: '* * *'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Luckily, there are not so many SQL concepts tested by these questions. It doesn’t
    mean you should solve only the interview questions I’m about to show or know only
    the selected topics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这些问题测试的 SQL 概念并不多。这并不意味着你只需要解决我即将展示的面试题或仅了解选定的主题。
- en: But if you focus on the most common topics, the chance is you’ll be covering
    most of the concepts tested in the interviews. Of course, the questions can be
    of different difficulty, which will require more or less knowledge about a specific
    topic. Still, the concepts are often the same.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你专注于最常见的主题，你将有可能覆盖面试中测试的大部分概念。当然，问题的难度可能有所不同，这将需要对某一特定主题有更多或更少的了解。不过，这些概念通常是相同的。
- en: 'While these topics can be seen as magnificent (especially if you’re an SQL
    nerd!), I prefer to call them “The Unavoidable Seven”:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些主题可以被视为宏伟的（特别是如果你是 SQL 爱好者的话！），我更愿意称它们为“不可避免的七个”：
- en: Aggregating, Grouping, and Sorting
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇总、分组和排序
- en: Filtering
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤
- en: JOINs & Set Operators
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JOINs 和集合运算符
- en: Subqueries & CTEs
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子查询与 CTEs
- en: CASE Statement
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CASE 语句
- en: Window Functions
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 窗口函数
- en: Text & Date Manipulation
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本与日期操作
- en: These topics are usually tested in the coding SQL questions, but they can also
    appear in the non-coding types of questions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题通常在编码 SQL 问题中测试，但也可能出现在非编码类型的问题中。
- en: Coding SQL Interview Questions
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 SQL 面试题
- en: 'The coding questions are precisely what their name suggests: they test your
    ability to write a code using the SQL concepts.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编程题正如其名：它们测试你使用 SQL 概念编写代码的能力。
- en: 1\. Aggregating, Grouping, and Sorting
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 汇总、分组和排序
- en: '![Aggregating, Grouping, and Sorting](../Images/2f1c6477f63ecdb76e5cf30618c0a600.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![汇总、分组和排序](../Images/2f1c6477f63ecdb76e5cf30618c0a600.png)'
- en: Theory
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: 'The [SQL aggregate functions](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-aggregate-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    are the functions that perform calculations on multiple rows and return one value.
    The most commonly used aggregate functions are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL 聚合函数](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-aggregate-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)是对多行进行计算并返回一个值的函数。最常用的聚合函数包括：'
- en: '| **Aggregate Function** | **Description** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **聚合函数** | **描述** |'
- en: '| COUNT() | Counts the number of rows. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| COUNT() | 计算行数。 |'
- en: '| SUM() | Returns the sum of the rows. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| SUM() | 返回行的总和。 |'
- en: '| AVG() | Calculates the average of the rows’ values.  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| AVG() | 计算行值的平均值。 |'
- en: '| MIN() | Returns the lowest value. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| MIN() | 返回最小值。 |'
- en: '| MAX() | Returns the highest value.  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| MAX() | 返回最高值。 |'
- en: When used alone, these functions will return only one value. Admittedly, this
    isn’t very sophisticated.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用时，这些函数只会返回一个值。诚然，这并不十分复杂。
- en: The aggregate functions become more valuable for data scientists when used with
    the GROUP BY and ORDER BY clauses.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 GROUP BY 和 ORDER BY 子句一起使用时，汇总函数对数据科学家来说更有价值。
- en: GROUP BY is used for grouping data from one or more columns into groups based
    on the rows’ values. Every different value (or a combination of values for grouping
    by multiple columns) will form a separate data group. That way, it becomes possible
    to show additional info on data that is being aggregated.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GROUP BY 用于根据行的值将来自一个或多个列的数据分组。每个不同的值（或按多个列分组的值组合）将形成一个单独的数据组。这样就可以显示正在汇总的数据的附加信息。
- en: The ORDER BY serves for sorting the query’s output. Data can be sorted in ascending
    or descending order. Also, you can sort by one or more columns.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ORDER BY 用于对查询的输出进行排序。数据可以按升序或降序排序。此外，你可以按一个或多个列进行排序。
- en: Aggregate functions used with these two clauses become a stepping stone for
    creating reports, calculating metrics, and tidying data. They allow you to perform
    mathematical operations on data and show your finding in a clear and presentable
    way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与这两个子句一起使用时，汇总函数成为创建报告、计算指标和整理数据的垫脚石。它们允许你对数据进行数学运算，并以清晰和可展示的方式展示你的发现。
- en: SQL Questions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 问题
- en: 'SQL Interview Question #1: Finding Updated Records'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #1：查找更新的记录'
- en: '*“We have a table with employees and their salaries, however, some of the records
    are old and contain outdated salary information. Find the current salary of each
    employee, assuming that salaries increase each year. Output their id, first name,
    last name, department ID, and current salary. Order your list by employee ID in
    ascending order.”*'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“我们有一个包含员工及其工资的表格，但其中一些记录是旧的，包含过时的工资信息。找出每位员工的当前工资，假设工资每年都在增长。输出他们的 ID、名字、姓氏、部门
    ID 和当前工资。按员工 ID 升序排序你的列表。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10299-finding-updated-records?code_type=1](https://platform.stratascratch.com/coding/10299-finding-updated-records?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10299-finding-updated-records?code_type=1](https://platform.stratascratch.com/coding/10299-finding-updated-records?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: '**Data**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: 'This question gives you one table: ms_employee_salary'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题给你一个表：ms_employee_salary
- en: '| id | int |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| id | int |'
- en: '| first_name | varchar |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| first_name | varchar |'
- en: '| last_name | varchar |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| last_name | varchar |'
- en: '| salary | varchar |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| salary | varchar |'
- en: '| department_id | int |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| department_id | int |'
- en: The sample of the data from the table is given below.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下方给出了表格的数据样本。
- en: '![data from the table](../Images/58dd583b7dcfe9b7fc0c404eac1e2c27.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![来自表的数据](../Images/58dd583b7dcfe9b7fc0c404eac1e2c27.png)'
- en: '**Solution Approach**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案方法**'
- en: If the salary is increasing every year, then the latest salary is also the highest
    salary. To fetch it, use the MAX() aggregate function. Group the data by the employee
    and department. You should also show the output sorted by the employee ID in ascending
    order; use the ORDER BY clause for that.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工资每年都在增长，那么最新的工资也是最高工资。要获取它，请使用 MAX() 汇总函数。按员工和部门分组数据。你还应按员工 ID 以升序排序输出；为此使用
    ORDER BY 子句。
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Output**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![Finding Updated Records](../Images/c94879daa40b49a7477e560d63822d16.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![查找更新的记录](../Images/c94879daa40b49a7477e560d63822d16.png)'
- en: 'SQL Interview Question #2: Order All Countries by the Year They First Participated
    in the Olympics'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #2：按国家首次参加奥运会的年份排序'
- en: '*“Find the average distance traveled in each hour.*'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出每小时的平均行驶距离。”*'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the hour along with the corresponding average traveled distance.*'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*输出小时及相应的平均行驶距离。*'
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sort records by the hour in ascending order.”*'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*按小时升序排列记录。*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10006-find-the-average-distance-traveled-in-each-hour?code_type=1](https://platform.stratascratch.com/coding/10006-find-the-average-distance-traveled-in-each-hour?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10006-find-the-average-distance-traveled-in-each-hour?code_type=1](https://platform.stratascratch.com/coding/10006-find-the-average-distance-traveled-in-each-hour?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: To find the average distance, use the AVG() function, then group and order the
    output by the column hour.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找平均距离，请使用 AVG() 函数，然后按小时列对输出进行分组和排序。
- en: If you write the correct solution, this is what you’ll get.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写出正确的解决方案，你将会得到这个结果。
- en: '![Order All Countries by the Year They First Participated in the Olympics correct
    solution ](../Images/955a3288b7becc8e344aeac00c348f5f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![按各国首次参加奥运会的年份排序的正确解决方案](../Images/955a3288b7becc8e344aeac00c348f5f.png)'
- en: 'SQL Interview Question #3: Order All Countries by the Year They First Participated
    in the Olympics'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试问题 #3：按各国首次参加奥运会的年份排序'
- en: '*“Order all countries by the year they first participated in the Olympics.*'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“按各国首次参加奥运会的年份排序。”*'
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the National Olympics Committee (NOC) name along with the desired year.*'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*输出国家奥林匹克委员会（NOC）名称以及所需年份。*'
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sort records by the year and the NOC in ascending order.”*'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*按年份和 NOC 升序排序记录。*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10184-order-all-countries-by-the-year-they-first-participated-in-the-olympics?code_type=1](https://platform.stratascratch.com/coding/10184-order-all-countries-by-the-year-they-first-participated-in-the-olympics?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10184-order-all-countries-by-the-year-they-first-participated-in-the-olympics?code_type=1](https://platform.stratascratch.com/coding/10184-order-all-countries-by-the-year-they-first-participated-in-the-olympics?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: The code needs to group data by the column noc and uses the MIN() aggregate
    function for finding the first year of participation. To sort the output adequately,
    use the ORDER BY.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要按列 noc 对数据进行分组，并使用 MIN() 聚合函数找到首次参与的年份。为了适当地排序输出，使用 ORDER BY。
- en: If you get this result, then you did everything right.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到这个结果，那么你做对了一切。
- en: '![Order All Countries by the Year They First Participated in the Olympics](../Images/a7050f00aedfe975d8806178beea63c3.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![按各国首次参加奥运会的年份排序](../Images/a7050f00aedfe975d8806178beea63c3.png)'
- en: 2\. Filtering
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 筛选
- en: '![Filtering](../Images/3285180204dc5403a0f96bdf56f452fe.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![筛选](../Images/3285180204dc5403a0f96bdf56f452fe.png)'
- en: Theory
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: If data filtering is defined as selecting a subset of data, then there are many
    ways of data filtering. Even the ones people usually don’t see as such, for example,
    the SELECT statement and JOINs. But they are; they select only part of the data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将数据筛选定义为选择数据的一个子集，那么数据筛选有许多种方式。即使是那些人们通常不会认为是筛选的方式，例如 SELECT 语句和 JOINs，但它们也是筛选的一部分；它们仅选择数据的一部分。
- en: 'When thinking about filtering data, usually two keywords come to mind (or three
    when you’re using PostgreSQL:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑数据筛选时，通常会想到两个关键字（或者在使用 PostgreSQL 时是三个）：
- en: WHERE
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WHERE
- en: HAVING
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HAVING
- en: (LIMIT)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (LIMIT)
- en: The WHERE clause’s purpose is to filter data before it is aggregated. The syntax
    reflects that in a way that it must be written before the GROUP BY clause.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE 子句的目的是在数据汇总之前进行筛选。语法上，这意味着它必须在 GROUP BY 子句之前书写。
- en: When filtering data using the WHERE clause, there are many operators to be used.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 WHERE 子句进行数据筛选时，有许多运算符可以使用。
- en: '| **Operator** | **Description** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| = | Is equal |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| = | 等于 |'
- en: '| < | Is less than |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| > | Is greater than |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| <= | Is less than or equal |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: '| >=  | Is greater than or equal |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <> | Does not equal |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| <> | 不等于 |'
- en: '| BETWEEN  | Between the specified range |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| BETWEEN | 在指定范围之间 |'
- en: '| LIKE | Looking for a pattern |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| LIKE | 寻找模式 |'
- en: '| IN | Equals the values listed in the parentheses |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| IN | 等于括号中列出的值 |'
- en: The HAVING clause does the same thing as the WHERE clause, except it filters
    data after the aggregation. Naturally, it can be used only after the GROUP BY
    clause in the SQL queries.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: HAVING 子句与 WHERE 子句做的事情相同，只是它在聚合之后筛选数据。自然地，它只能在 SQL 查询中的 GROUP BY 子句之后使用。
- en: All the operators in the WHERE clause are also allowed in the HAVING clause.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE 子句中的所有运算符在 HAVING 子句中也允许使用。
- en: Both clauses allow filtering on one or multiple conditions by using the AND/OR
    logical operators.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 两个子句都允许通过使用 AND/OR 逻辑运算符在一个或多个条件上进行筛选。
- en: Using these two clauses adds another dimension to your calculations. Basic use
    makes it possible to show only the data you’re interested in and not the bulk
    of the data. This means not only do you get the choose the columns you want but
    also the rows you want, based on their values. Use it with the aggregate function,
    and you get to perform calculations on even more detailed subsets of data by filtering
    the input for the aggregate functions and, if you wish, their output, too. This
    increases the complexity of the calculations at your disposal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个子句为你的计算增加了另一个维度。基本用法使你能够只显示你感兴趣的数据，而不是大部分数据。这意味着你不仅可以选择你想要的列，还可以选择你想要的行，基于它们的值。与聚合函数一起使用，你可以通过过滤输入数据，甚至是其输出，来对更详细的数据子集进行计算。这增加了你计算的复杂性。
- en: Here are the examples of how [WHERE](https://towardsdatascience.com/data-science-lesson-3-filtering-data-using-sql-45d90986487f)
    and [HAVING](https://www.sqlservertutorial.net/sql-server-basics/sql-server-having/)
    work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 [WHERE](https://towardsdatascience.com/data-science-lesson-3-filtering-data-using-sql-45d90986487f)
    和 [HAVING](https://www.sqlservertutorial.net/sql-server-basics/sql-server-having/)
    工作的示例。
- en: '[The LIMIT clause](https://www.geeksforgeeks.org/sql-limit-clause/#:~:text=The%20LIMIT%20clause%20is%20used,be%20a%20non-negative%20integer.)
    simply specifies the number of rows you wish to see as output. The integer value
    in the clause equals the number of rows shown as a result. This is especially
    useful when you want to rank data, e.g., show the top N sales, employees, salaries,
    etc.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[LIMIT 子句](https://www.geeksforgeeks.org/sql-limit-clause/#:~:text=The%20LIMIT%20clause%20is%20used,be%20a%20non-negative%20integer.)
    简单地指定了你希望看到的输出行数。子句中的整数值等于作为结果显示的行数。这在你想要对数据进行排名时特别有用，例如，显示前 N 名销售、员工、薪资等。'
- en: SQL Questions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 问题
- en: 'SQL Interview Question #4: Find the Year That Uber Acquired More Than 2000
    Customers Through Celebrities'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #4：找出 Uber 通过名人获得超过 2000 名客户的年份'
- en: '*“Find the year that Uber acquired more than 2000 customers through advertising
    using celebrities.”*'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出 Uber 通过名人广告获得超过 2000 名客户的年份。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10000-find-the-year-that-uber-acquired-more-than-2000-customers-through-celebrities?code_type=1](https://platform.stratascratch.com/coding/10000-find-the-year-that-uber-acquired-more-than-2000-customers-through-celebrities?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10000-find-the-year-that-uber-acquired-more-than-2000-customers-through-celebrities?code_type=1](https://platform.stratascratch.com/coding/10000-find-the-year-that-uber-acquired-more-than-2000-customers-through-celebrities?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: '**Data**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: The table uber_advertising has four columns.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 uber_advertising 有四列。
- en: '| year | int |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| year | int |'
- en: '| advertising_channel | varchar |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| advertising_channel | varchar |'
- en: '| money_spent | int |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| money_spent | int |'
- en: '| customers_acquired | int |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| customers_acquired | int |'
- en: Here’s the table preview.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是表格预览。
- en: '![data preview](../Images/48515f96c36832410d25c9e853351712.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![数据预览](../Images/48515f96c36832410d25c9e853351712.png)'
- en: '**Solution Approach**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案方法**'
- en: The solution is a simple SELECT statement with one column. However, you don’t
    need all the years. The question asks you to output only those where the advertising
    channel was through celebrities, and there were more than 2,000 customers acquired.
    To do that, put these two conditions into the WHERE clause.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是一个简单的 SELECT 语句，包含一个列。然而，你不需要所有的年份。问题要求你只输出那些广告渠道是通过名人，并且获得了超过 2000 名客户的年份。为此，将这两个条件放入
    WHERE 子句中。
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Output**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![Find the Year That Uber Acquired More Than 2000 Customers Through Celebrities](../Images/ad13f186bafd3351f13553f33199bebc.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![找出 Uber 通过名人获得超过 2000 名客户的年份](../Images/ad13f186bafd3351f13553f33199bebc.png)'
- en: 'Run the code, and it will output only one year that satisfies the criteria:
    2018.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，它将只输出一个满足条件的年份：2018。
- en: 'SQL Interview Question #5: Find All Businesses Whose Lowest and Highest Inspection
    Scores Are Different'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #5：找出所有最低和最高检查评分不同的企业'
- en: '*“Find all businesses whose lowest and highest inspection scores are different.*'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出所有最低和最高检查评分不同的企业。”*'
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the corresponding business name and the lowest and highest scores of
    each business.*'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*输出每个企业的对应企业名称和最低及最高评分。*'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Order the result based on the business name in ascending order.”*'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*按企业名称升序排列结果。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9731-find-all-businesses-whose-lowest-and-highest-inspection-scores-are-different?code_type=1](https://platform.stratascratch.com/coding/9731-find-all-businesses-whose-lowest-and-highest-inspection-scores-are-different?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/9731-find-all-businesses-whose-lowest-and-highest-inspection-scores-are-different?code_type=1](https://platform.stratascratch.com/coding/9731-find-all-businesses-whose-lowest-and-highest-inspection-scores-are-different?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: To answer the question, use the MIN() and MAX() functions to find the highest
    and lowest inspection scores and group the data by business. Then use the HAVING
    clause to show only businesses whose highest and lowest scores are not equal.
    Finally, sort the output by the business name alphabetically.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，使用MIN()和MAX()函数来找出最高和最低的检查分数，并按企业分组数据。然后使用HAVING子句仅显示最高分数和最低分数不相等的企业。最后，按企业名称字母顺序对结果进行排序。
- en: Your output should be this one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该是这样的。
- en: '![Find All Businesses Whose Lowest and Highest Inspection Scores Are Different](../Images/ca62f2fdc9c7ada86155cc20731538cc.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![查找所有最低和最高检查分数不同的企业](../Images/ca62f2fdc9c7ada86155cc20731538cc.png)'
- en: 'SQL Interview Question #6: Find the Top 3 Jobs With the Highest Overtime Pay
    Rate'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL面试问题#6：找到最高加班工资率的前三份工作
- en: “Find the top 3 jobs with the highest overtime pay rate.
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “找到加班工资率最高的前三份工作。
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Output the job title of selected records.
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出所选记录的职位名称。
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sort records based on the overtime pay in descending order.”
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 按加班工资降序排列记录。”
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9988-find-the-top-3-jobs-with-the-highest-overtime-pay-rate?code_type=1](https://platform.stratascratch.com/coding/9988-find-the-top-3-jobs-with-the-highest-overtime-pay-rate?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/9988-find-the-top-3-jobs-with-the-highest-overtime-pay-rate?code_type=1](https://platform.stratascratch.com/coding/9988-find-the-top-3-jobs-with-the-highest-overtime-pay-rate?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: 'This question asks you to use both WHERE and LIMIT clause. Use WHERE to find
    the job titles whose overtime pay isn’t NULL and isn’t 0\. Order the data from
    the highest to the lowest overtime pay. Then, simply limit the output to the first
    three rows, and there you have it: the top 3 jobs with the highest overtime pay
    rate.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题要求你同时使用WHERE和LIMIT子句。使用WHERE来查找加班工资不是NULL且不为0的职位。按加班工资从高到低排序数据。然后，只需将输出限制为前三行，这样就得到了：加班工资率最高的前三份工作。
- en: As the output shows, there are only three such jobs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中可以看出，只有三份这样的工作。
- en: '![Find the Top 3 Jobs With the Highest Overtime Pay Rate](../Images/109c14f76bb3f0c0b725e1c884eaa8c3.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![找到加班工资率最高的前三份工作](../Images/109c14f76bb3f0c0b725e1c884eaa8c3.png)'
- en: 3\. JOINs & Set Operators
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. JOINs & 集合运算符
- en: '![JOINs & Set Operators](../Images/aa499db5adf469793d17ff1762652136.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![JOINs & 集合运算符](../Images/aa499db5adf469793d17ff1762652136.png)'
- en: Theory
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: So far, you’ve been condemned to use only one table. Unfortunately, not one
    respectable database is comprised of only one table. To fully use the available
    data, you need to know how to combine data from two or more tables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你被限制只使用一个表。不幸的是，没有一个值得尊敬的数据库只由一个表组成。为了充分利用可用数据，你需要知道如何结合两个或更多表的数据。
- en: 'JOINs are the SQL feature you’re looking for: it makes it possible to join
    tables on the common column.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: JOIN是你寻找的SQL功能：它使得在公共列上连接表成为可能。
- en: There are five distinct JOIN types in SQL.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: SQL中有五种不同的JOIN类型。
- en: '| **JOIN Type** | **Description** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **JOIN类型** | **描述** |'
- en: '| (INNER) JOIN | Returns only the matching rows from both tables. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| (INNER) JOIN | 仅返回两个表中的匹配行。 |'
- en: '| LEFT (OUTER) JOIN | Returns all the data from the left table and only the
    matching rows from the right.  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| LEFT (OUTER) JOIN | 返回左表中的所有数据和右表中的匹配行。 |'
- en: '| RIGHT (OUTER) JOIN | Returns all the data from the right table and only the
    matching rows from the left.  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| RIGHT (OUTER) JOIN | 返回右表中的所有数据和左表中的匹配行。 |'
- en: '| FULL OUTER JOIN | Returns all the rows from both tables.  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| FULL OUTER JOIN | 返回两个表中的所有行。 |'
- en: '| CROSS JOIN | Combines all the rows from one table with every from the second
    table.  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| CROSS JOIN | 将一个表中的所有行与第二个表中的每一行组合。 |'
- en: When I mention the matching rows, I mean the rows or values that are the same
    in both tables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我提到匹配行时，我指的是两个表中相同的行或值。
- en: '[The first four joins](https://learnsql.com/blog/sql-joins-types-explained/)
    are used most often, but [CROSS JOIN](https://www.sqlshack.com/sql-cross-join-with-examples/)
    can also be used sometimes.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[前四种连接](https://learnsql.com/blog/sql-joins-types-explained/) 最常使用，但 [CROSS
    JOIN](https://www.sqlshack.com/sql-cross-join-with-examples/) 有时也可以使用。'
- en: 'One additional way of joining tables is a self-join. It isn’t a distinct type
    of join: any JOIN type can be used for self-joining, which simply means that you
    join the table with itself.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种连接表格的方法是自连接。这不是一种独特的连接类型：任何JOIN类型都可以用于自连接，这意味着你将表格与自身连接。
- en: '[The set operators](https://towardsdatascience.com/how-to-use-set-operations-in-sql-53d57c4f7b77)
    are used to combine the output of two or more queries.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[集合运算符](https://towardsdatascience.com/how-to-use-set-operations-in-sql-53d57c4f7b77)
    用于合并两个或多个查询的输出。'
- en: '| **Set Operator** | **Description** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **集合运算符** | **描述** |'
- en: '| UNION | Combines the unique rows resulting from the queries.  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| UNION | 合并查询结果中的唯一行。 |'
- en: '| UNION ALL | Combines all the rows resulting from the queries, including the
    duplicates. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| UNION ALL | 合并查询结果中的所有行，包括重复的行。 |'
- en: '| INTERSECT | Returns only the rows that appear in both queries’ output. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| INTERSECT | 仅返回两个查询输出中都出现的行。 |'
- en: '| EXCEPT | Returns unique rows from one query and only those that appear in
    the second query’s output.   |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| EXCEPT | 返回一个查询中的唯一行，以及仅出现在第二个查询输出中的行。 |'
- en: SQL Questions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 问题
- en: 'SQL Interview Question #7: Expensive Projects'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #7：昂贵的项目'
- en: '*“Given a list of projects and employees mapped to each project, calculate
    by the amount of project budget allocated to each employee. The output should
    include the project title and the project budget per employee rounded to the closest
    integer. Order your list by projects with the highest budget per employee first.”*'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“给定一个列出项目及每个项目关联的员工的列表，根据每位员工分配的项目预算进行计算。输出应包括项目标题和每位员工的项目预算（四舍五入到最接近的整数）。按每位员工预算最高的项目排序。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1](https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1](https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: '**Data **'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: The question gives you two tables.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 题目给出了两个表。
- en: 'Table: ms_projects'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表格：ms_projects
- en: '| id | int |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| id | int |'
- en: '| title | varchar |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| title | varchar |'
- en: '| budget | int |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| budget | int |'
- en: Here’s the table preview.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是表格预览。
- en: '![the table preview](../Images/57c59a16f75089de3f6e2607accf2aec.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![表格预览](../Images/57c59a16f75089de3f6e2607accf2aec.png)'
- en: 'Table: ms_emp_projects'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表格：ms_emp_projects
- en: '| emp_id | int |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| emp_id | int |'
- en: '| project_id | int |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| project_id | int |'
- en: The data example is given below.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 数据示例如下。
- en: '![Expensive Projects](../Images/a7db7674b91845e896d69dcb3e4112d9.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![昂贵的项目](../Images/a7db7674b91845e896d69dcb3e4112d9.png)'
- en: '**Solution Approach**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案方法**'
- en: 'The first thing to do is to calculate the project budget by the employee. This
    looks more complicated than it is: simply divide the column budget with the number
    of employees, which you get using the COUNT() function. Then, cast the result
    to a float data type to get the decimal places. This calculation is done inside
    the ROUND() functions used to round the numbers. In this case, the result of division
    is cast to the numeric data type and rounded with no decimal places.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要按员工计算项目预算。这看起来比实际更复杂：只需将列预算除以员工数量，员工数量使用COUNT()函数获取。然后，将结果转换为浮点数据类型以获得小数位数。这个计算是在ROUND()函数内完成的，用于四舍五入数字。在这种情况下，除法结果被转换为数值数据类型，并四舍五入为没有小数位数。
- en: The SELECT statement uses the columns from both tables. This is possible because
    the tables are joined using the INNER JOIN in the FROM clause. They are joined
    where the column id equals the column project_id.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT语句使用了两个表中的列。这是可能的，因为表在FROM子句中使用INNER JOIN连接。它们在列id等于列project_id的地方连接。
- en: In the end, the result is grouped by the project and its budget, while the output
    is sorted by the ratio in descending order.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果按项目和其预算分组，同时输出按比例降序排序。
- en: '[PRE2]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Output**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![project budget](../Images/7b77de8a426bb8f34b42acead7efd058.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![项目预算](../Images/7b77de8a426bb8f34b42acead7efd058.png)'
- en: The code output should look like this, shown partially below.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 代码输出应如下所示，部分显示如下。
- en: 'SQL Interview Question #8: Find How Many Logins Spanish Speakers Made by Country'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #8：按国家找出讲西班牙语的人登录次数'
- en: '*“Find how many logins Spanish speakers made by the country.*'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出西班牙语用户按国家的登录次数。”*'
- en: ''
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the country along with the corresponding number of logins.*'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*输出国家及其相应的登录次数。*'
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Order records by the number of logins in descending order.”*'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*按登录次数降序排列记录。*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9889-find-how-many-logins-spanish-speakers-made-by-country?code_type=1](https://platform.stratascratch.com/coding/9889-find-how-many-logins-spanish-speakers-made-by-country?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '问题链接: [https://platform.stratascratch.com/coding/9889-find-how-many-logins-spanish-speakers-made-by-country?code_type=1](https://platform.stratascratch.com/coding/9889-find-how-many-logins-spanish-speakers-made-by-country?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
- en: In the solution, use the COUNT() function to calculate the number of logins.
    Since the required data is found in two tables, joining them would be necessary.
    Use the INNER JOIN for that purpose. Join the tables on the column user_id and
    where the event is ‘login’, while the user’s language is ‘spanish’. Group data
    by the location and sort it from the highest to the lowest count of logins.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，使用COUNT()函数计算登录次数。由于所需数据在两个表中，因此需要将它们联接。为此使用INNER JOIN。根据列user_id和事件为‘login’，而用户语言为‘spanish’来联接表格。按位置对数据进行分组，并按登录次数从高到低排序。
- en: The correct code will return three countries with the following number of logins.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的代码将返回三个国家的登录次数如下。
- en: '![number of logins](../Images/23d5763ce25ffe05af70cdf45ffb9224.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![登录次数](../Images/23d5763ce25ffe05af70cdf45ffb9224.png)'
- en: 'SQL Interview Question #9: Sum Of Numbers'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL面试问题 #9: 数字之和'
- en: '*“Find the sum of numbers whose index is less than 5 and the sum of numbers
    whose index is greater than 5\. Output each result on a separate row.”*'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出索引小于5的数字之和，以及索引大于5的数字之和。将每个结果单独输出一行。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10008-sum-of-numbers?code_type=1](https://platform.stratascratch.com/coding/10008-sum-of-numbers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '问题链接: [https://platform.stratascratch.com/coding/10008-sum-of-numbers?code_type=1](https://platform.stratascratch.com/coding/10008-sum-of-numbers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
- en: The code you’ll have to write consists of two SELECT statements. One will find
    the sum of numbers where the index is less than 5, the other will do the same
    for the indexes higher than 5.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编写的代码包括两个SELECT语句。一个将找出索引小于5的数字之和，另一个将对索引大于5的数字做同样的处理。
- en: All you have to do is put UNION ALL between these two statements to get the
    output.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你所要做的就是在这两个语句之间放置UNION ALL来获得输出。
- en: '![UNION ALL between these two statements to get the output](../Images/cbd4fdfda330043dfea6c2e862baecde.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![这两个语句之间的UNION ALL以获得输出](../Images/cbd4fdfda330043dfea6c2e862baecde.png)'
- en: 4\. Subqueries & CTEs
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 子查询与CTE
- en: '![Subqueries & CTEs](../Images/6245626ccd798ded44f79da553133be1.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![子查询与CTE](../Images/6245626ccd798ded44f79da553133be1.png)'
- en: Theory
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: The subqueries and CTEs add flexibility to your code. They are both used for
    more complex calculations with several steps, and their result is used in the
    main calculation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询和CTE为您的代码提供了灵活性。它们都用于更复杂的多步骤计算，其结果用于主要计算。
- en: There are specific keywords where you can use the [subqueries](https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有特定的关键字可以使用[子查询](https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php)。
- en: SELECT
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELECT
- en: FROM
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FROM
- en: WHERE
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WHERE
- en: HAVING
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HAVING
- en: INSERT
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT
- en: UPDATE
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UPDATE
- en: DELETE
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DELETE
- en: They are most often used for filtering data in the WHERE or HAVING clause but
    also as tables in the FROM clause when the query result acts as a table. Generally,
    they allow performing complex calculations within one query.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常用于WHERE或HAVING子句中的数据过滤，但也可作为FROM子句中的表格，当查询结果作为表格时。一般而言，它们允许在一个查询中执行复杂计算。
- en: As for the CTEs or Common Table Expressions, they have the same purpose. The
    difference is that they are closer to the human logic of calculation steps, so
    they make a tidier code. Usually, a CTE requires writing less code, and it’s more
    readable than the same calculation written in subqueries.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CTE（公共表表达式），它们的目的相同。不同之处在于，它们更接近人类逻辑的计算步骤，因此使代码更加整洁。通常，CTE所需的代码更少，且比相同计算的子查询更具可读性。
- en: 'There are two main parts of a CTE: a CTE and a query referencing the CTE.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: CTE的主要部分有两个：一个CTE和一个引用CTE的查询。
- en: 'The general CTE syntax is:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的CTE语法是：
- en: '[PRE3]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The CTE is called using the WITH keyword. After giving your CTE, a name comes
    AS and then a CTE definition in the parentheses. This definition is a SELECT statement
    that gives instructions to CTE.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: CTE 是通过 WITH 关键字调用的。在给出 CTE 名称后，接着是 AS，然后是括号中的 CTE 定义。这个定义是一个 SELECT 语句，用于给
    CTE 提供指令。
- en: The main query is again a SELECT statement, but this one references the CTE.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 主查询再次是一个 SELECT 语句，但这次引用了 CTE。
- en: 'There’s a reason they have a word table in the name: a CTE is a temporary result
    that can be accessed only when a CTE is run, so it is similar to a temporary table.
    That’s why you can use it in the FROM clause like any other table.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在名称中包含单词表的原因是：CTE 是一个临时结果，只能在运行 CTE 时访问，所以它类似于一个临时表。这就是为什么你可以像使用其他表一样在 FROM
    子句中使用它。
- en: SQL Questions
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 问题
- en: 'SQL Interview Question #10: Income By Title and Gender'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试问题 #10：按职称和性别计算收入'
- en: '*“Find the average total compensation based on employee titles and gender.
    Total compensation is calculated by adding both the salary and bonus of each employee.
    However, not every employee receives a bonus, so disregard employees without bonuses
    in your calculation. An employee can receive more than one bonus.*'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“根据员工职称和性别计算平均总薪酬。总薪酬通过将每个员工的薪水和奖金相加来计算。然而，并不是所有员工都会收到奖金，所以在计算时忽略没有奖金的员工。一个员工可以获得多个奖金。”*'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the employee title, gender (i.e., sex), along with the average total
    compensation.”*'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“输出员工职称、性别（即，sex），以及平均总薪酬。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10077-income-by-title-and-gender?code_type=1](https://platform.stratascratch.com/coding/10077-income-by-title-and-gender?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 链接到问题：[https://platform.stratascratch.com/coding/10077-income-by-title-and-gender?code_type=1](https://platform.stratascratch.com/coding/10077-income-by-title-and-gender?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: '**Data**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: The first table used in the question is sf_employee.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 问题中使用的第一个表是 sf_employee。
- en: 'Table: sf_employee'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表：sf_employee
- en: '| id | int |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| id | int |'
- en: '| first_name | varchar |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| first_name | varchar |'
- en: '| last_name | varchar |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| last_name | varchar |'
- en: '| age | int |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| age | int |'
- en: '| sex | varchar |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| sex | varchar |'
- en: '| employee_title | varchar |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| employee_title | varchar |'
- en: '| department | varchar |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| department | varchar |'
- en: '| salary | int |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| salary | int |'
- en: '| target | int |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| target | int |'
- en: '| email | varchar |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| email | varchar |'
- en: '| city | varchar |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| city | varchar |'
- en: '| address | varchar |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| address | varchar |'
- en: '| manager_id | int |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| manager_id | int |'
- en: The data in the table looks like this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的数据如下所示。
- en: '![data in the table](../Images/4bc11f82a38c125bbef2745baed6bcba.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![data in the table](../Images/4bc11f82a38c125bbef2745baed6bcba.png)'
- en: 'Table: sf_bonus'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表：sf_bonus
- en: '| worker_ref_id | int |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| worker_ref_id | int |'
- en: '| bonus | int |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| bonus | int |'
- en: '| bonus_date | datetime |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| bonus_date | datetime |'
- en: Here’s the data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据。
- en: '![worker bonus data](../Images/57290c659fab786ef724e6f342ede800.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![worker bonus data](../Images/57290c659fab786ef724e6f342ede800.png)'
- en: '**Solution Approach**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案方法**'
- en: The main SELECT statement in this code uses the table sf_employee and subquery
    data. The subquery calculates the total bonuses for the employee using the SUM()
    function; that’s why it also groups data by the worker ID. The subquery is joined
    with the table sf_employee like any other table. In this case, it’s using the
    INNER JOIN.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的主 SELECT 语句使用表 sf_employee 和子查询数据。子查询通过 SUM() 函数计算员工的总奖金；这就是它还按员工 ID 分组数据的原因。子查询像其他表一样与表
    sf_employee 连接。在这种情况下，使用的是 INNER JOIN。
- en: The main query will then use the subquery’s data to calculate the average total
    compensation, comprised of the salary and the total bonuses received.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 主查询将使用子查询的数据来计算平均总薪酬，包括薪水和获得的总奖金。
- en: In the end, the result is grouped by the employee and sex.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，结果按员工和性别分组。
- en: '[PRE4]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Output**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: The solution will return four rows as a result.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案将返回四行结果。
- en: '![average compensation](../Images/17ec6bd9173d4b0f065df7c2d8e042b8.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![average compensation](../Images/17ec6bd9173d4b0f065df7c2d8e042b8.png)'
- en: 'SQL Interview Question #11: Cheapest Neighborhoods With Real Beds And Internet'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试问题 #11：提供真实床和互联网的最便宜的邻里'
- en: '*“Find neighborhoods where you can sleep on a real bed in a villa with internet
    while paying the lowest price possible.”*'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“寻找在别墅中能睡在真正的床上且提供互联网的最低价格的邻里。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9636-cheapest-neighborhoods-with-real-beds-and-internet?code_type=1](https://platform.stratascratch.com/coding/9636-cheapest-neighborhoods-with-real-beds-and-internet?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '问题链接: [https://platform.stratascratch.com/coding/9636-cheapest-neighborhoods-with-real-beds-and-internet?code_type=1](https://platform.stratascratch.com/coding/9636-cheapest-neighborhoods-with-real-beds-and-internet?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
- en: For solving the question, use the subquery in the WHERE clause to get the price
    that satisfies certain criteria. The MIN() function will be used to find the lowest
    price for a real bed in a villa with the internet. Use the equals sign for two
    conditions and ILIKE with the wild card character (%) on both sides of the condition.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，使用 WHERE 子句中的子查询来获取满足特定标准的价格。使用 MIN() 函数找出具有互联网的别墅中真实床的最低价格。对两个条件使用等号，对条件两侧使用
    ILIKE 和通配符字符（%）。
- en: Then the same criteria (real bed, villa, the internet) will be used in the main
    query.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在主查询中使用相同的标准（真实床、别墅、互联网）。
- en: There’s one neighborhood that satisfies the criteria.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个邻里符合这些标准。
- en: '![neighborhood](../Images/55babde4ff6c7fb89b4b17f35c5037fc.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![邻里](../Images/55babde4ff6c7fb89b4b17f35c5037fc.png)'
- en: 'SQL Interview Question #12: Advertising Channel Effectiveness'
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #12: 广告渠道效果'
- en: '*“Find the average effectiveness of each advertising channel in the period
    from 2017 to 2018 (both included). The effectiveness is calculated as the ratio
    of total money spent to total customers acquired. *'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出 2017 年至 2018 年（含）每个广告渠道的平均效果。效果计算为总花费与获得的总客户数之比。”*'
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the advertising channel along with corresponding average effectiveness.
    Sort records by the average effectiveness in ascending order.”*'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“输出广告渠道及其对应的平均效果。按平均效果升序排序记录。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10012-advertising-channel-effectiveness?code_type=1](https://platform.stratascratch.com/coding/10012-advertising-channel-effectiveness?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '问题链接: [https://platform.stratascratch.com/coding/10012-advertising-channel-effectiveness?code_type=1](https://platform.stratascratch.com/coding/10012-advertising-channel-effectiveness?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
- en: Every CTE starts with the keyword WITH, after which follows the name of the
    CTE. This is then followed by AS, and in the parentheses, you define the body
    of CTE, i.e., the SELECT statement, which you’ll call on in the outer query.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 CTE 都以关键字 WITH 开始，之后是 CTE 的名称。接着是 AS，在括号中定义 CTE 的主体，即 SELECT 语句，你将在外部查询中调用它。
- en: You should use the CTE in this example to sum the money spent and the acquired
    customers. You do all that for the years 2017 and 2018 by setting this condition
    in the WHERE clause.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在这个示例中使用 CTE 来汇总花费和获得的客户数。你为 2017 年和 2018 年执行这些操作，通过在 WHERE 子句中设置这个条件。
- en: In the outer query, select the advertising channel and then divide the total
    money spent with the total number of customers acquired, which will give you the
    average effectiveness.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部查询中，选择广告渠道，然后将总花费除以获得的总客户数，这将给出平均效果。
- en: Sort the output by the effectiveness in ascending order.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 按效果升序排序输出结果。
- en: '![advertising output](../Images/468f635202c80dc37c8ce120de174b37.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![广告输出](../Images/468f635202c80dc37c8ce120de174b37.png)'
- en: 5\. CASE Statement
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. CASE 语句
- en: '![CASE Statement](../Images/91dd159a682c52f33c22786f84de8f7f.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![CASE 语句](../Images/91dd159a682c52f33c22786f84de8f7f.png)'
- en: Theory
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: This is a conditional statement, an SQL version of an IF-THEN-ELSE logic. It
    instructs the code to go through a set of conditions that define which result
    should be returned depending on whether the data satisfies the condition or not.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个条件语句，是 SQL 版本的 IF-THEN-ELSE 逻辑。它指示代码通过一组条件来确定应返回的结果，具体取决于数据是否满足条件。
- en: 'The CASE statement’s syntax is:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: CASE 语句的语法是：
- en: '[PRE5]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It also allows setting the multiple conditions, not only one.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许设置多个条件，而不仅仅是一个。
- en: '[The case statement](https://mode.com/sql-tutorial/sql-case/) is most commonly
    used when labeling data or with aggregate functions when the calculations are
    performed based on specific criteria.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[CASE 语句](https://mode.com/sql-tutorial/sql-case/) 最常用于标记数据或与聚合函数一起使用，当计算是基于特定标准进行时。'
- en: SQL Questions
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 问题
- en: 'SQL Interview Question #13: Bookings vs. Non-Bookings'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #13: 预订与非预订'
- en: '*“Display the average number of times a user performed a search which led to
    a successful booking and the average number of times a user performed a search
    but did not lead to a booking. The output should have a column named action with
    values ''does not book'' and ''books'' as well as a 2nd column named average_searches
    with the average number of searches per action. Consider that the booking did
    not happen if the booking date is null. Be aware that search is connected to the
    booking only if their check-in dates match.”*'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“显示用户进行搜索的平均次数，其中导致成功预订和未导致预订的平均次数。输出应具有名为 action 的列，值为 ''does not book''
    和 ''books''，以及名为 average_searches 的第二列，表示每个动作的平均搜索次数。考虑到如果预订日期为空则认为没有发生预订。请注意，搜索仅在入住日期匹配时与预订相关。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10124-bookings-vs-non-bookings?code_type=1](https://platform.stratascratch.com/coding/10124-bookings-vs-non-bookings?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10124-bookings-vs-non-bookings?code_type=1](https://platform.stratascratch.com/coding/10124-bookings-vs-non-bookings?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: '**Data**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: You’ll have to use both tables the question provides.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用问题提供的两个表。
- en: 'Table: airbnb_contacts'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 表：airbnb_contacts
- en: '| id_guest | varchar |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| id_guest | varchar |'
- en: '| id_host | varchar |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| id_host | varchar |'
- en: '| id_listing | varchar |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| id_listing | varchar |'
- en: '| ts_contact_at | datetime |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| ts_contact_at | datetime |'
- en: '| ts_reply_at | datetime |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| ts_reply_at | datetime |'
- en: '| ts_accepted_at | datetime |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| ts_accepted_at | datetime |'
- en: '| ts_booking_at | datetime |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| ts_booking_at | datetime |'
- en: '| ds_checkin | datetime |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| ds_checkin | datetime |'
- en: '| ds_checkout | datetime |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| ds_checkout | datetime |'
- en: '| n_guests | int |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| n_guests | int |'
- en: '| n_messages | int |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| n_messages | int |'
- en: Here’s the data preview.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据预览。
- en: '![airbnb_contacts](../Images/5d545f421fa528aae8f364e53f3f2a42.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![airbnb_contacts](../Images/5d545f421fa528aae8f364e53f3f2a42.png)'
- en: 'Table: airbnb_searches'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 表：airbnb_searches
- en: '| ds | datetime |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| ds | datetime |'
- en: '| id_user | varchar |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| id_user | varchar |'
- en: '| ds_checkin | datetime |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| ds_checkin | datetime |'
- en: '| ds_checkout | datetime |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| ds_checkout | datetime |'
- en: '| n_searches | int |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| n_searches | int |'
- en: '| n_nights | float |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| n_nights | float |'
- en: '| n_guests_min | int |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| n_guests_min | int |'
- en: '| n_guests_max | int |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| n_guests_max | int |'
- en: '| origin_country | varchar |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| origin_country | varchar |'
- en: '| filter_price_min | float |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| filter_price_min | float |'
- en: '| filter_price_max | float |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| filter_price_max | float |'
- en: '| filter_room_types | varchar |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| filter_room_types | varchar |'
- en: '| filter_neighborhoods | datetime |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| filter_neighborhoods | datetime |'
- en: The first few rows from the table are shown below.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的前几行如下所示。
- en: '![airbnb_searches](../Images/bc7dbc314a3d88d8cbc7550d325c7d5e.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![airbnb_searches](../Images/bc7dbc314a3d88d8cbc7550d325c7d5e.png)'
- en: '**Solution Approach**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案方法**'
- en: The solution uses the CASE statement in the SELECT statement to label data.
    When there is no-NULL value in the column ts_booking_at, it will get the label
    “books”. If it is NULL, it will become “does not book”. This CASE statement will
    show its results in the new column action.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在 SELECT 语句中使用 CASE 语句为数据标记。当列 ts_booking_at 中有非空值时，它将标记为“books”。如果为 NULL，则标记为“does
    not book”。这个 CASE 语句将其结果显示在新列 action 中。
- en: Also, there is an AVG() function in the SELECT statement for finding the average
    number of searches.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SELECT 语句中还有一个 AVG() 函数用于查找搜索的平均次数。
- en: Data is fetched from both tables using the LEFT JOIN. In the end, the output
    is grouped by the data label.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 数据从两个表中使用 LEFT JOIN 提取。最终，输出按数据标签分组。
- en: '[PRE6]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Output**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: The above query returns the required output.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询返回所需的输出。
- en: '![output](../Images/f9ee300607e00b134ab471984b057a34.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![output](../Images/f9ee300607e00b134ab471984b057a34.png)'
- en: 'SQL Interview Question #14: Churn Rate Of Lyft Drivers'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试问题 #14：Lyft 驾驶员的流失率'
- en: '*“Find the global churn rate of Lyft drivers across all years. Output the rate
    as a ratio.”*'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出所有年份 Lyft 驾驶员的全球流失率。将比率作为结果输出。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10016-churn-rate-of-lyft-drivers?code_type=1](https://platform.stratascratch.com/coding/10016-churn-rate-of-lyft-drivers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10016-churn-rate-of-lyft-drivers?code_type=1](https://platform.stratascratch.com/coding/10016-churn-rate-of-lyft-drivers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: This question asks you to use the CASE statement in the aggregate function;
    COUNT(), to be precise. Use it to count the drivers that left, which are those
    whose end date is not NULL. Divide the result by the total number of drivers,
    and cast this into the decimal numbers.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题要求你在聚合函数中使用CASE语句，具体来说是COUNT()。用它来计算离开的司机，那些结束日期不为NULL的。将结果除以总司机数量，并将其转换为小数。
- en: If you do everything right, you should get the churn rate.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，你应该得到流失率。
- en: '![global churn rate](../Images/db6e606670b2a402b7b6fba8aa175769.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![全球流失率](../Images/db6e606670b2a402b7b6fba8aa175769.png)'
- en: 'SQL Interview Question #15: Find the Number of Employees Who Received the Bonus
    and Who Didn’t'
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL面试问题 #15：找出获得奖金和未获得奖金的员工数量'
- en: '*“Find the number of employees who received the bonus and who didn''t.*'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出获得奖金和未获得奖金的员工数量。”*'
- en: ''
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output an indication of whether the bonus was received or not along with the
    corresponding number of employees.*'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*输出是否获得奖金的指示及相应的员工数量。*'
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*    ex: if the bonus was received: 1, if not: 0.”*'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*    例如：获得奖金为1，未获得为0。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10081-find-the-number-of-employees-who-received-the-bonus-and-who-didnt?code_type=1](https://platform.stratascratch.com/coding/10081-find-the-number-of-employees-who-received-the-bonus-and-who-didnt?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10081-find-the-number-of-employees-who-received-the-bonus-and-who-didnt?code_type=1](https://platform.stratascratch.com/coding/10081-find-the-number-of-employees-who-received-the-bonus-and-who-didnt?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: There’s a subquery in this solution. The subquery uses the CASE statement to
    determine the employees who did receive the bonus and who didn’t. It’s done based
    on the bonus date and whether the value is NULL or not. To do that, you will need
    to join both tables from the question using the LEFT JOIN.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案中有一个子查询。子查询使用CASE语句来确定获得奖金和未获得奖金的员工。依据奖金日期和是否值为NULL来完成。为此，你需要使用LEFT JOIN连接两个表。
- en: The main query will use this result to count the number of employees with and
    without the bonus.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 主要查询将使用此结果来统计获得和未获得奖金的员工数量。
- en: '![has bouns](../Images/37fc510f5fb718ce8b9ce2f8ef42a2f9.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![有奖金](../Images/37fc510f5fb718ce8b9ce2f8ef42a2f9.png)'
- en: 6\. Window Functions
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 窗口函数
- en: '![Window Functions](../Images/25a0a565eed279c056d4ffa562363be4.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![窗口函数](../Images/25a0a565eed279c056d4ffa562363be4.png)'
- en: Theory
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: The [SQL window functions](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-window-functions/)
    are similar to the aggregate functions. The difference is that the window functions
    aggregate data in a way that makes it possible to show both individual rows and
    aggregated values.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL窗口函数](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-window-functions/)
    类似于聚合函数。区别在于窗口函数以一种方式聚合数据，使得可以同时显示单独的行和聚合值。'
- en: 'Generally, there are three distinct types of window functions:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有三种不同类型的窗口函数：
- en: Aggregate Window Functions
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合窗口函数
- en: Ranking Window Functions
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排名窗口函数
- en: Value Window Functions
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值窗口函数
- en: '| **Aggregate Window Functions** | **Description** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **聚合窗口函数** | **描述** |'
- en: '| COUNT() | Counts the number of rows. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| COUNT() | 计算行数。 |'
- en: '| SUM() | Sums the values. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| SUM() | 求和。 |'
- en: '| AVG() | Returns the average value. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| AVG() | 返回平均值。 |'
- en: '| MIN() | Returns the minimum value. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| MIN() | 返回最小值。 |'
- en: '| MAX() | Returns the maximum value. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| MAX() | 返回最大值。 |'
- en: '| **Ranking Window Functions** | **Description** |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **排名窗口函数** | **描述** |'
- en: '| ROW_NUMBER() | Ranks rows sequentially without skipping the row number and
    gives the same rank to the rows with the same values. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| ROW_NUMBER() | 依次对行进行排名，不跳过行号，并对相同值的行赋予相同的排名。 |'
- en: '| RANK() | Used for ranking, with the same values given the same ranking and
    the next rank being skipped. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| RANK() | 用于排名，相同的值会得到相同的排名，下一个排名会被跳过。 |'
- en: '| DENSE_RANK() | Used for ranking, with the same values given the same ranking
    and the next rank not being skipped. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| DENSE_RANK() | 用于排名，相同的值会得到相同的排名，且下一个排名不会被跳过。 |'
- en: '| PERCENT_RANK() | Ranks the values in a percent value.  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| PERCENT_RANK() | 以百分比值对值进行排名。 |'
- en: '| NTILE() | Divides rows into a number of equally sized groups. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| NTILE() | 将行划分为若干个相等大小的组。 |'
- en: '| **Value Window Functions** | **Description** |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **值窗口函数** | **描述** |'
- en: '| LAG() | Allows accessing data from the defined number of preceding rows.
    |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| LAG() | 允许访问定义数量的前置行数据。 |'
- en: '| LEAD() | Allows accessing data from the defined number of the following rows.
    |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| LEAD() | 允许访问从定义的行数之后的数据。 |'
- en: '| FIRST_VALUE() | Returns the first value from the data. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| FIRST_VALUE() | 返回数据中的第一个值。 |'
- en: '| LAST_VALUE() | Returns the last value from the data. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| LAST_VALUE() | 返回数据中的最后一个值。 |'
- en: '| NTH_VALUE() | Returns the value from the defined (nth) row.  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| NTH_VALUE() | 返回定义的（第 n）行的值。 |'
- en: The window functions are called that for a reason. They do calculations over
    the rows that are related to the current row. The current row and all related
    rows are called a window frame.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数之所以叫做窗口函数，是有原因的。它们对与当前行相关的行进行计算。当前行和所有相关行称为窗口框架。
- en: There are five clauses important for using the window functions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用窗口函数时，有五个重要的子句。
- en: OVER
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OVER
- en: PARTITION BY
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PARTITION BY
- en: ORDER BY
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORDER BY
- en: ROWS
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROWS
- en: RANGE
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RANGE
- en: The OVER clause is mandatory, and its purpose is to call the window function.
    Without it, there are no window functions.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: OVER 子句是强制的，其目的是调用窗口函数。没有它，就没有窗口函数。
- en: The PARTITION BY is used for partitioning data. By specifying the column(s)
    in it, you’re instructing the window function on which subset of data the calculation
    should be performed. When the PARTITION BY is omitted, the window function takes
    the whole table as a data set.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: PARTITION BY 用于对数据进行分区。通过指定其中的列，你在指示窗口函数应在哪个数据子集上执行计算。当省略 PARTITION BY 时，窗口函数将整个表作为数据集。
- en: The ORDER BY clause is also an optional clause. It specifies the logical order
    within each data set. In other words, it’s not used for sorting the output but
    for setting the direction in which the window function will work. Data can be
    ordered in ascending or descending order.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ORDER BY 子句也是一个可选子句。它指定了每个数据集内的逻辑顺序。换句话说，它不是用来排序输出的，而是用来设置窗口函数将如何工作的方向。数据可以按升序或降序排列。
- en: Within the partition, you can additionally limit the rows that will be included
    in the window function’s calculation. This is called defining a window frame.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在分区内，你还可以进一步限制将包含在窗口函数计算中的行。这被称为定义窗口框架。
- en: The ROWS clause defines a fixed number of rows preceding and following the current
    one.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ROWS 子句定义了当前行之前和之后的固定行数。
- en: The RANGE does the same, except not based on the number of rows but their value
    compared to the current row.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: RANGE 做的是相同的事情，只不过不是基于行数，而是根据其与当前行的值进行比较。
- en: The window functions increase the analytical possibilities of SQL. By using
    them, you can show aggregated and non-aggregated data side by side, aggregate
    on multiple levels, rank data, and do a number of other operations that are not
    possible with only the aggregate functions.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数扩展了 SQL 的分析可能性。通过使用它们，你可以将聚合数据和非聚合数据并排显示，进行多级聚合，对数据进行排名，并进行其他仅用聚合函数无法完成的操作。
- en: SQL Questions
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 问题
- en: 'SQL Interview Question #16: Average Salaries'
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #16：平均工资'
- en: '*“Compare each employee''s salary with the average salary of the corresponding
    department.*'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“将每个员工的工资与相应部门的平均工资进行比较。”*'
- en: ''
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the department, first name, and salary of employees along with the
    average salary of that department.”*'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*输出部门、名字和员工的工资，并附上该部门的平均工资。*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9917-average-salaries?code_type=1](https://platform.stratascratch.com/coding/9917-average-salaries?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 链接到问题：[https://platform.stratascratch.com/coding/9917-average-salaries?code_type=1](https://platform.stratascratch.com/coding/9917-average-salaries?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: '**Data**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: There’s one table named employee.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 employee 的表。
- en: '| id | int |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| id | int |'
- en: '| first_name | varchar |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| first_name | varchar |'
- en: '| last_name | varchar |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| last_name | varchar |'
- en: '| age | int |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| age | int |'
- en: '| sex | varchar |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| sex | varchar |'
- en: '| employee_title | varchar |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| employee_title | varchar |'
- en: '| department | varchar |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| department | varchar |'
- en: '| salary | int |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| salary | int |'
- en: '| target | int |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| target | int |'
- en: '| bonus | int |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| bonus | int |'
- en: '| email | varchar |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| email | varchar |'
- en: '| city | varchar |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| city | varchar |'
- en: '| address | varchar |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| address | varchar |'
- en: '| manager_id | int |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| manager_id | int |'
- en: Here’s the employee data.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是员工数据。
- en: '![the employee data](../Images/4bc11f82a38c125bbef2745baed6bcba.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![员工数据](../Images/4bc11f82a38c125bbef2745baed6bcba.png)'
- en: '**Solution Approach**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案方法**'
- en: The query selects the department, employee’s first name, and their salary. The
    fourth column will calculate the AVG() salary. Since it’s a window function, it
    has to be called using the OVER() clause. By using department as data partition,
    the query will return the average salary by department instead of the overall
    salary.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 查询选择了部门、员工的名字和他们的薪资。第四列将计算AVG()薪资。由于这是一个窗口函数，它必须使用OVER()子句来调用。通过使用部门作为数据分区，查询将返回按部门划分的平均薪资，而不是整体薪资。
- en: '[PRE7]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Output**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: These are only the first five rows of the complete output.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是完整输出的前五行。
- en: '![output](../Images/fb5ea3a0cf80e687393049b3faf70103.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![输出](../Images/fb5ea3a0cf80e687393049b3faf70103.png)'
- en: 'SQL Interview Question #17: Ranking Most Active Guests'
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #17：排名最活跃的宾客'
- en: '*“Rank guests based on the number of messages they''ve exchanged with the hosts.
    Guests with the same number of messages as other guests should have the same rank.
    Do not skip rankings if the preceding rankings are identical.*'
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“根据宾客与主持人交换消息的数量对宾客进行排名。与其他宾客消息数量相同的宾客应具有相同的排名。如果前面的排名相同，请不要跳过排名。*'
- en: ''
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the rank, guest id, and the number of total messages they''ve sent.
    Order by the highest number of total messages first.”*'
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*输出排名、宾客ID和他们发送的总消息数。按总消息数从高到低排序。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10159-ranking-most-active-guests?code_type=1](https://platform.stratascratch.com/coding/10159-ranking-most-active-guests?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10159-ranking-most-active-guests?code_type=1](https://platform.stratascratch.com/coding/10159-ranking-most-active-guests?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: Here you need to use the ranking window function, namely the DENSE_RANK() function.
    There will be no data ,partitioning, but use the ORDER BY to rank the sum of the
    messages from the highest to the lowest. Additionally, select the guest ID and
    calculate the sum of messages outside the window function.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要使用排名窗口函数，即DENSE_RANK()函数。数据不会进行分区，但使用ORDER BY对消息总和进行排名，从高到低。此外，选择宾客ID，并在窗口函数之外计算消息总和。
- en: Group data by the guest ID and sort data from the highest to the lowest number
    of messages.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 按宾客ID分组数据，并按消息数量从高到低排序。
- en: Your output should look something like this.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应类似于此。
- en: '![guest rank](../Images/b9f01df96cbf23522eec59396c594c94.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![宾客排名](../Images/b9f01df96cbf23522eec59396c594c94.png)'
- en: 'SQL Interview Question #18: Cum Sum Energy Consumption'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #18：累计能耗'
- en: '*“Calculate the running total (i.e., cumulative sum) energy consumption of
    the Meta/Facebook data centers in all 3 continents by the date. Output the date,
    running total energy consumption, and running total percentage rounded to the
    nearest whole number.”*'
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“计算Meta/Facebook数据中心在所有三个大洲的累计能耗（即累计总和）按日期。输出日期、累计能耗以及四舍五入到最接近的整数的累计百分比。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10084-cum-sum-energy-consumption?code_type=1](https://platform.stratascratch.com/coding/10084-cum-sum-energy-consumption?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10084-cum-sum-energy-consumption?code_type=1](https://platform.stratascratch.com/coding/10084-cum-sum-energy-consumption?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: This is a hard question that covers most of the topics I talked about. First,
    you need to write a CTE. Use it to write three SELECT statements that select all
    data from each table and join the outputs using the UNION ALL.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个难题，涵盖了我讨论的大部分主题。首先，你需要编写一个CTE。使用它来编写三个SELECT语句，从每个表中选择所有数据，并使用UNION ALL将结果合并。
- en: The second CTE will use data from the first CTE to fetch the total energy consumption
    by date using the SUM() aggregate function.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个CTE将使用第一个CTE中的数据，通过SUM()聚合函数按日期获取总能耗。
- en: The outer query uses the data from the second CTE in the following way. The
    SUM() window function calculates the cumulative sum by ordering data from the
    oldest to the newest date.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 外部查询使用第二个CTE中的数据如下所示。SUM()窗口函数通过将数据按日期从最旧到最新排序来计算累计总和。
- en: Then this same window function is divided by the total energy consumption –
    which you can get by summing the energy consumption by date – and multiplying
    by 100 to get the percentage. Use the ROUND() function to show the result as rounded
    to the nearest whole number, i.e., there will be no decimal places.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这个相同的窗口函数除以总能量消耗——你可以通过按日期汇总能量消耗来获得——并乘以 100 得到百分比。使用 ROUND() 函数将结果四舍五入到最接近的整数，即没有小数位。
- en: There it is, the output that will get you points from the interviewer.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 就是它，能够让你从面试官那里获得分数的输出。
- en: '![cumulative energy](../Images/c5535bbe224fa0173b32bfcb6d3d0564.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![累计能量](../Images/c5535bbe224fa0173b32bfcb6d3d0564.png)'
- en: 7\. Text & Date Manipulation
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 文本和日期处理
- en: '![Text & Date Manipulation](../Images/cd714162e4e2c3e4ee09440ebc11f747.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![文本和日期处理](../Images/cd714162e4e2c3e4ee09440ebc11f747.png)'
- en: Theory
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: The data scientists often have to handle text and dates/time in the databases,
    not only numerical values. This usually means creating one string from several
    ones or using only the part of the date (like day, month, year) or a string.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家常常需要处理数据库中的文本和日期/时间，而不仅仅是数值。这通常意味着从多个字符串中创建一个字符串，或仅使用日期的某一部分（如日、月、年）或一个字符串。
- en: 'The most common [text manipulation functions](https://www.tutorialspoint.com/sql/sql-string-functions.htm)
    are:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的 [文本处理函数](https://www.tutorialspoint.com/sql/sql-string-functions.htm)包括：
- en: '| **Text Function** | **Description** |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| **文本函数** | **描述** |'
- en: '| &#124;&#124; or CONCAT() | Concatenates multiple string values into one. 
    |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; 或 CONCAT() | 将多个字符串值连接成一个。  |'
- en: '| CHAR_LENGTH() | Returns the of characters in a string. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| CHAR_LENGTH() | 返回字符串中的字符数。 |'
- en: '| LOWER() | Converts the string to all lowercase.  |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| LOWER() | 将字符串转换为全小写。  |'
- en: '| UPPER() | Converts the string to all uppercase. |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| UPPER() | 将字符串转换为全大写。 |'
- en: '| SUBSTRING() | Returns the part of the string.  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| SUBSTRING() | 返回字符串的部分。  |'
- en: '| TRIM() | Deletes space or any other character from the start and end of a
    string.  |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| TRIM() | 删除字符串开头和结尾的空格或其他字符。  |'
- en: '| LTRIM() | Deletes space or any other character from the start of a string. 
    |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| LTRIM() | 删除字符串开头的空格或其他字符。  |'
- en: '| RTRIM() | Deletes space or any other character from the end of a string. 
    |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| RTRIM() | 删除字符串结尾的空格或其他字符。  |'
- en: '| LEFT() | Returns the defined number of characters from the start of a string. 
    |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| LEFT() | 从字符串开头返回定义的字符数。  |'
- en: '| RIGHT() | Returns the defined number of characters from the end of a string.
    |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| RIGHT() | 从字符串结尾返回定义的字符数。 |'
- en: 'The two most often used [date/time functions](https://www.postgresql.org/docs/8.1/functions-datetime.html)
    are:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最常用的 [日期/时间函数](https://www.postgresql.org/docs/8.1/functions-datetime.html)是：
- en: '| **Date/Time Function** | **Description** |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| **日期/时间函数** | **描述** |'
- en: '| EXTRACT() | Returns the part of the date or time; SQL standard.  |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| EXTRACT() | 返回日期或时间的部分；SQL 标准。  |'
- en: '| DATE_PART() | Returns the part of the date or time; PostgreSQL specific. 
    |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| DATE_PART() | 返回日期或时间的部分；特定于 PostgreSQL。  |'
- en: Text & date/time functions come in handy for data scientists when they clean
    data. Of course, they can also perform calculations using the date/time functions,
    such as adding or subtracting time periods, and use it for data filtering, aggregation,
    etc.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 文本和日期/时间函数在数据科学家清理数据时非常实用。当然，他们也可以使用日期/时间函数进行计算，例如添加或减去时间段，并用于数据过滤、聚合等。
- en: SQL Questions
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 问题
- en: 'SQL Interview Question #19: Pending Claims'
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试问题 #19: 待处理的索赔'
- en: '*“Count how many claims submitted in December 2021 are still pending. A claim
    is pending when it has neither an acceptance nor rejection date.”*'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“统计 2021 年 12 月提交的索赔中仍在待处理的数量。待处理的索赔是指没有接受或拒绝日期的索赔。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/2083-pending-claims?code_type=1](https://platform.stratascratch.com/coding/2083-pending-claims?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/2083-pending-claims?code_type=1](https://platform.stratascratch.com/coding/2083-pending-claims?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: '**Data**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: The question gives you the table cvs_claims.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 问题给出了表 cvs_claims。
- en: '| claim_id | int |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| claim_id | int |'
- en: '| account_id | varchar |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| account_id | varchar |'
- en: '| date_submitted | datetime |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| date_submitted | datetime |'
- en: '| date_accepted | datetime |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| date_accepted | datetime |'
- en: '| date_rejected | datetime |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| date_rejected | datetime |'
- en: Make yourself familiar with the data.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 让自己熟悉数据。
- en: '![data](../Images/48b991d627a626c57d97ae1dc38c8ee0.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![数据](../Images/48b991d627a626c57d97ae1dc38c8ee0.png)'
- en: '**Solution Approach**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案方法**'
- en: The COUNT() function is here for getting the number of claims. You need to count
    only the claims satisfying the certain criteria. Two criteria are set up with
    the help of the EXTRACT() function. The first one is used for extracting the month
    from the claim submission date. The other EXTRACT() function will get the year
    from the same column. That way, you get claims submitted in December 2021.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: COUNT() 函数用于获取索赔数量。你需要计数仅满足特定条件的索赔。通过 EXTRACT() 函数设置了两个条件。第一个用于从索赔提交日期中提取月份。另一个
    EXTRACT() 函数将从同一列中获取年份。这样，你将获得 2021 年 12 月提交的索赔。
- en: The next two criteria in the WHERE clause will show only claims that are not
    yet accepted nor rejected, i.e., they are pending.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE 子句中的接下来的两个条件将仅显示尚未接受或拒绝的索赔，即它们处于待处理状态。
- en: '[PRE8]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Output**'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![ive pending claims submitted in December 2021](../Images/f3487fbb71e85f3d608ba5051c6bf559.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![2021年12月提交的待处理索赔](../Images/f3487fbb71e85f3d608ba5051c6bf559.png)'
- en: This solution shows there are five pending claims submitted in December 2021.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案显示了2021年12月提交的五个待处理索赔。
- en: 'SQL Interview Question #20: Rush Hour Calls'
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #20：高峰时段电话'
- en: '*“Redfin helps clients to find agents. Each client will have a unique request_id,
    and each request_id has several calls. For each request_id, the first call is
    an “initial call”, and all the following calls are “update calls”.  How many customers
    have called 3 or more times between 3 PM and 6 PM (initial and update calls combined)?”*'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“Redfin 帮助客户找到代理。每个客户将有一个唯一的 request_id，每个 request_id 有多个电话。对于每个 request_id，第一次电话是“初始电话”，所有后续电话都是“更新电话”。有多少客户在下午
    3 点到 6 点之间（初始和更新电话合并）拨打了 3 次或更多次？”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/2023-rush-hour-calls?code_type=1](https://platform.stratascratch.com/coding/2023-rush-hour-calls?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/2023-rush-hour-calls?code_type=1](https://platform.stratascratch.com/coding/2023-rush-hour-calls?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: The solution uses the DATE_PART() function instead of EXTRACT(). It does that
    in the subquery in the FROM clause. The subquery shows the clients, but not all
    of them. First, data is filtered and cast to timestamp using the WHERE clause
    and D,ATE_PART() so the subquery will return only the clients making calls between
    15 and 17 hours.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案使用了 DATE_PART() 函数，而不是 EXTRACT()。它在 FROM 子句中的子查询中进行。子查询显示客户，但不是所有客户。首先，数据通过
    WHERE 子句和 DATE_PART() 进行过滤并转换为时间戳，以便子查询仅返回在 15 点到 17 点之间拨打电话的客户。
- en: Data is additionally filtered after grouping using the HAVING clause. The condition
    shows only customers with three or more calls in the above time period.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在分组后通过 HAVING 子句进行额外过滤。条件显示了在上述时间段内拨打三次或更多次的客户。
- en: This result will be used in the main query only for counting the number of customers.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果仅用于主查询中计算客户数量。
- en: Only one customer called three or more times between 15:00 and 17:00.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 仅有一名客户在 15:00 到 17:00 之间拨打了三次或更多次。
- en: '![one customer called three or more times between 15:00 and 17:00](../Images/405366a85904004e2a0111d6e31aaf9e.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![一个客户在 15:00 到 17:00 之间拨打了三次或更多次](../Images/405366a85904004e2a0111d6e31aaf9e.png)'
- en: 'SQL Interview Question #21: Rules To Determine Grades'
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SQL 面试题 #21：确定等级的规则'
- en: '*“Find the rules used to determine each grade. Show the rule in a separate
    column in the format of ''Score > X AND Score <= Y => Grade = A'' where X and
    Y are the lower and upper bounds for a grade. Output the corresponding grade and
    its highest and lowest scores along with the rule. Order the result based on the
    grade in ascending order.”*'
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“找出用于确定每个等级的规则。以“Score > X AND Score <= Y => Grade = A”的格式在单独的列中显示规则，其中 X
    和 Y 是等级的下限和上限。输出相应的等级及其最高和最低分数以及规则。根据等级按升序排列结果。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9700-rules-to-determine-grades?code_type=1](https://platform.stratascratch.com/coding/9700-rules-to-determine-grades?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/9700-rules-to-determine-grades?code_type=1](https://platform.stratascratch.com/coding/9700-rules-to-determine-grades?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: 'The SELECT statement returns the minimum and maximum score per grade. The last
    column is used for labeling the rules with the concatenate function. Use both
    MIN() and MAX() functions to get the following rules:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT 语句返回每个等级的最低和最高分数。最后一列用于通过连接函数标记规则。使用 MIN() 和 MAX() 函数来获取以下规则：
- en: 'Grade A: score > 89 and <= 100'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 级：分数 > 89 且 <= 100
- en: 'Grade B: score > 79 and <= 88'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B 级：分数 > 79 且 <= 88
- en: 'Grade C: score > 69 and <= 79'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C等级：得分 > 69 且 <= 79
- en: Of course, the labels have to be formatted as is required.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，标签必须按要求格式化。
- en: The output is grouped by and ordered by grade.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 输出按等级分组和排序。
- en: Here are the rules.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是规则。
- en: '![grouped by and ordered by grade](../Images/a3c5e11f1c149741d71770f7bd6fd084.png)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![按等级分组和排序](../Images/a3c5e11f1c149741d71770f7bd6fd084.png)'
- en: SQL Theoretical Interview Questions
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL理论面试问题
- en: These questions test the SQL knowledge, too, the same as the coding questions.
    The difference is they don’t require writing a code, but you have to explain SQL
    concepts or the difference between them.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题也测试SQL知识，与编码问题类似。不同之处在于它们不需要编写代码，但你必须解释SQL概念或它们之间的区别。
- en: Here are some examples of such questions, all testing the topics I mentioned
    in the coding questions section.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些这样的例子，所有问题都测试了我在编码问题部分提到的主题。
- en: 'SQL Interview Question #22: WHERE and HAVING'
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL面试问题#22：WHERE和HAVING
- en: '*“What is the main difference between a WHERE clause and a HAVING clause in
    SQL?”*'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“WHERE子句和HAVING子句在SQL中的主要区别是什么？”*'
- en: 'Link to the question: [https://platform.stratascratch.com/technical/2374-where-and-having](https://platform.stratascratch.com/technical/2374-where-and-having?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/technical/2374-where-and-having](https://platform.stratascratch.com/technical/2374-where-and-having?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: Both WHERE and HAVING are used for filtering data. The main difference is that
    the WHERE clause is used for filtering data before aggregation and GROUP BY. The
    HAVING clause filters already aggregated data and is written after the GROUP BY
    clause.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE和HAVING都用于过滤数据。主要区别在于，WHERE子句用于在聚合和GROUP BY之前过滤数据，而HAVING子句则在GROUP BY子句之后用于过滤已经聚合的数据。
- en: 'SQL Interview Question #23: Left Join and Right Join'
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL面试问题#23：左连接和右连接
- en: '*“What is the difference between a left join and a right join in SQL?”*'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“在SQL中，左连接和右连接有什么区别？”*'
- en: 'Link to the question: [https://platform.stratascratch.com/technical/2242-left-join-and-right-join](https://platform.stratascratch.com/technical/2242-left-join-and-right-join?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/technical/2242-left-join-and-right-join](https://platform.stratascratch.com/technical/2242-left-join-and-right-join?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: 'You can start off by explaining the similarities of these two outer joins.
    Then you can talk about their differences. Hint: the clue is in the ‘left’ and
    ‘right’.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以先解释这两种外连接的相似之处。然后你可以谈论它们的区别。提示：线索在于‘left’和‘right’。
- en: 'SQL Interview Question #24: Common Table Expression'
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL面试问题#24：公共表表达式
- en: '*“In SQL, what is a Common Table Expression? Give an example of a situation
    when you would use it.”*'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“在SQL中，什么是公共表表达式？举例说明你会在什么情况下使用它。”*'
- en: 'Link to the question: [https://platform.stratascratch.com/technical/2354-common-table-expression](https://platform.stratascratch.com/technical/2354-common-table-expression?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/technical/2354-common-table-expression](https://platform.stratascratch.com/technical/2354-common-table-expression?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
- en: You already saw how the CTEs work. You could talk about comparing them with
    subqueries and then give an example of a CTE use. There you have it in the coding
    questions.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到CTE的工作原理。你可以谈谈它们与子查询的比较，然后给出一个CTE的使用示例。编码问题中已经涵盖了这些内容。
- en: Wrap up
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'The SQL interview questions usually come in two forms: coding and non-coding.
    Both question types most often test “The Unavoidable Seven”. You can’t even think
    of going to the interview without seven crucial SQL concepts.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: SQL面试问题通常有两种形式：编码和非编码。两种问题类型最常测试“不可避免的七个”。你不能在面试时忽视这七个关键的SQL概念。
- en: Focus on them to cover the most SQL questions that can come up at the interview.
    The question difficulty is also one variable, so there can be a big difference
    in the knowledge required for solving the easy and hard questions.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于这些问题，以涵盖面试中可能出现的大多数SQL问题。问题的难度也是一个变量，因此解决简单和困难问题所需的知识可能有很大差异。
- en: '**[Nate Rosidi](https://www.stratascratch.com)** is a data scientist and in
    product strategy. He''s also an adjunct professor teaching analytics, and is the
    founder of [StrataScratch](https://www.stratascratch.com/), a platform helping
    data scientists prepare for their interviews with real interview questions from
    top companies. Connect with him on [Twitter: StrataScratch](https://twitter.com/StrataScratch)
    or [LinkedIn](https://www.linkedin.com/in/nathanrosidi/).'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[5 Pandas Plotting Functions You Might Not Know](https://www.kdnuggets.com/2023/02/5-pandas-plotting-functions-might-know.html)'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 10 Advanced Data Science SQL Interview Questions You Must Know…](https://www.kdnuggets.com/2023/01/top-10-advanced-data-science-sql-interview-questions-must-know-answer.html)'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL Interview Questions for Experienced Professionals](https://www.kdnuggets.com/2022/01/sql-interview-questions-experienced-professionals.html)'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[25 Advanced SQL Interview Questions for Data Scientists](https://www.kdnuggets.com/2022/10/25-advanced-sql-interview-questions-data-scientists.html)'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3 More SQL Aggregate Function Interview Questions for Data Science](https://www.kdnuggets.com/2023/01/3-sql-aggregate-function-interview-questions-data-science.html)'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL and Python Interview Questions for Data Analysts](https://www.kdnuggets.com/2023/02/sql-python-interview-questions-data-analysts.html)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
