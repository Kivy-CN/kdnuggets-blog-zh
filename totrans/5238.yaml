- en: 'Event Processing: Three Important Open Problems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2018/05/event-processing-important-open-problems.html](https://www.kdnuggets.com/2018/05/event-processing-important-open-problems.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [comments](#comments)'
  prefs: []
  type: TYPE_IMG
- en: '**By [Miyuru Dayarathna](https://wso2.com/about/team/miyuru-dayarathna), WSO2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Event Processing (EP) is a paradigm which analyzes streams of events to extract
    useful insights of real world events. As shown in Figure 1, we can divide EP into
    two [main areas](http://miyurud.github.io/papers/2018/event-processing-survey.pdf)
    called *Event Stream processing* and *Complex Event Processing (CEP)*. The first
    area, [stream (i.e., event) processing](https://medium.com/@srinathperera/what-is-stream-processing-1eadfca11b97)
    supports many kinds of continuous analytics such as filter, aggregation, enrichment,
    classification, joining, etc. The second area, CEP uses patterns over sequences
    of simple events to detect and report composite events.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events Processing Fig1](../Images/153bbf20a110c795a9aa4387bfdc83f2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1: Difference between event processing terminologies**'
  prefs: []
  type: TYPE_NORMAL
- en: Based on a recent [survey](http://miyurud.github.io/papers/2018/event-processing-survey.pdf)
    and using multiple analysis conducted on the trends in the industry we identify
    three most important open problems in event processing as follows,
  prefs: []
  type: TYPE_NORMAL
- en: How to develop and debug event processing applications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to tackle the system scalability issue?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage the system state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to develop and debug event processing applications?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we need to address key issues of how the event processing applications
    get developed. There are two key sub-issues as follows,
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1 Can we use a single programming language across different stream processors?**'
  prefs: []
  type: TYPE_NORMAL
- en: Event processing applications are developed following three main techniques.
    First, via the use of an API written using a standard programming language such
    as Java/C++/Python. Some examples for such event processing platforms (all of
    which are Apache projects) are [Flink](https://flink.apache.org/), [Samza](http://samza.apache.org/),
    [Apex](https://apex.apache.org/), [Storm](http://storm.apache.org/), [Heron](https://github.com/apache/incubator-heron),
    etc. Figure 2 shows a breakdown of the usage of programming languages by event
    processing software.
  prefs: []
  type: TYPE_NORMAL
- en: '![Events Processing Fig2a, aggregated view ](../Images/187ade037749247ce144027e09060876.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Events Processing Fig2, breakdown of the programming languages](../Images/8f81f056e5594c04a288ca8fab6552ee.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2: Event Processing Software Programming Language usage. (a) aggregated
    view (b) breakdown of the programming languages used in different event processing
    systems.**'
  prefs: []
  type: TYPE_NORMAL
- en: Second, they can be developed using a custom (i.e., domain specific) language.
    For example, IBM Infosphere [Stream’s Stream Processing Language](https://www.ibm.com/support/knowledgecenter/en/SSCRJU_4.0.0/com.ibm.streams.ref.doc/doc/spl-container.html)
    (SPL), [Software AG’s Apama](https://www.softwareag.com/corporate/products/apama_webmethods/analytics/default),
    etc. The program statements written in the custom language get translated to intermediary
    languages such as C/C++/Perl, etc. and then they get compiled into application
    executables.
  prefs: []
  type: TYPE_NORMAL
- en: Third, event processing applications can be developed using SQL or SQL like
    languages. Examples include WSO2 [Siddhi](https://wso2.github.io/siddhi/) ([WSO2
    Stream Processor](https://wso2.com/analytics)), Confluent’s [KSQL](https://www.confluent.io/product/ksql/),
    [FlinkSQL](https://data-artisans.com/blog/flink-streaming-sql-ksql-stream-processing),
    [SparkSQL](https://spark.apache.org/sql/), [BeamSQL](https://beam.apache.org/documentation/dsls/sql/),
    etc. The SQL like languages (also known as [Streaming SQL](https://wso2.com/library/articles/2018/02/stream-processing-101-from-sql-to-streaming-sql-in-ten-minutes/))
    provide familiar syntax for application developers with relational database background.
    Streaming SQL provides core operations which [cover 90% of the use cases](https://wso2.com/library/articles/2018/02/stream-processing-101-from-sql-to-streaming-sql-in-ten-minutes/).
  prefs: []
  type: TYPE_NORMAL
- en: The diversity of the programming languages has created the need to follow a
    common syntax so that [usability and portability issues](https://player.vimeo.com/video/264663504)
    prevalent across event stream processors could be addressed. In doing so the third
    approach described above ([Streaming SQL](https://wso2.com/library/articles/2018/02/stream-processing-101-from-sql-to-streaming-sql-in-ten-minutes/))
    has significant potential of becoming the standard for specifying event stream
    processing applications. The ideal scenario would be to create a streaming SQL
    system which is ANSI SQL compliant. Currently, there are bits and pieces missing
    such as supporting set operations in Streaming SQL ([see](https://player.vimeo.com/video/264663504)).
  prefs: []
  type: TYPE_NORMAL
- en: '**2.2 Query Writing and Debugging Environment**'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the stream processors express business logic using programming language
    code such as [Streaming SQL](https://wso2.com/library/articles/2018/02/stream-processing-101-from-sql-to-streaming-sql-in-ten-minutes/),
    Scala, Java, etc. Hence it is useful to have right set of tools for developing
    stream processing applications. To develop large complex applications most of
    the time non-programmers prefer graphical user interface (GUI) based environments
    over command line interface (CLI) for application development. Large portion of
    the stream processor users are non-programmers such as data scientists. Hence
    not having a proper query writing and debugging environment makes the life of
    non-programmers a very difficult one. [Data analytics notebooks](http://miyurud.github.io/papers/2017/stream-processing-notebook.pdf)
    are emerging as a query writing environment for stream processor applications.
    Almost all the event stream processors have some kind of application debugging
    support. Yet, the depth of debugging support varies significantly.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can the system scalability issue be solved?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System scalability and performance are important metrics which measure the ability
    of a stream processor to handle large workloads. A scalable stream processor can
    expand its operational scale. The traditional scaling approaches are based on
    adding more resources and they are called vertical scaling (adding more resources
    to the same server) and horizontal scaling (adding multiple servers). However,
    some other techniques such as [elastic scaling](http://miyurud.github.io/papers/2017/ElasticCEP_ICPE2017-web.pdf),
    [approximate computing](https://www.infoq.com/articles/WSO2-algorithms-applied)
    could also be used to address the issues of system scalability.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to manage the system state effectively?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State of an event processor is the set of values being repeatedly accessed during
    the processing of the events from the incoming data stream. State has three types
    called Application state, User state, and System state. Application state refers
    to the values being created and maintained while running the application. This
    can be for example, state required to detect conditions such as patterns or content
    of a length window. Application state resides in the ephemeral store (See Figure
    2) such as main memory and periodically gets flushed to the permanent store. User
    state is the user data which is accessed by the application to make runtime decisions.
    For example, a permanent store such as a RDBMS can contain information of user’s
    credit history. System state refers to everything else the framework provides
    to make sure that if the stream processor crashes, it is recoverable back to its
    normal operations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Events Processing Fig3, A typical data stream processor ](../Images/6a72ace515156012bdadce8ee7756745.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3: A typical data stream processor with state management functionalities**'
  prefs: []
  type: TYPE_NORMAL
- en: Reliable and fault tolerant state management is important for a stream processor
    to provide highly available service. Traditionally, reliability and fault tolerance
    of the stream processors have been achieved by checkpointing their operator states
    into distributed file system, or to a Relational Database Management System (RDBMS)
    or to a distributed message queue (such as Apache Kafka). However, checkpointing
    introduces latency penalty since we need to stop execution of stream application
    before taking the checkpoint. Several techniques have been introduced to reduce
    the time taken for saving checkpoints. E.g., Incremental checkpointing keeps a
    log of changes made to the state and recovers using the log rather than taking
    full checkpoints of the application state every time. Hence this technique is
    only beneficial in use cases where the snapshot recovery cost can be subdued by
    the performance gain made by taking incremental checkpoints. Another approach
    would be instead of separating out computation layer and database layer into two,
    they can be merged into one layer and have the other tier as the storage layer
    for streams and snapshots ([see for details](https://www.infoq.com/presentations/distributed-stream-processing-flink)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: How an event processing application can be programmed, how it can be scaled,
    and how to manage its state are three main issues to be solved in event processing
    paradigm. Finding effective solutions for the above three questions may lead us
    to the next generation stream processors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bio:** [Miyuru Dayarathna](https://wso2.com/about/team/miyuru-dayarathna)
    is a Senior Technical Lead at WSO2\. He is a computer scientist with multiple
    research interests and contributions in stream computing, graph data management
    and mining, cloud computing, performance engineering, IoT, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Executive Guide to Data Science and Machine Learning](https://www.kdnuggets.com/2018/05/executive-guide-data-science-machine-learning.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Data Science vs Machine Learning vs Data Analytics vs Business Analytics](https://www.kdnuggets.com/2018/05/data-science-machine-learning-business-analytics.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Actionable Insights: Obliterating BI, Data Warehousing as We Know It](https://www.kdnuggets.com/2017/10/actionable-insights-bi-data-warehousing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Three R Libraries Every Data Scientist Should Know (Even if You Use Python)](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[More Performance Evaluation Metrics for Classification Problems You…](https://www.kdnuggets.com/2020/04/performance-evaluation-metrics-classification.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common Data Problems (and Solutions)](https://www.kdnuggets.com/2022/02/common-data-problems-solutions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4 Factors to Identify Machine Learning Solvable Problems](https://www.kdnuggets.com/2022/04/4-factors-identify-machine-learning-solvable-problems.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Want to Use Your Data Skills to Solve Global Problems? Here’s What…](https://www.kdnuggets.com/2022/04/jhu-want-data-skills-solve-global-problems.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solving 5 Complex SQL Problems: Tricky Queries Explained](https://www.kdnuggets.com/2022/07/5-hardest-things-sql.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
