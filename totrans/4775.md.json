["```py\n\nimport numpy as np\nimport imageio\nimport matplotlib.pyplot as plt\n\npic = imageio.imread('img/potato.jpeg')\nplt.figure(figsize=(7,7))\nplt.axis('off')\nplt.imshow(pic);\n\n```", "```py\n\ndef otsu_threshold(im):\n\n    # Compute histogram and probabilities of each intensity level\n    pixel_counts = [np.sum(im == i) for i in range(256)]\n\n    # Initialization\n    s_max = (0,0)\n\n    for threshold in range(256):\n\n        # update\n        w_0 = sum(pixel_counts[:threshold])\n        w_1 = sum(pixel_counts[threshold:])\n\n        mu_0 = sum([i * pixel_counts[i] for i in range(0,threshold)]) / w_0 if w_0 > 0 else 0       \n        mu_1 = sum([i * pixel_counts[i] for i in range(threshold, 256)]) / w_1 if w_1 > 0 else 0\n\n        # calculate - inter class variance\n        s = w_0 * w_1 * (mu_0 - mu_1) ** 2\n\n        if s > s_max[1]:\n            s_max = (threshold, s)\n\n    return s_max[0]\ndef threshold(pic, threshold):\n    return ((pic > threshold) * 255).astype('uint8')\n\ngray = lambda rgb : np.dot(rgb[... , :3] , [0.21 , 0.72, 0.07]) \n\nplt.figure(figsize=(7,7))\nplt.imshow(threshold(gray(pic), otsu_threshold(pic)), cmap='Greys')\nplt.axis('off');\n\n```", "```py\n\nfrom sklearn import cluster\n\nimport matplotlib.pyplot as plt\n# load image\npic = imageio.imread('img/purple.jpg') \n\nplt.figure(figsize=(7,7))\nplt.imshow(pic)\nplt.axis('off');\n\n```", "```py\n\nx, y, z = pic.shape\npic_2d = pic.reshape(x*y, z)\n```", "```py\n\n%%time\n\n# fit on the image with cluster five\nkmeans_cluster = cluster.KMeans(n_clusters=5)\nkmeans_cluster.fit(pic_2d)\n\ncluster_centers = kmeans_cluster.cluster_centers_\ncluster_labels = kmeans_cluster.labels_\nWall time: 16.2 s\n```", "```py\n\nplt.figure(figsize=(7,7))\nplt.imshow(cluster_centers[cluster_labels].reshape(x, y, z))\nplt.axis('off');\n\n```", "```py\n\nwhere\nρ = distance from origin to the line. [-Dmax, Dmax]\nDmax is the diagonal length of the image.\n\nθ = angle from origin to the line. [-90° to 90°]\n\n```", "```py\n\ndef hough_line(img):\n    # Rho and Theta ranges\n    thetas = np.deg2rad(np.arange(-90.0, 90.0))\n    width, height = img.shape\n    diag_len = int(np.ceil(np.sqrt(width * width + height * height)))   # Dmax\n    rhos = np.linspace(-diag_len, diag_len, diag_len * 2.0)\n\n    # Cache some resuable values\n    cos_t = np.cos(thetas)\n    sin_t = np.sin(thetas)\n    num_thetas = len(thetas)\n\n    # Hough accumulator array of theta vs rho\n    accumulator = np.zeros((2 * diag_len, num_thetas), dtype=np.uint64)\n    y_idxs, x_idxs = np.nonzero(img)  # (row, col) indexes to edges\n\n    # Vote in the hough accumulator\n    for i in range(len(x_idxs)):\n        x = x_idxs[i]\n        y = y_idxs[i]\n\n        for t_idx in range(num_thetas):\n            # Calculate rho. diag_len is added for a positive index\n            rho = round(x * cos_t[t_idx] + y * sin_t[t_idx]) + diag_len\n            accumulator[rho, t_idx] += 1\n    return accumulator, thetas, rhos\n\n```"]