["```py\n#Nnumber of classes in the dataset. Used to specify number of outputs in the last fully connected layer.\nnum_datatset_classes = 10\n#Number of rows & columns in each input image. The image is expected to be rectangular Used to reshape the images and specify the input tensor shape.\nim_dim = 32\n#Number of channels in rach input image. Used to reshape the images and specify the input tensor shape.\nnum_channels = 3\n\n#Directory at which the training binary files of the CIFAR10 dataset are saved.\npatches_dir = \"C:\\\\Users\\\\Dell\\\\Downloads\\\\Compressed\\\\cifar-10-python\\\\cifar-10-batches-py\\\\\"\n#Reading the CIFAR10 training binary files and returning the input data and output labels. Output labels are used to test the CNN prediction accuracy.\ndataset_array, dataset_labels = get_dataset_images(dataset_path=patches_dir, im_dim=im_dim, num_channels=num_channels)\nprint(\"Size of data : \", dataset_array.shape)\n\n\"\"\"\nInput tensor to hold the data read above. It is the entry point of the computational graph.\nThe given name of 'data_tensor' is useful for retreiving it when restoring the trained model graph for testing.\n\"\"\"\ndata_tensor = tensorflow.placeholder(tensorflow.float32, shape=[None, im_dim, im_dim, num_channels], name='data_tensor')\n\n\"\"\"\nTensor to hold the outputs label. \nThe name \"label_tensor\" is used for accessing the tensor when tesing the saved trained model after being restored.\n\"\"\"\nlabel_tensor = tensorflow.placeholder(tensorflow.float32, shape=[None], name='label_tensor')\n\n#The probability of dropping neurons in the dropout layer. It is given a name for accessing it later.\nkeep_prop = tensorflow.Variable(initial_value=0.5, name=\"keep_prop\")\n\n#Building the CNN architecure and returning the last layer which is the fully connected layer.\nfc_result2 = create_CNN(input_data=data_tensor, num_classes=num_datatset_classes, keep_prop=keep_prop)\n\n\"\"\"\nPredicitions probabilities of the CNN for each training sample.\nEach sample has a probability for each of the 10 classes in the dataset.\nSuch tensor is given a name for accessing it later.\n\"\"\"\nsoftmax_propabilities = tensorflow.nn.softmax(fc_result2, name=\"softmax_probs\")\n\n\"\"\"\nPredicitions labels of the CNN for each training sample.\nThe input sample is classified as the class of the highest probability.\naxis=1 indicates that maximum of values in the second axis is to be returned. This returns that maximum class probability fo each sample.\n\"\"\"\nsoftmax_predictions = tensorflow.argmax(softmax_propabilities, axis=1)\n\n#Cross entropy of the CNN based on its calculated probabilities.\ncross_entropy = tensorflow.nn.softmax_cross_entropy_with_logits(logits=tensorflow.reduce_max(input_tensor=softmax_propabilities, reduction_indices=[1]),\n                                                                labels=label_tensor)\n#Summarizing the cross entropy into a single value (cost) to be minimized by the learning algorithm.\ncost = tensorflow.reduce_mean(cross_entropy)\n#Minimizng the network cost using the Gradient Descent optimizer with a learning rate is 0.01.\nerror = tensorflow.train.GradientDescentOptimizer(learning_rate=.01).minimize(cost)\n\n#Creating a new TensorFlow Session to process the computational graph.\nsess = tensorflow.Session()\n#Wiriting summary of the graph to visualize it using TensorBoard.\ntensorflow.summary.FileWriter(logdir=\"./log/\", graph=sess.graph)\n#Initializing the variables of the graph.\nsess.run(tensorflow.global_variables_initializer())\n\n\"\"\"\nBecause it may be impossible to feed the complete data to the CNN on normal machines, it is recommended to split the data into a number of patches.\nA percent of traning samples is used to create each path. Samples for each path can be randomly selected.\n\"\"\"\nnum_patches = 5#Number of patches\nfor patch_num in numpy.arange(num_patches):\n    print(\"Patch : \", str(patch_num))\n    percent = 80 #percent of samples to be included in each path.\n    #Getting the input-output data of the current path.\n    shuffled_data, shuffled_labels = get_patch(data=dataset_array, labels=dataset_labels, percent=percent)\n    #Data required for cnn operation. 1)Input Images, 2)Output Labels, and 3)Dropout probability\n    cnn_feed_dict = {data_tensor: shuffled_data,\n                     label_tensor: shuffled_labels,\n                     keep_prop: 0.5}\n    \"\"\"\n    Training the CNN based on the current patch. \n    CNN error is used as input in the run to minimize it.\n    SoftMax predictions are returned to compute the classification accuracy.\n    \"\"\"\n    softmax_predictions_, _ = sess.run([softmax_predictions, error], feed_dict=cnn_feed_dict)\n    #Calculating number of correctly classified samples.\n    correct = numpy.array(numpy.where(softmax_predictions_ == shuffled_labels))\n    correct = correct.size\n    print(\"Correct predictions/\", str(percent * 50000/100), ' : ', correct)\n\n```", "```py\ndef get_patch(data, labels, percent=70):\n\n    \"\"\"\n    Returning patch to train the CNN.\n    :param data: Complete input data after being encoded and reshaped.\n    :param labels: Labels of the entire dataset.\n    :param percent: Percent of samples to get returned in each patch.\n    :return: Subset of the data (patch) to train the CNN model.\n    \"\"\"\n    #Using the percent of samples per patch to return the actual number of samples to get returned.\n    num_elements = numpy.uint32(percent*data.shape[0]/100)\n    shuffled_labels = labels#Temporary variable to hold the data after being shuffled.\n    numpy.random.shuffle(shuffled_labels)#Randomly reordering the labels.\n    \"\"\"\n    The previously specified percent of the data is returned starting from the beginning until meeting the required number of samples. \n    The labels indices are also used to return their corresponding input images samples.\n    \"\"\"\n    return data[shuffled_labels[:num_elements], :, :, :], shuffled_labels[:num_elements]\n\n```", "```py\n#Saving the model after being trained.\nsaver = tensorflow.train.Saver()\nsave_model_path = \"C:\\\\model\\\\\"\nsave_path = saver.save(sess=sess, save_path=save_model_path+\"model.ckpt\")\nprint(\"Model saved in : \", save_path)\n\n```", "```py\ndef get_dataset_images(test_path_path, im_dim=32, num_channels=3):\n\n    \"\"\"\n    Similar to the one used in training except that there is just a single testing binary file for testing the CIFAR10 trained models.\n    \"\"\"\n    print(\"Working on testing patch\")\n    data_dict = unpickle_patch(test_path_path)\n    images_data = data_dict[b\"data\"]\n    dataset_array = numpy.reshape(images_data, newshape=(len(images_data), im_dim, im_dim, num_channels))\n    return dataset_array, data_dict[b\"labels\"]\n\n```", "```py\n#Dataset path containing the testing binary file to be decoded.\npatches_dir = \"C:\\\\Users\\\\Dell\\\\Downloads\\\\Compressed\\\\cifar-10-python\\\\cifar-10-batches-py\\\\\"\ndataset_array, dataset_labels = get_dataset_images(test_path_path=patches_dir + \"test_batch\", im_dim=32, num_channels=3)\nprint(\"Size of data : \", dataset_array.shape)\n\nsess = tensorflow.Session()\n\n#Restoring the previously saved trained model.\nsaved_model_path = 'C:\\\\Users\\\\Dell\\\\Desktop\\\\model\\\\'\nsaver = tensorflow.train.import_meta_graph(saved_model_path+'model.ckpt.meta')\nsaver.restore(sess=sess, save_path=saved_model_path+'model.ckpt')\n\n#Initalizing the varaibales.\nsess.run(tensorflow.global_variables_initializer())\n\ngraph = tensorflow.get_default_graph()\n\n\"\"\"\nRestoring previous created tensors in the training phase based on their given tensor names in the training phase.\nSome of such tensors will be assigned the testing input data and their outcomes (data_tensor, label_tensor, and keep_prop).\nOthers are helpful in assessing the model prediction accuracy (softmax_propabilities and softmax_predictions).\n\"\"\"\nsoftmax_propabilities = graph.get_tensor_by_name(name=\"softmax_probs:0\")\nsoftmax_predictions = tensorflow.argmax(softmax_propabilities, axis=1)\ndata_tensor = graph.get_tensor_by_name(name=\"data_tensor:0\")\nlabel_tensor = graph.get_tensor_by_name(name=\"label_tensor:0\")\nkeep_prop = graph.get_tensor_by_name(name=\"keep_prop:0\")\n\n#keep_prop is equal to 1 because there is no more interest to remove neurons in the testing phase.\nfeed_dict_testing = {data_tensor: dataset_array,\n                     label_tensor: dataset_labels,\n                     keep_prop: 1.0}\n#Running the session to predict the outcomes of the testing samples.\nsoftmax_propabilities_, softmax_predictions_ = sess.run([softmax_propabilities, softmax_predictions],\n                                                      feed_dict=feed_dict_testing)\n#Assessing the model accuracy by counting number of correctly classified samples.\ncorrect = numpy.array(numpy.where(softmax_predictions_ == dataset_labels))\ncorrect = correct.size\nprint(\"Correct predictions/10,000 : \", correct)\n\n```", "```py\nimport flask\n#Creating a new Flask Web application. It accepts the package name.\napp = flask.Flask(\"CIFAR10_Flask_Web_App\")\n\n\"\"\"\nTo activate the Web server to receive requests, the application must run.\nA good practice is to check whether the file is whether the file called from an external Python file or not.\nIf not, then it will run.\n\"\"\"\nif __name__ == \"__main__\":\n    \"\"\"\n    In this example, the app will run based on the following properties:\n    host: localhost\n    port: 7777\n    debug: flag set to True to return debugging information.\n    \"\"\"\n    app.run(host=\"localhost\", port=7777, debug=True)\n\n```", "```py\napp.add_url_rule(rule=\"/\", endpoint=\"homepage\", view_func=redirect_upload)\n\n```", "```py\ndef redirect_upload():\n\n    \"\"\"\n    A viewer function that redirects the Web application from the root to a HTML page for uploading an image to get classified.\n    The HTML page is located under the /templates directory of the application.\n    :return: HTML page used for uploading an image. It is 'upload_image.html' in this exmaple.\n    \"\"\"\n    return flask.render_template(template_name_or_list=\"upload_image.html\")\n\"\"\"\nCreating a route between the homepage URL (http://localhost:7777) to a viewer function that is called after getting to such URL. \nEndpoint 'homepage' is used to make the route reusable without hard-coding it later.\n\"\"\"\napp.add_url_rule(rule=\"/\", endpoint=\"homepage\", view_func=redirect_upload)\n\n```", "```py\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{{url_for(endpoint='static', filename='project_styles.css')}}\">\n    <meta charset=\"UTF-8\">\n    <title>Upload Image</title>\n</head>\n<body>\n<form enctype=\"multipart/form-data\" method=\"post\" action=\"http://localhost:7777/upload/\">\n    <center>\n    <h3>Select CIFAR10 image to predict its label.</h3>\n    <input type=\"file\" name=\"image_file\" accept=\"image/*\"><br>\n    <input type=\"submit\" value=\"Upload\">\n    </center>\n</form>\n</body>\n</html>\n\n```", "```py\ndef upload_image():\n\n    \"\"\"\n    Viewer function that is called in response to getting to the 'http://localhost:7777/upload' URL.\n    It uploads the selected image to the server.\n    :return: redirects the application to a new page for predicting the class of the image.\n    \"\"\"\n    #Global variable to hold the name of the image file for reuse later in prediction by the 'CNN_predict' viewer functions.\n    global secure_filename\n    if flask.request.method == \"POST\":#Checking of the HTTP method initiating the request is POST.\n        img_file = flask.request.files[\"image_file\"]#Getting the file name to get uploaded.\n        secure_filename = werkzeug.secure_filename(img_file.filename)#Getting a secure file name. It is a good practice to use it.\n        img_path = os.path.join(app.root_path, secure_filename)#Preparing the full path under which the image will get saved.\n        img_file.save(img_path)#Saving the image in the specified path.\n        print(\"Image uploaded successfully.\")\n        \"\"\"\n        After uploading the image file successfully, next is to predict the class label of it.\n        The application will fetch the URL that is tied to the HTML page responsible for prediction and redirects the browser to it.\n        The URL is fetched using the endpoint 'predict'.\n        \"\"\"\n        return flask.redirect(flask.url_for(endpoint=\"predict\"))\n    return \"Image upload failed.\"\n\"\"\"\nCreating a route between the URL (http://localhost:7777/upload) to a viewer function that is called after navigating to such URL. \nEndpoint 'upload' is used to make the route reusable without hard-coding it later.\nThe set of HTTP method the viewer function is to respond to is added using the 'methods' argument.\nIn this case, the function will just respond to requests of method of type POST.\n\"\"\"\napp.add_url_rule(rule=\"/upload/\", endpoint=\"upload\", view_func=upload_image, methods=[\"POST\"])\n\n```", "```py\nreturn flask.redirect(flask.url_for(endpoint=\"predict\"))\n\n```", "```py\npredicted_class = CIFAR10_CNN_Predict_Image.main(img)\n\n```", "```py\ndef CNN_predict():\n\n    \"\"\"\n    Reads the uploaded image file and predicts its label using the saved pre-trained CNN model.\n    :return: Either an error if the image is not for CIFAR10 dataset or redirects the browser to a new page to show the prediction result if no error occurred.\n    \"\"\"\n    \"\"\"\n    Setting the previously created 'secure_filename' to global.\n    This is because to be able invoke a global variable created in another function, it must be defined global in the caller function.\n    \"\"\"\n    global secure_filename\n    #Reading the image file from the path it was saved in previously.\n    img = scipy.misc.imread(os.path.join(app.root_path, secure_filename))\n\n    \"\"\"\n    Checking whether the image dimensions match the CIFAR10 specifications.\n    CIFAR10 images are RGB (i.e. they have 3 dimensions). It number of dimenions was not equal to 3, then a message will be returned.\n    \"\"\"\n    if(img.ndim) == 3:\n        \"\"\"\n        Checking if the number of rows and columns of the read image matched CIFAR10 (32 rows and 32 columns).\n        \"\"\"\n        if img.shape[0] == img.shape[1] and img.shape[0] == 32:\n            \"\"\"\n            Checking whether the last dimension of the image has just 3 channels (Red, Green, and Blue).\n            \"\"\"\n            if img.shape[-1] == 3:\n                \"\"\"\n                Passing all conditions above, the image is proved to be of CIFAR10.\n                This is why it is passed to the predictor.\n                \"\"\"\n                predicted_class = CIFAR10_CNN_Predict_Image.main(img)\n                \"\"\"\n                After predicting the class label of the input image, the prediction label is rendered on an HTML page.\n                The HTML page is fetched from the /templates directory. The HTML page accepts an input which is the predicted class.\n                \"\"\"\n                return flask.render_template(template_name_or_list=\"prediction_result.html\", predicted_class=predicted_class)\n            else:\n                # If the image dimensions do not match the CIFAR10 specifications, then an HTML page is rendered to show the problem.\n                return flask.render_template(template_name_or_list=\"error.html\", img_shape=img.shape)\n        else:\n            # If the image dimensions do not match the CIFAR10 specifications, then an HTML page is rendered to show the problem.\n            return flask.render_template(template_name_or_list=\"error.html\", img_shape=img.shape)\n    return \"An error occurred.\"#Returned if there is a different error other than wrong image dimensions.\n\"\"\"\nCreating a route between the URL (http://localhost:7777/predict) to a viewer function that is called after navigating to such URL. \nEndpoint 'predict' is used to make the route reusable without hard-coding it later.\n\"\"\"\napp.add_url_rule(rule=\"/predict/\", endpoint=\"predict\", view_func=CNN_predict)\n\n```", "```py\ndef main(img):\n\n    \"\"\"\n    The 'main' method accepts an input image array of size 32x32x3 and returns its class label.\n    :param img:RGB image of size 32x32x3.\n    :return:Predicted class label.\n    \"\"\"\n    #Dataset path containing a binary file with the labels of classes. Useful to decode the prediction code into a significant textual label.\n    patches_dir = \"C:\\\\cifar-10-python\\\\cifar-10-batches-py\\\\\"\n    dataset_array = numpy.random.rand(1, 32, 32, 3)\n    dataset_array[0, :, :, :] = img\n\n    sess = tensorflow.Session()\n\n    #Restoring the previously saved trained model.\n    saved_model_path = 'C:\\\\model\\\\'\n    saver = tensorflow.train.import_meta_graph(saved_model_path+'model.ckpt.meta')\n    saver.restore(sess=sess, save_path=saved_model_path+'model.ckpt')\n\n    #Initalizing the varaibales.\n    sess.run(tensorflow.global_variables_initializer())\n\n    graph = tensorflow.get_default_graph()\n\n    \"\"\"\n    Restoring previous created tensors in the training phase based on their given tensor names in the training phase.\n    Some of such tensors will be assigned the testing input data and their outcomes (data_tensor, label_tensor, and keep_prop).\n    Others are helpful in assessing the model prediction accuracy (softmax_propabilities and softmax_predictions).\n    \"\"\"\n    softmax_propabilities = graph.get_tensor_by_name(name=\"softmax_probs:0\")\n    softmax_predictions = tensorflow.argmax(softmax_propabilities, axis=1)\n    data_tensor = graph.get_tensor_by_name(name=\"data_tensor:0\")\n    label_tensor = graph.get_tensor_by_name(name=\"label_tensor:0\")\n    keep_prop = graph.get_tensor_by_name(name=\"keep_prop:0\")\n\n    #keep_prop is equal to 1 because there is no more interest to remove neurons in the testing phase.\n    feed_dict_testing = {data_tensor: dataset_array,\n                         keep_prop: 1.0}\n    #Running the session to predict the outcomes of the testing samples.\n    softmax_propabilities_, softmax_predictions_ = sess.run([softmax_propabilities, softmax_predictions],\n                                                          feed_dict=feed_dict_testing)\n    label_names_dict = unpickle_patch(patches_dir + \"batches.meta\")\n    dataset_label_names = label_names_dict[b\"label_names\"]\n    return dataset_label_names[softmax_predictions_[0]].decode('utf-8')\n\n```", "```py\nreturn flask.render_template(template_name_or_list=\"prediction_result.html\", predicted_class=predicted_class)\n\n```", "```py\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{{url_for(endpoint='static', filename='project_styles.css')}}\">\n    <script type=\"text/javascript\" src=\"{{url_for(endpoint='static', filename='result.js')}}\"></script>\n    <meta charset=\"UTF-8\">\n    <title>Prediction Result</title>\n</head>\n<body onload=\"show_alert('{{predicted_class}}')\">\n<center><h1>Predicted Class Label : <span>{{predicted_class}}</span></h1>\n    <br>\n    <a href=\"{{url_for(endpoint='homepage')}}\"><span>Return to homepage</span>.</a>\n</center>\n</body>\n</html>\n\n```", "```py\n<span>{{predicted_class}}</span>\n\n```"]