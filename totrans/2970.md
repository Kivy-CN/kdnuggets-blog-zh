# 使用遗传算法优化人工神经网络与 Python

> 原文：[https://www.kdnuggets.com/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html](https://www.kdnuggets.com/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html)

![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [评论](/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html?page=2#comments)![实际计算机视觉应用-深度学习](../Images/2d2eba3f4293703bd96266e9008105f8.png)

在之前的一篇名为"**使用 NumPy 实现人工神经网络并分类 Fruits360 图像数据集**"的教程中，该教程可在我的 LinkedIn 个人资料中的此链接找到：[https://www.linkedin.com/pulse/artificial-neural-network-implementation-using-numpy-fruits360-gad](https://www.linkedin.com/pulse/artificial-neural-network-implementation-using-numpy-fruits360-gad)，我们创建了一个人工神经网络（ANN）用于分类 Fruits360 图像数据集中的 4 个类别。该教程中使用的源代码可以在我的 GitHub 页面找到： [https://github.com/ahmedfgad/NumPyANN](https://github.com/ahmedfgad/NumPyANN)

该教程的简要总结是提取特征向量（360 个 bins 色调通道直方图），并使用基于滤波的技术通过标准差将其减少到仅 102 个元素。随后，ANN 是从头开始使用 NumPy 构建的。

* * *

## 我们的前 3 个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你所在组织的 IT 工作

* * *

ANN 并未完全创建，只完成了前向传递，但没有进行更新网络权重的反向传递。这就是为什么准确率非常低且未超过 45%。解决这个问题的方法是使用优化技术来更新网络权重。本教程扩展了之前的教程，使用遗传算法（GA）来优化网络权重。

值得一提的是，之前的教程和本教程都基于我的 2018 年书籍，该书名为"**Ahmed Fawzy Gad《使用深度学习与 CNN 的实际计算机视觉应用》。2018年12月，Apress，978-1-4842-4167-7**"。该书在 Springer 上可通过以下链接找到：[https://springer.com/us/book/9781484241660](https://springer.com/us/book/9781484241660)。你可以在这本书中找到所有细节。

本教程中使用的源代码可以在我的GitHub页面找到：[https://github.com/ahmedfgad/NeuralGenetic](https://github.com/ahmedfgad/NeuralGenetic)

### 阅读更多关于遗传算法的内容

在开始本教程之前，我建议阅读关于遗传算法如何工作以及其在Python中使用NumPy从头实现的内容，这些内容可以在以下链接中找到：

+   遗传算法优化简介

    +   [https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/](https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/)

    +   [https://www.kdnuggets.com/2018/03/introduction-optimization-with-genetic-algorithm.html](/2018/03/introduction-optimization-with-genetic-algorithm.html)

    +   [https://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b](https://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b)

    +   [https://www.springer.com/us/book/9781484241660](https://www.springer.com/us/book/9781484241660)

+   遗传算法（GA）优化 - 步骤示例

    +   [https://www.slideshare.net/AhmedGadFCIT/genetic-algorithm-ga-optimization-stepbystep-example](https://www.slideshare.net/AhmedGadFCIT/genetic-algorithm-ga-optimization-stepbystep-example)

+   遗传算法在Python中的实现

    +   [https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/](https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/)

    +   [/2018/07/genetic-algorithm-implementation-python.html](/2018/07/genetic-algorithm-implementation-python.html)

    +   [https://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6](https://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6)

    +   [https://github.com/ahmedfgad/GeneticAlgorithmPython](https://github.com/ahmedfgad/GeneticAlgorithmPython)

在理解了基于数值示例的GA工作原理以及在Python中的实现之后，我们可以开始使用GA来优化ANN，通过更新其权重（参数）。

### 使用遗传算法（GA）优化人工神经网络（ANN）

GA为给定问题创建多个解决方案，并通过多个世代对其进行进化。每个解决方案包含可能有助于改善结果的所有参数。对于ANN，所有层的权重有助于实现高准确度。因此，GA中的单个解决方案将包含ANN中的所有权重。根据之前教程中讨论的网络结构以及下图所示，ANN具有4层（1层输入，2层隐藏，1层输出）。任何层中的权重都将成为同一解决方案的一部分。这样的网络的单个解决方案将包含总数量为102x150+150x60+60x4=24,540的权重。如果种群中有8个解决方案，每个解决方案包含24,540个参数，那么整个种群中的总参数数量为24,540x8=196,320。

![artificial-neural-network](../Images/d3ee8682d9b41f4e59bad5b79e948a75.png)

从上图来看，网络的参数是矩阵形式，因为这样可以使ANN的计算更加简单。对于每一层，都有一个相关的权重矩阵。只需将输入矩阵乘以给定层的参数矩阵，就可以返回该层的输出。遗传算法中的染色体是1D向量，因此我们必须将权重矩阵转换为1D向量。

因为矩阵乘法是处理人工神经网络（ANN）的一个好选择，我们在使用ANN时仍会将ANN的参数表示为矩阵形式。因此，在处理ANN时使用矩阵形式，而在处理遗传算法（GA）时使用向量形式。这就需要我们在矩阵和向量之间进行转换。下图总结了使用

这张图被称为**主要图**。

![figure-name](../Images/57ce8711167885fdd567d24b6587d7b0.png)

### 权重矩阵转换为 1D 向量的步骤。

每个种群中的解决方案将有两种表示方式。首先是用于GA的1D向量，其次是用于ANN的矩阵。由于3层（2层隐藏层+1层输出层）有3个权重矩阵，所以将有3个向量，每个矩阵对应一个向量。因为GA中的解决方案表示为一个单独的1D向量，所以这3个单独的1D向量将被拼接成一个单一的1D向量。每个解决方案将被表示为长度为24,540的向量。接下来的Python代码创建了一个名为**mat_to_vector()**的函数，该函数将种群中所有解决方案的参数从矩阵转换为向量。

```py

def mat_to_vector(mat_pop_weights):
    pop_weights_vector = []
    for sol_idx in range(mat_pop_weights.shape[0]):
        curr_vector = []
        for layer_idx in range(mat_pop_weights.shape[1]):
            vector_weights = numpy.reshape(mat_pop_weights[sol_idx, layer_idx], newshape=(mat_pop_weights[sol_idx, layer_idx].size))
            curr_vector.extend(vector_weights)
        pop_weights_vector.append(curr_vector)
    return numpy.array(pop_weights_vector)

```

该函数接受一个参数，表示所有解决方案的种群，以便对其进行遍历并返回它们的向量表示。在函数开始时，创建了一个名为**pop_weights_vector**的空列表变量，用于保存结果（所有解决方案的向量）。对于每个矩阵形式的解决方案，有一个内循环遍历其三个矩阵。对于每个矩阵，使用**numpy.reshape()**函数将其转换为向量，该函数接受输入矩阵和要重塑的输出大小。变量**curr_vector**接受一个解决方案的所有向量。在生成所有向量后，它们将被追加到**pop_weights_vector**变量中。

请注意，我们使用**numpy.extend()**函数来处理属于同一解决方案的向量，使用**numpy.append()**来处理属于不同解决方案的向量。原因是**numpy.extend()**将属于同一解决方案的3个向量中的数字连接在一起。换句话说，调用此函数的两个列表会返回一个新列表，其中包含两个列表中的所有数字。这适用于为每个解决方案创建一个1D染色体。但是**numpy.append()**将为每个解决方案返回三个列表。调用两个列表时，它会返回一个新的列表，该列表被拆分为两个子列表。这不是我们的目标。最后，**mat_to_vector()**函数将种群解决方案作为NumPy数组返回，以便后续处理。

### 实现GA步骤

在将所有解决方案从矩阵转换为向量并连接在一起后，我们准备进入**"Introduction to Optimization with Genetic Algorithm"**教程中讨论的GA步骤。这些步骤在**main figure**中展示，并在下一个图中总结。

![遗传算法步骤](../Images/6ab6d32f52e77336c2e67f65d9e0058b.png)

记住GA使用适应度函数来返回每个解决方案的适应度值。适应度值越高，解决方案越好。最佳解决方案作为父代在**parents selection**步骤中返回。

对于像ANN这样的分类器，常见的适应度函数之一是准确率。它是正确分类样本与样本总数之间的比例。它根据下列公式计算。每个解决方案的分类准确率是根据**main figure**中的步骤计算的。

![公式](../Images/e8768f7eb7deeb08cb4bd8ca72e54f27.png)

每个解决方案的单个1D向量被转换回3个矩阵，每层一个矩阵（2个隐藏层和1个输出层）。转换使用一个名为**vector_to_mat()**的函数。定义在下一个代码中。

```py

def vector_to_mat(vector_pop_weights, mat_pop_weights):

    mat_weights = []

    for sol_idx in range(mat_pop_weights.shape[0]):

        start = 0

        end = 0

        for layer_idx in range(mat_pop_weights.shape[1]):

            end = end + mat_pop_weights[sol_idx, layer_idx].size

            curr_vector = vector_pop_weights[sol_idx, start:end]

            mat_layer_weights = numpy.reshape(curr_vector, newshape=(mat_pop_weights[sol_idx, layer_idx].shape))

            mat_weights.append(mat_layer_weights)

            start = end

    return numpy.reshape(mat_weights, newshape=mat_pop_weights.shape)

```

它会逆转之前所做的工作。但有一个重要的问题。如果给定解决方案的向量只有一块，我们怎么将它分成三个不同的部分，每部分表示一个矩阵？输入层和隐藏层之间的第一个参数矩阵的大小是102x150。当转换为向量时，其长度为15,300。因为它是按照**mat_to_vector()**函数插入**curr_vector**变量中的第一个向量，所以其索引从0开始，到15,299结束。**mat_pop_weights**作为**vector_to_mat()**函数的参数，用于知道每个矩阵的大小。我们不关心使用**mat_pop_weights**变量中的权重，只关心从中获取矩阵的大小。

对于同一解决方案中的第二个向量，它将是将150x60的矩阵转换后的结果。因此，向量长度为9,000。这样一个向量被插入到 **curr_vector** 变量中，刚好在之前长度为15,300的向量之前。结果，它将从索引15,300开始，结束于索引15,300+9,000-1=24,299。-1的使用是因为Python从0开始索引。对于最后一个由60x4参数矩阵创建的向量，它的长度是240。由于它被添加到 **curr_vector** 变量中，正好在之前长度为9,000的向量之后，因此它的索引会在它之后开始。也就是说，它的起始索引是24,300，结束索引是24,300+240-1=24,539。因此，我们可以成功地将向量恢复为原始的3个矩阵。

每个解决方案返回的矩阵用于预测在所用数据集中每个1,962个样本的类别标签，以计算准确度。这是通过使用两个函数 **predict_outputs()** 和 **fitness()** 来完成的，具体请参见下述代码。

```py

def predict_outputs(weights_mat, data_inputs, data_outputs, activation="relu"):

    predictions = numpy.zeros(shape=(data_inputs.shape[0]))

    for sample_idx in range(data_inputs.shape[0]):

        r1 = data_inputs[sample_idx, :]

        for curr_weights in weights_mat:

            r1 = numpy.matmul(a=r1, b=curr_weights)

            if activation == "relu":

                r1 = relu(r1)

            elif activation == "sigmoid":

                r1 = sigmoid(r1)

        predicted_label = numpy.where(r1 == numpy.max(r1))[0][0]

        predictions[sample_idx] = predicted_label

    correct_predictions = numpy.where(predictions == data_outputs)[0].size

    accuracy = (correct_predictions/data_outputs.size)*100

    return accuracy, predictions

def fitness(weights_mat, data_inputs, data_outputs, activation="relu"):

    accuracy = numpy.empty(shape=(weights_mat.shape[0]))

    for sol_idx in range(weights_mat.shape[0]):

        curr_sol_mat = weights_mat[sol_idx, :]

        accuracy[sol_idx], _ = predict_outputs(curr_sol_mat, data_inputs, data_outputs, activation=activation)

    return accuracy

```

**predict_outputs()** 函数接受单个解决方案的权重、输入和训练数据的输出，以及一个可选参数，该参数指定使用哪个激活函数。它返回的仅仅是一个解决方案的准确度，而不是群体中所有解决方案的准确度。为了返回群体中所有解决方案的适应度值（即准确度），**fitness()** 函数遍历每个解决方案，将其传递给 **predict_outputs()** 函数，将所有解决方案的准确度存储到 **accuracy** 数组中，最后返回这个数组。

在计算所有解决方案的适应度值（即准确度）后，主图中的遗传算法（GA）的剩余步骤与之前的操作相同。根据准确度选择最好的父代进入配对池。然后应用突变和交叉变体以产生后代。新一代的种群是通过将后代和父代结合创建的。这些步骤会重复进行若干代。

### 更多相关主题

+   [使用管道编写干净的Python代码](https://www.kdnuggets.com/2021/12/write-clean-python-code-pipes.html)

+   [建立一个强大的数据团队](https://www.kdnuggets.com/2021/12/build-solid-data-team.html)

+   [是什么让Python成为初创公司的理想编程语言](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)

+   [每个数据科学家都应该了解的三个R库（即使你使用Python）](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)

+   [停止学习数据科学以寻找目标，并寻找目标去…](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)

+   [成为优秀数据科学家所需的5项关键技能](https://www.kdnuggets.com/2021/12/5-key-skills-needed-become-great-data-scientist.html)
