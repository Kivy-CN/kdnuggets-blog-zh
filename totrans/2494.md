# PyCaret 的二分类简介

> 原文：[https://www.kdnuggets.com/2021/12/introduction-binary-classification-pycaret.html](https://www.kdnuggets.com/2021/12/introduction-binary-classification-pycaret.html)

[评论](#comments)

**由 [Moez Ali](https://www.linkedin.com/in/profile-moez/)，PyCaret 的创始人及作者**

![](../Images/48f8e698fa3c51848935be2eaccf13c0.png)

由 [Mike U](https://unsplash.com/@roguewild?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 提供的照片

* * *

## 我们的前三个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织 IT

* * *

## 1.0 简介

[PyCaret](https://www.pycaret.org/) 是一个开源的低代码机器学习库，它自动化机器学习工作流。它是一个端到端的机器学习和模型管理工具，可以显著加快实验周期，提高生产力。

与其他开源机器学习库相比，PyCaret 是一个替代的低代码库，可以用少量代码替代成百上千行代码。这使得实验过程极其快速高效。PyCaret 本质上是几个机器学习库和框架的 Python 包装器，例如 scikit-learn、XGBoost、LightGBM、CatBoost、spaCy、Optuna、Hyperopt、Ray 等。

PyCaret 的设计和简洁性受到“公民数据科学家”这一新兴角色的启发，这一术语首次由 Gartner 提出。公民数据科学家是能够执行简单和中等复杂度分析任务的高级用户，这些任务之前需要更多技术专长。

要了解更多关于 PyCaret 的信息，你可以查看官方 [网站](https://www.pycaret.org/) 或 [GitHub](https://www.github.com/pycaret/pycaret)。

## 2.0 教程目标

在本教程中，我们将学习：

+   **获取数据：** 如何从 PyCaret 仓库导入数据

+   **设置环境：** 如何在 PyCaret 中设置实验并开始构建分类模型

+   **创建模型：** 如何创建模型，进行分层交叉验证并评估分类指标

+   **调整模型：** 如何自动调整分类模型的超参数

+   **绘制模型：** 如何使用各种图表分析模型性能

+   **最终确定模型：** 如何在实验结束时确定最佳模型

+   **预测模型：** 如何对未见数据进行预测

+   **保存/加载模型：** 如何保存/加载模型以供将来使用

## 3.0 安装 PyCaret

安装过程简单，只需几分钟。PyCaret 从 pip 的默认安装仅安装了 [requirements.txt](https://github.com/pycaret/pycaret/blob/master/requirements.txt) 文件中列出的硬依赖。

[PRE0]

要安装完整版本：

[PRE1]

## 4.0 什么是二分类？

二分类是一种监督式机器学习技术，目标是预测离散且无序的类别标签，如合格/不合格、正面/负面、违约/非违约等。以下是一些分类的实际应用案例：

+   医疗检测以确定患者是否患有某种疾病——分类属性是疾病的存在。

+   工厂中的“合格或不合格”测试方法或质量控制，即决定是否满足规范——一种合格/不合格的分类。

+   信息检索，即决定一个页面或文章是否应出现在搜索结果中——分类属性是文章的相关性或对用户的有用性。

## 5.0 PyCaret中的分类模块概述

PyCaret 的 [分类模块](https://pycaret.readthedocs.io/en/latest/api/classification.html) (`pycaret.classification`) 是一个监督式机器学习模块，用于根据各种技术和算法将元素分类到二进制组中。一些常见的分类问题的应用包括预测客户违约（是或否）、客户流失（客户是否会离开或留下）、疾病检测（阳性或阴性）。

PyCaret的分类模块可用于二分类或多分类问题。它有超过18种算法和14种图表来分析模型的性能。不论是超参数调优、集成方法，还是像堆叠这样的高级技术，PyCaret的分类模块都可以满足需求。

## 6.0 教程数据集

在本教程中，我们将使用来自 UCI 的数据集，[**信用卡客户违约数据集**](https://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients)。该数据集包含了2005年4月到2005年9月在台湾的信用卡客户的违约支付信息、人口统计因素、信用数据、支付历史和账单报表，共有24,000个样本和25个特征。每一列的简要描述如下：

+   **ID：** 每个客户的ID

+   **信用额度：** 以新台币为单位的信用额度（包括个人和家庭/附加信用）

+   **性别：** 性别（1=男，2=女）

+   **教育程度：** （1=研究生，2=大学，3=高中，4=其他，5=未知，6=未知）

+   **婚姻状况：** 婚姻状态（1=已婚，2=单身，3=其他）

+   **年龄：** 年龄（以年为单位）

+   **PAY_0 到 PAY_6：** 几个月前的还款状态（PAY_0 = 上个月 … PAY_6 = 6 个月前）（标签：-1=按时还款，1=逾期一个月，2=逾期两个月，… 8=逾期八个月，9=逾期九个月及以上）

+   **BILL_AMT1 到 BILL_AMT6：** 几个月前的账单金额（ BILL_AMT1 = 上个月 .. BILL_AMT6 = 6 个月前）

+   **PAY_AMT1 到 PAY_AMT6：** 几个月前的支付金额（ BILL_AMT1 = 上个月 .. BILL_AMT6 = 6 个月前）

+   **默认值：** 默认支付（1=是，0=否） `Target Column`

## 数据集致谢：

Lichman, M. (2013). UCI 机器学习库。加利福尼亚州欧文市：加利福尼亚大学信息与计算机科学学院。

## 7.0 获取数据

你可以从原始来源下载数据 [**在这里找到**](https://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients) 并使用 pandas [**（学习如何）**](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html) 加载数据，或者你可以使用 PyCaret 的数据仓库，通过 `get_data()` 函数加载数据（这需要互联网连接）。

[PRE2]

![png](../Images/15c6708db0c28339c5fa0fff910992c8.png)

[PRE3]

为了演示 `predict_model` 函数在未见数据上的使用，原始数据集中保留了 1200 条记录（约 5%）以用于最后的预测。这不应与训练-测试-拆分混淆，因为这种特定的拆分是为了模拟真实场景。另一种理解方式是，这 1200 名客户在训练机器学习模型时不可用。

[PRE4]

## 8.0 在 PyCaret 中设置环境

PyCaret 中的 `setup` 函数初始化环境并创建建模和部署的转换管道。在执行 pycaret 的任何其他函数之前，必须调用 `setup`。它需要两个必需的参数：一个 pandas dataframe 和目标列的名称。所有其他参数是可选的，可以用于自定义预处理管道。

当 `setup` 执行时，PyCaret 的推断算法将根据某些属性自动推断所有特征的数据类型。数据类型应该被正确推断，但这并不总是如此。为此，PyCaret 会在你执行 `setup` 后显示一个提示，要求确认数据类型。如果所有数据类型正确，你可以按回车键，如果要退出设置，输入 `quit`。

确保数据类型正确在 PyCaret 中非常重要，因为它会自动执行多种特定类型的预处理任务，这对机器学习模型至关重要。

另外，你还可以在 `setup` 中使用 `numeric_features` 和 `categorical_features` 参数来预定义数据类型。

[PRE5]

![png](../Images/f5680fa7ac99aa4cf1de46adb02b05af.png)

一旦设置成功执行，它会显示包含实验重要信息的信息网格。大部分信息与执行`setup`时构建的预处理管道相关。这些特性大多数超出了本教程的范围，但需要注意以下几个重要点：

+   **session_id：** 作为种子分配给所有函数的伪随机数，以便后续可重复性。如果没有传递`session_id`，则会自动生成一个随机数，并分配给所有函数。在本实验中，`session_id`设置为`123`以确保后续可重复性。

+   **目标类型：** 二分类或多分类。目标类型会自动检测并显示。二分类和多分类问题在实验执行方式上没有区别。所有功能都是相同的。

+   **标签编码：** 当目标变量是字符串类型（即‘Yes’或‘No’）而不是1或0时，它会自动将标签编码为1和0，并显示映射（0: No, 1: Yes）供参考。在本实验中，由于目标变量是数值型，因此不需要标签编码。

+   **原始数据：** 显示数据集的原始形状。在本实验中，（22800, 24）表示22,800个样本和包括目标列在内的24个特征。

+   **缺失值：** 当原始数据中存在缺失值时，这里会显示为True。在本实验中，数据集中没有缺失值。

+   **数值特征：** 推断出的数值型特征数量。在此数据集中，24个特征中有14个被推断为数值型。

+   **分类特征：** 推断出的分类特征数量。在此数据集中，24个特征中有9个被推断为分类特征。

+   **转化后的训练集：** 显示转化后的训练集的形状。注意，原始形状（22800, 24）被转化为（15959, 91），并且由于独热编码，特征数量从24增加到91。

+   **转化后的测试集：** 显示转化后的测试/持留集的形状。测试/持留集中有6841个样本。这个分割基于默认值70/30，可以通过`train_size`参数在设置中进行更改。

注意，一些对建模至关重要的任务是自动处理的，例如缺失值插补（在这种情况下，训练数据中没有缺失值，但我们仍然需要插补器来处理未见数据）、分类编码等。`setup`中的大部分参数是可选的，用于自定义预处理管道。这些参数超出了本教程的范围，但我们会在未来的教程中涵盖它们。

## 9.0 比较所有模型

比较所有模型以评估性能是完成设置后的推荐起点（除非你确切知道需要哪种模型，这种情况通常不常见）。此功能会训练模型库中的所有模型，并使用分层交叉验证进行指标评估。输出会打印一个评分网格，显示各折（默认10折）的平均准确率、AUC、召回率、精确率、F1 分数、Kappa 值和 MCC，以及训练时间。

[PRE6]

![](../Images/f55c8b9473ff0d8d18ea4fbad477ffea.png)

上述打印的评分网格仅突出显示了用于比较的最高性能指标。网格默认按 `Accuracy`（从高到低）排序，可以通过传递 `sort` 参数进行更改。例如 `compare_models(sort = 'Recall')` 将按召回率而不是准确率对网格进行排序。

如果你想将折数参数从默认值 `10` 更改为其他值，可以使用 `fold` 参数。例如 `compare_models(fold = 5)` 将在 5 折交叉验证上比较所有模型。减少折数将提高训练时间。默认情况下，`compare_models` 返回基于默认排序顺序的最佳表现模型，但也可以通过使用 `n_select` 参数返回前 N 个模型的列表。

[PRE7]

## 10.0 创建模型

`create_model` 是 PyCaret 中最细粒度的功能，通常是大多数 PyCaret 功能的基础。顾名思义，此功能使用交叉验证来训练和评估模型，交叉验证的折数可以通过 `fold` 参数设置。输出会打印一个评分网格，显示各折的准确率、AUC、召回率、精确率、F1 分数、Kappa 值和 MCC。

在本教程的剩余部分，我们将使用下列模型作为我们的候选模型。选择这些模型仅用于说明目的，并不一定意味着它们在此类型数据中表现最佳或最为理想。

+   决策树分类器（‘dt’）

+   K 近邻分类器（‘knn’）

+   随机森林分类器（‘rf’）

PyCaret 模型库中有 18 个分类器。要查看所有分类器的列表，可以查阅文档或使用 `models` 函数查看库。

[PRE8]

![](../Images/34973a5648847757697f30db20a4cd38.png)

## 10.1 决策树分类器

[PRE9]

![](../Images/0968d4d67efa271f3665869ca1bd65ec.png)

[PRE10]

## 10.2 K 近邻分类器

[PRE11]

![](../Images/c99040f56cd8529088616aa3c46a2897.png)

## 10.3 随机森林分类器

[PRE12]

![](../Images/54259896a7c5696c43f0c0dbf4fc3cdc.png)

请注意，所有模型的平均得分与 `compare_models` 中打印的得分一致。这是因为 `compare_models` 评分网格中的指标是所有交叉验证折的平均得分。类似于 `compare_models`，如果你想将折数参数从默认值 10 更改为其他值，可以使用 `fold` 参数。例如：`create_model('dt', fold = 5)` 将使用 5 折分层交叉验证创建决策树分类器。

## 11.0 调整模型

当使用`create_model`函数创建模型时，它使用默认超参数来训练模型。为了调整超参数，使用`tune_model`函数。该函数通过在预定义的搜索空间上进行随机网格搜索，自动调整模型的超参数。输出会打印一个评分网格，显示最佳模型在各折中的准确度、AUC、召回率、精确度、F1分数、Kappa和MCC。要使用自定义搜索网格，可以在`tune_model`函数中传递`custom_grid`参数（请参见下面的11.2 KNN调整）。

## 11.1 决策树分类器

[PRE13]

![](../Images/74b345f9e28f7da429e4226b8c01ec64.png)

[PRE14]

## 11.2 K 最近邻分类器

[PRE15]

![](../Images/bf1f90c108efa7e4fefe9b04c9e40744.png)

[PRE16]

## 11.3 随机森林分类器

[PRE17]

![](../Images/bc41a57e4365ed095755adfc837fa15c.png)

默认情况下，`tune_model`优化`Accuracy`，但可以通过`optimize`参数进行更改。例如：`tune_model(dt, optimize = 'AUC')`将搜索决策树分类器的超参数，以获得最高的`AUC`而不是`Accuracy`。为了简单起见，本示例仅使用了默认指标`Accuracy`。通常，当数据集不平衡（如我们正在处理的信用数据集）时，`Accuracy`不是一个好的评估指标。选择合适的指标来评估分类器的方法超出了本教程的范围，但如果你想了解更多，可以[**点击这里**](https://medium.com/@MohammedS/performance-metrics-for-classification-problems-in-machine-learning-part-i-b085d432082b)阅读一篇关于如何选择正确评估指标的文章。

单独的指标并不是在最终确定最佳生产模型时唯一需要考虑的标准。其他需要考虑的因素包括训练时间、k折的标准差等。随着教程系列的深入，我们将在中级和高级阶段详细讨论这些因素。现在，让我们继续将调整后的随机森林分类器`tuned_rf`作为本教程剩余部分的最佳模型。

## 12.0 绘制模型

在模型最终确定之前，可以使用`plot_model`函数分析各个方面的性能，例如AUC、混淆矩阵、决策边界等。该函数接受一个训练好的模型对象，并返回基于测试集的图形。

提供了15种不同的图形，具体可查看`plot_model`文档中的可用图形列表。

## 12.1 AUC图

[PRE18]

![png](../Images/260e900d7f7ce14e00835b8521e2e381.png)

## 12.2 精确度-召回率曲线

[PRE19]

![png](../Images/b42330e418d905c9b44d8537032eec66.png)

## 12.3 特征重要性图

[PRE20]

![png](../Images/98cf38d13d31e60982e9a3d7e7ab8583.png)

## 12.4 混淆矩阵

[PRE21]

![png](../Images/03e51f3afc86070b952151346c2d1346.png)

*另一种* 分析模型性能的方法是使用`evaluate_model()`函数，该函数为给定模型显示所有可用图表的用户界面。它内部使用了`plot_model()`函数。

[PRE22]

![](../Images/c4072017a375237f83ce3b8b5dfce2e7.png)

## 13.0 对测试/持出样本进行预测

在最终确定模型之前，建议通过预测测试/持出集并审查评估指标进行最后检查。如果你查看上文第8节中的信息网格，你会看到30%（6,841个样本）的数据被分离出来作为测试/持出样本。我们以上看到的所有评估指标都是基于训练集（70%）的交叉验证结果。现在，使用我们最终训练好的模型`tuned_rf`来预测测试/持出样本，并评估指标以查看它们是否与交叉验证结果有显著差异。

[PRE23]

![](../Images/b75a08012005a33bb198eef510c49c6b.png)

测试/持出集上的准确率为`**0.8116**`，相比于`tuned_rf`交叉验证结果中的`**0.8203**`（在第11.3节中）。这不是一个显著的差异。如果测试/持出集和交叉验证结果之间有较大差异，这通常表示过拟合，但也可能由于其他几个因素，需要进一步调查。在这种情况下，我们将继续完成模型并对未见数据进行预测（即最初分离的5%数据，未暴露于PyCaret）。

（提示：使用`create_model`时查看交叉验证结果的标准差总是好的）

## 14.0 完成模型部署

模型最终确定是实验中的最后一步。在PyCaret中，正常的机器学习工作流程从`setup`开始，然后使用`compare_models`比较所有模型，并基于感兴趣的指标筛选几个候选模型，以执行各种建模技术，如超参数调整、集成、堆叠等。这个工作流程最终将引导你找到最佳模型，用于对新数据和未见数据进行预测。`finalize_model`函数将模型拟合到完整数据集，包括测试/持出样本（在这种情况下是30%）。该函数的目的是在生产环境中部署之前，在完整数据集上训练最终模型。（这是可选的，你可以选择是否使用finalize_model）。

[PRE24]

**注意：** 最后一点提醒。一旦模型被最终确定，整个数据集，包括测试/持出集，都用于训练。因此，如果在使用`finalize_model`后对持出集进行预测，信息网格将会具有误导性，因为你是在尝试预测用于建模的相同数据。为了仅仅展示这一点，我们将使用`final_rf`在`predict_model`下与第13节中的信息网格进行比较。

[PRE25]

![](../Images/a013e2bd953b01eed34d01815befc639.png)

请注意，尽管模型相同，`final_rf`中的AUC已经从`**0.7407**`增加到`**0.7526**`。这是因为`final_rf`变量已经在包括测试/保留集的完整数据集上进行了训练。

## 15.0 对未见数据进行预测

`predict_model`函数也用于对未见数据集进行预测。与第13节不同的是，这次我们将传递`data_unseen`。这是在本教程开始时创建的变量，包含原始数据集的5%（1200个样本），这些样本从未暴露给PyCaret。（参见第7节了解解释）

[PRE26]

![png](../Images/9bc7878a2506ae2f4784b4f9100094d2.png)

`Label`和`Score`列被添加到`data_unseen`数据集中。标签是预测值，分数是预测的概率。请注意，预测结果被连接到原始数据集中，同时所有的转换都在后台自动执行。由于您有实际的目标列`default`，您也可以检查这些指标。为此，我们将使用`pycaret.utils`模块。请参见下面的示例：

[PRE27]

## 16.0 保存模型

我们现在通过最终确定`tuned_rf`模型完成了实验，该模型现在存储在`final_rf`变量中。我们还使用存储在`final_rf`中的模型对`data_unseen`进行了预测。这标志着实验的结束，但仍有一个问题需要解决：当您有更多新的数据需要预测时会发生什么？您是否需要重新进行整个实验？答案是否定的，PyCaret内置的`save_model()`函数允许您保存模型及整个转换管道以备后用。

[PRE28]

## 17.0 加载保存的模型

若要在将来在相同或其他环境中加载保存的模型，我们可以使用PyCaret的`load_model()`函数，然后轻松地在新的未见数据上应用保存的模型进行预测。

[PRE29]

一旦模型加载到环境中，您可以简单地使用相同的`predict_model()`函数对任何新数据进行预测。以下是我们将加载的模型应用于第13节中使用的相同`data_unseen`进行预测的示例。

[PRE30]

![png](../Images/9bc7878a2506ae2f4784b4f9100094d2.png)

请注意，`unseen_predictions`和`new_prediction`的结果是相同的。

[PRE31]

## 18.0 总结 / 下一步？

本教程涵盖了整个机器学习流程，从数据摄取、预处理、训练模型、超参数调优、预测，到保存模型以备后用。我们在不到10个命令中完成了所有这些步骤，这些命令自然构造且易于记忆，如`create_model()`、`tune_model()`、`compare_models()`。没有PyCaret，重新创建整个实验将需要超过100行代码。

我们仅覆盖了 `pycaret.classification` 的基础知识。在未来的教程中，我们将深入探讨高级预处理、集成、广义堆叠和其他技术，这些技术能够让你完全自定义你的机器学习管道，是任何数据科学家必须掌握的。

感谢阅读 [????](https://emojipedia.org/folded-hands/)

## 重要链接

⭐ [教程](https://github.com/pycaret/pycaret/tree/master/tutorials) 刚接触 PyCaret？查看我们的官方笔记本！

???? [示例笔记本](https://github.com/pycaret/pycaret/tree/master/examples) 由社区创建。

???? [博客](https://github.com/pycaret/pycaret/tree/master/resources) 由贡献者撰写的教程和文章。

???? [文档](https://pycaret.readthedocs.io/en/latest/index.html) PyCaret 的详细 API 文档

???? [视频教程](https://www.youtube.com/channel/UCxA1YTYJ9BEeo50lxyI_B3g) 我们在各种活动中的视频教程。

???? [讨论](https://github.com/pycaret/pycaret/discussions) 有问题？与社区和贡献者互动。

????️ [更新日志](https://github.com/pycaret/pycaret/blob/master/CHANGELOG.md) 变更和版本历史。

???? [路线图](https://github.com/pycaret/pycaret/issues/1756) PyCaret 的软件和社区发展计划。

**简介：[Moez Ali](https://www.linkedin.com/in/profile-moez/)** 撰写关于 PyCaret 及其实际应用的文章。如果你希望自动接收通知，可以关注 Moez 的 [Medium](https://medium.com/@moez-62905)、[LinkedIn](https://www.linkedin.com/in/profile-moez/) 和 [Twitter](https://twitter.com/moezpycaretorg1)。

[原文](https://towardsdatascience.com/introduction-to-binary-classification-with-pycaret-a37b3e89ad8d)。经许可转载。

**相关：**

+   [初学者端到端机器学习指南](/2021/12/beginner-guide-end-end-machine-learning.html)

+   [PyCaret 2.3.5 发布！了解新功能](/2021/11/pycaret-here-learn-new.html)

+   [使用 PyCaret 的新时间序列模块](/2021/12/pycaret-new-time-series-module.html)

### 更多相关内容

+   [使用 PyCaret 进行 Python 中的聚类介绍](https://www.kdnuggets.com/2021/12/introduction-clustering-python-pycaret.html)

+   [多标签分类：使用 Python 的 Scikit-Learn 进行介绍](https://www.kdnuggets.com/2023/08/multilabel-classification-introduction-python-scikitlearn.html)

+   [宣布 PyCaret 3.0：Python 中的开源、低代码机器学习](https://www.kdnuggets.com/2023/03/announcing-pycaret-30-opensource-lowcode-machine-learning-python.html)

+   [开始使用 PyCaret](https://www.kdnuggets.com/2022/11/getting-started-pycaret.html)

+   [分类问题的更多性能评估指标](https://www.kdnuggets.com/2020/04/performance-evaluation-metrics-classification.html)

+   [使用 HuggingFace 对 BERT 进行推文分类的微调](https://www.kdnuggets.com/2022/01/finetuning-bert-tweets-classification-ft-hugging-face.html)
