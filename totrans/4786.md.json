["```py\nimport random\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nimport sys\nimport os\n\nlib_path = os.path.join(os.path.realpath(\".\"), \"data_aug\")\nsys.path.append(lib_path)\n```", "```py\nclass RandomHorizontalFlip(object):\n\n    \"\"\"Randomly horizontally flips the Image with the probability *p*\n\n    Parameters\n    ----------\n    p: float\n        The probability with which the image is flipped\n\n    Returns\n    -------\n\n    numpy.ndaaray\n        Flipped image in the numpy format of shape `HxWxC`\n\n    numpy.ndarray\n        Tranformed bounding box co-ordinates of the format `n x 4` where n is \n        number of bounding boxes and 4 represents `x1,y1,x2,y2` of the box\n\n    \"\"\"\n\n    def __init__(self, p=0.5):\n        self.p = p\n\n```", "```py\ndef __call__(self, img, bboxes):\n        img_center = np.array(img.shape[:2])[::-1]/2\n        img_center = np.hstack((img_center, img_center))\n        if random.random() < self.p:\n            img =  img[:,::-1,:]\n            bboxes[:,[0,2]] += 2*(img_center[[0,2]] - bboxes[:,[0,2]])\n\n            box_w = abs(bboxes[:,0] - bboxes[:,2])\n\n            bboxes[:,0] -= box_w\n            bboxes[:,2] += box_w\n\n        return img, bboxes\n```", "```py\nimg_center = np.array(img.shape[:2])[::-1]/2\nimg_center = np.hstack((img_center, img_center))\nif random.random() < self.p:\n   img =  img[:,::-1,:]\n   bboxes[:,[0,2]] += 2*(img_center[[0,2]] - bboxes[:,[0,2]])\n```", "```py\nbox_w = abs(bboxes[:,0] - bboxes[:,2])\nbboxes[:,0] -= box_w\nbboxes[:,2] += box_w\n\n```", "```py\ndef __call__(self, img, bboxes):\n        img_center = np.array(img.shape[:2])[::-1]/2\n        img_center = np.hstack((img_center, img_center))\n\n        img =  img[:,::-1,:]\n        bboxes[:,[0,2]] += 2*(img_center[[0,2]] - bboxes[:,[0,2]])\n\n        box_w = abs(bboxes[:,0] - bboxes[:,2])\n\n        bboxes[:,0] -= box_w\n        bboxes[:,2] += box_w\n\n    return img, bboxes\n```", "```py\nfrom data_aug.data_aug import *\nimport cv2 \nimport pickle as pkl\nimport numpy as np \nimport matplotlib.pyplot as plt\n```", "```py\nimg = cv2.imread(\"messi.jpg\")[:,:,::-1] #OpenCV uses BGR channels\nbboxes = pkl.load(open(\"messi_ann.pkl\", \"rb\"))\n\n#print(bboxes)   #visual inspection\n\n```", "```py\nimport cv2 \nimport numpy as np\n```", "```py\ndef draw_rect(im, cords, color = None):\n    \"\"\"Draw the rectangle on the image\n\n    Parameters\n    ----------\n\n    im : numpy.ndarray\n        numpy image \n\n    cords: numpy.ndarray\n        Numpy array containing bounding boxes of shape `N X 4` where N is the \n        number of bounding boxes and the bounding boxes are represented in the\n        format `x1 y1 x2 y2`\n\n    Returns\n    -------\n\n    numpy.ndarray\n        numpy image with bounding boxes drawn on it\n\n    \"\"\"\n\n    im = im.copy()\n\n    cords = cords.reshape(-1,4)\n    if not color:\n        color = [255,255,255]\n    for cord in cords:\n\n        pt1, pt2 = (cord[0], cord[1]) , (cord[2], cord[3])\n\n        pt1 = int(pt1[0]), int(pt1[1])\n        pt2 = int(pt2[0]), int(pt2[1])\n\n        im = cv2.rectangle(im.copy(), pt1, pt2, color, int(max(im.shape[:2])/200))\n    return im\n```", "```py\nplt.imshow(draw_rect(img, bboxes))\n```", "```py\nhor_flip = RandomHorizontalFlip(1)  \n\nimg, bboxes = hor_flip(img, bboxes)\n\nplt.imshow(draw_rect(img, bboxes))\n```"]