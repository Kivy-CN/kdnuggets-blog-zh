- en: 'Essential Math for Data Science: Integrals And Area Under The Curve'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据科学中的基本数学：积分与曲线下的面积
- en: 原文：[https://www.kdnuggets.com/2020/11/essential-math-data-science-integrals-area-under-curve.html](https://www.kdnuggets.com/2020/11/essential-math-data-science-integrals-area-under-curve.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2020/11/essential-math-data-science-integrals-area-under-curve.html](https://www.kdnuggets.com/2020/11/essential-math-data-science-integrals-area-under-curve.html)
- en: '[comments](#comments)[![Image](../Images/45c05efbbd9635efb62adde614427da4.png)](https://www.essentialmathfordatascience.com/)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](#comments)[![图片](../Images/45c05efbbd9635efb62adde614427da4.png)](https://www.essentialmathfordatascience.com/)'
- en: 'Calculus is a branch of mathematics that gives tools to study the rate of change
    of functions through two main areas: derivatives and integrals. In the context
    of machine learning and data science, you might use integrals to calculate the
    area under the curve (for instance, to evaluate the performance of a model with
    the ROC curve, or to calculate probability from densities.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分是数学的一个分支，提供了研究函数变化率的工具，通过两个主要领域：导数和积分。在机器学习和数据科学的背景下，你可能会使用积分来计算曲线下的面积（例如，评估模型性能的ROC曲线，或从密度计算概率）。
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our Top 3 Course Recommendations
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的前三大课程推荐
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity)
    - 快速进入网络安全职业。'
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics)
    - 提升你的数据分析能力'
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport)
    - 支持你的组织的 IT'
- en: '* * *'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In this article, you’ll learn about integrals and the area under the curve using
    the practical data science example of the area under the ROC curve used to compare
    the performances of two machine learning models. Building from this example, you’ll
    see the notion of the area under the curve and integrals from a mathematical point
    of view (from my book Essential Math for Data Science).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，你将了解积分和曲线下的面积，使用实际数据科学的例子——ROC曲线下的面积，用于比较两个机器学习模型的性能。基于这个例子，你将从数学的角度了解曲线下的面积和积分（来自我的书《数据科学中的基本数学》）。
- en: Practical Project
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践项目
- en: Let’s say that you would like to predict the quality of wines from various of
    their chemical properties. You want to do a binary classification of the quality
    (distinguishing very good wines from not very good ones). You’ll develop methods
    allowing you to evaluate your models considering imbalanced data with the area
    under the Receiver Operating Characteristics (ROC) curve.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望通过各种化学性质来预测酒的质量。你想对质量进行二元分类（区分非常好的酒和不是很好的酒）。你将开发方法来评估你的模型，考虑到数据不平衡的情况，并使用接收者操作特征（ROC）曲线下的面积。
- en: '**Dataset**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据集**'
- en: 'To do this, we’ll use a dataset showing various chemical properties of red
    wines and ratings of their quality. The dataset comes from here: https://archive.ics.uci.edu/ml/datasets/wine+quality.
    The related paper is Cortez, Paulo, et al. ”Modeling wine preferences by data
    mining from physicochemical properties.” Decision Support Systems 47.4 (2009):
    547-553.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '为了实现这一目标，我们将使用一个展示红酒各种化学性质及其质量评级的数据集。数据集来自这里：[https://archive.ics.uci.edu/ml/datasets/wine+quality](https://archive.ics.uci.edu/ml/datasets/wine+quality)。相关论文是Cortez,
    Paulo等人的“通过从物理化学性质数据挖掘建模酒品偏好。”《决策支持系统》47.4 (2009): 547-553。'
- en: '![Figure](../Images/622f9846821726cb0886d511fd86d51c.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图示](../Images/622f9846821726cb0886d511fd86d51c.png)'
- en: '*Figure 1: Illustration of wine quality modeling.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1：酒品质量建模的示意图。*'
- en: 'As illustrated in Figure 1, the dataset represents chemical analyses of wines
    (the features) and ratings of their quality. This rating is the target: this is
    what you’ll try to estimate.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如图1所示，数据集表示了酒的化学分析（特征）和质量评级。这个评级是目标：这是你将尝试估计的内容。
- en: 'First, let’s load the data and have a look at the features:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们加载数据并查看特征：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last column `quality` is important as you’ll use it as the target of your
    classification. The quality is described by ratings from 3 to 8:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一列`quality`很重要，因为你将其用作分类的目标。质量由3到8的评分描述：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the goal is to classify red wines of *very good* quality, let’s decide
    that the wines are very good when ratings are 7 or 8 and not very good otherwise.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标是对*非常好*的红酒进行分类，让我们决定当评分为7或8时酒是非常好的，否则不是非常好。
- en: Let’s create the dataset with `y` being the quality (the dependent variable,
    0 for ratings less than 7 and 1 for ratings greater than or equal 7) and `X` containing
    all the other features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数据集，其中`y`是质量（因变量，0表示评分低于7，1表示评分等于或高于7），`X`包含所有其他特征。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing to do, before looking at the data, is to split it in a part
    for training your algorithms (the training set) and a part for testing them (the
    test set). This will allow you to evaluate the performance of your model on data
    unseen during the training.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在查看数据之前，你需要将数据分为一部分用于训练你的算法（训练集）和一部分用于测试它们（测试集）。这将允许你评估模型在训练过程中未见过的数据上的表现。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Preprocessing**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**预处理**'
- en: As a first step, let’s standardize the data to help the convergence of the algorithm.
    You can use the class `StandardScaler` from Sklearn.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对数据进行标准化，以帮助算法的收敛。你可以使用Sklearn中的`StandardScaler`类。
- en: Note that you don’t want to consider the data from the test set to do the standardization.
    The method `fit_transform()` calculates the parameters needed for the standardization
    and apply it at the same time. Then, you can apply the same standardization to
    the test set without fitting again.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不希望使用测试集的数据来进行标准化。`fit_transform()`方法计算标准化所需的参数并同时应用。然后，你可以将相同的标准化应用于测试集而无需重新拟合。
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**First Model**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一个模型**'
- en: 'As a first model, let’s train a logistic regression on the training set and
    calculate the classification accuracy (the percentage of correct classifications)
    on the test set:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个模型，我们在训练集上训练一个逻辑回归模型，并计算测试集上的分类准确率（正确分类的百分比）：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The accuracy is about 0.87, meaning that 87% of the test examples have been
    correctly classified. Should you be happy with this result?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 准确率大约为0.87，这意味着87%的测试样本被正确分类。你对此结果满意吗？
- en: Metrics for Imbalanced Datasets
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不平衡数据集的指标
- en: '**Imbalanced Dataset**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**不平衡数据集**'
- en: 'Since we separated the data into very good wines and not very good wines, the
    dataset is *imbalanced*: there are different quantities of data corresponding
    to each target class.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将数据分为非常好的酒和不是非常好的酒，因此数据集是*不平衡的*：每个目标类别的数据量不同。
- en: 'Let’s check how many observations you have in the negative (not very good wines)
    and positive classes (very good wines):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下你在负类（不是很好酒）和正类（非常好酒）中有多少观察值：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It shows that there are around 86.5% of the examples corresponding to class
    0 and 13.5% to class 1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明大约86.5%的样本对应于类别0，13.5%对应于类别1。
- en: '**Simple Model**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单模型**'
- en: To illustrate this point about accuracy and imbalanced datasets, let’s creates
    a model as a baseline and look at its performance. It will help you to see the
    advantages to use other metrics than accuracy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明准确率和不平衡数据集的问题，我们创建一个模型作为基准，并查看其表现。这将帮助你了解使用其他指标的优势。
- en: A very simple model using the fact that the dataset is imbalanced would always
    estimate the class with the largest number of observations. In your case, such
    a model would always estimate that all wines are bad and get a decent accuracy
    doing that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的模型使用数据集不平衡的事实，会始终估计观察数量最多的类别。在你的情况下，这样的模型会始终估计所有酒都是坏的，并获得不错的准确率。
- en: Let’s simulate this model by creating random probabilities below 0.5 (for instance,
    a probability of 0.15 means that there is a 15% chance that the class is positive).
    We need these probabilities to calculate both the accuracy and other metrics.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建低于0.5的随机概率来模拟这个模型（例如，0.15的概率意味着该类别有15%的可能性是正类）。我们需要这些概率来计算准确率和其他指标。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s say that if the probability is above 0.5, the class is estimated as positive:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当概率超过0.5时，类别被估计为正类：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The variable `y_pred_random` contains only zeros. Let’s evaluate the accuracy
    of this random model:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`y_pred_random`仅包含零。让我们评估这个随机模型的准确率：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This shows that, even with a random model, the accuracy is not bad at all:
    it doesn’t mean that the model is good.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，即使是随机模型，准确率也并不差：这并不意味着模型是好的。
- en: To summarize, having a different number of observations corresponding to each
    class, you can’t rely on the accuracy to evaluate your model’s performance. In
    our example, the model could output only zeros and you would get around 86% accuracy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当每个类别的观察数量不同的时候，你不能仅依赖准确率来评估模型的性能。在我们的例子中，模型可能只输出零，你会得到大约86%的准确率。
- en: You need other metrics to assess the performance of models with imbalanced datasets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要其他指标来评估具有不平衡数据集的模型性能。
- en: '**ROC Curves**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROC曲线**'
- en: 'A good alternative to the accuracy is the Receiver Operating Characteristics
    (ROC) curve. You can check the very good explanations of Aurélien Géron about
    ROC curves in Géron, Aurélien. Hands-on machine learning with Scikit-Learn, Keras,
    and TensorFlow: Concepts, tools, and techniques to build intelligent systems.
    O’Reilly Media, 2019.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '准确率的一个良好替代是接收者操作特征（ROC）曲线。你可以查看Aurélien Géron在《Hands-on machine learning with
    Scikit-Learn, Keras, and TensorFlow: Concepts, tools, and techniques to build
    intelligent systems》中的非常好的ROC曲线解释。O''Reilly Media，2019。'
- en: 'The main idea is to separate the estimations from the model into four categories:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是将模型的估计分为四类：
- en: 'The true positives (TP): the prediction is 1 and the true class is 1.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正的正例（TP）：预测为1，真实类别为1。
- en: 'The false positives (FP): the prediction is 1 but the true class is 0.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚假正例（FP）：预测为1，但真实类别为0。
- en: 'The true negatives (TN): the prediction is 0 and the true class is 0.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正的负例（TN）：预测为0，真实类别为0。
- en: 'The false negatives (FN): the prediction is 0 but the true class is 1.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚假负例（FN）：预测为0，但真实类别为1。
- en: 'Let’s calculate these values for your first logistic regression model. You
    can use the function `confusion_matrix` from Sklearn. It presents a table organized
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算这些值以便用于你的第一个逻辑回归模型。你可以使用Sklearn中的`confusion_matrix`函数。它呈现的表格组织如下：
- en: '![Figure](../Images/3da6c540c32f461e174300a202c16a44.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/3da6c540c32f461e174300a202c16a44.png)'
- en: '*Figure 2: Illustration of a confusion matrix.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2：混淆矩阵的示例。*'
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see that there is no positive observation that has been correctly classified
    (TP) with the random model.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，没有任何正例被随机模型正确分类（TP）。
- en: '**Decision Threshold**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**决策阈值**'
- en: In classification tasks, you want to estimate the class of data samples. For
    models like logistic regression which outputs probabilities between 0 and 1, you
    need to convert this score to the class 0 or 1 using a *decision threshold*, or
    just *threshold*. A probability above the threshold is considered as a positive
    class. For instance, using the default choice of the decision threshold at 0.5,
    you consider that the estimated class is 1 when the model outputs a score above
    0.5.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在分类任务中，你想估计数据样本的类别。对于像逻辑回归这样的模型，它输出0到1之间的概率，你需要使用*决策阈值*或仅*阈值*将此分数转换为类别0或1。高于阈值的概率被视为正类。例如，使用默认的决策阈值0.5，当模型输出分数高于0.5时，你认为估计的类别为1。
- en: However, you can choose other thresholds, and the metrics you use to evaluate
    the performance of your model will depend on this threshold.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以选择其他阈值，你用来评估模型性能的指标将取决于这个阈值。
- en: With the ROC curve, you consider multiple thresholds between 0 and 1 and calculate
    the true positive rate as a function of the false positive rate for each of them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ROC曲线，你会考虑0到1之间的多个阈值，并计算每个阈值下的真正正例率作为虚假正例率的函数。
- en: You can use the function `roc_curve` from Sklearn to calculate the false positive
    rate (fpr) and the true positive rate (tpr). The function outputs also the corresponding
    thresholds. Let’s try it with our simulated random model where outputs are only
    values bellow 0.5 (`y_pred_random_proba`).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Sklearn中的`roc_curve`函数来计算虚假正例率（fpr）和真正正例率（tpr）。该函数还输出对应的阈值。让我们尝试用我们的模拟随机模型进行计算，其中输出值仅低于0.5（`y_pred_random_proba`）。
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s have a look at the outputs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下输出：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can now plot the ROC curve from these values:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以从这些值绘制ROC曲线：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Figure](../Images/0551fd39a886a7516aa8de613be795ad.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/0551fd39a886a7516aa8de613be795ad.png)'
- en: '*Figure 3: ROC curve corresponding to the random model.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3：对应随机模型的ROC曲线。*'
- en: Figure 3 shows the ROC curve corresponding to the random model. It gives you
    the true positive rate as a function of the false positive rate for each threshold.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3 显示了随机模型对应的 ROC 曲线。它给出了每个阈值下假阳性率的函数的真实正例率。
- en: 'However, be careful, the thresholds are from 1 to 0\. For instance, the point
    at the bottom left corresponds to a threshold of 1: there is 0 true positive and
    0 false positive because it is not possible to have a probability above 1, so
    with a threshold of 1, no observation can be categorized as positive. At the top
    right, the threshold is 0, so all observations are categorized as positive, leading
    to 100% of true positive but also 100% of false positive.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要小心，阈值范围是从 1 到 0。例如，左下角的点对应于阈值为 1：真实正例为 0，假阳性为 0，因为不可能有高于 1 的概率，所以阈值为 1 时，没有观察值可以被分类为正例。在右上角，阈值为
    0，因此所有观察值都被分类为正例，这导致 100% 的真实正例，但也有 100% 的假阳性。
- en: A ROC curve around the diagonal means that the model is not better than random
    which is the case here. A perfect model would be associated with a ROC curve with
    a true positive rate of 1 for all values of false positive rate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对角线附近的 ROC 曲线意味着模型表现不比随机模型更好，这正是这里的情况。一个完美的模型会对应一个 ROC 曲线，其真实正例率在所有假阳性率值下都是
    1。
- en: 'Let’s now look at the ROC curve corresponding to the logistic regression model
    you trained earlier. You’ll need probabilities from the model, that you can get
    using `predict_proba()` instead of `predict`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下你之前训练的逻辑回归模型对应的 ROC 曲线。你需要从模型中获取概率，可以使用`predict_proba()`代替`predict`来获得：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first column is the score for the class 0 and the second column for the
    score 1 (thus, the total of each row is 1), so you can keep the second column
    only.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是类别 0 的分数，第二列是类别 1 的分数（因此，每行的总和为 1），所以你只需保留第二列。
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Figure](../Images/e3c42300bd0d64dc35a743fc87c27ab1.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/e3c42300bd0d64dc35a743fc87c27ab1.png)'
- en: '*Figure 4: ROC curve corresponding to the logistic model.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4：对应于逻辑回归模型的 ROC 曲线。*'
- en: 'You can see in Figure 4 that your model is actually better than a random model,
    which is not something you were able to know from the model accuracies (they were
    equivalent: around 0.86 for the random model and 0.87 for your model).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 4 中看到你的模型实际上比随机模型更好，这是你无法从模型准确性中得知的（它们是等效的：随机模型约为 0.86，你的模型约为 0.87）。
- en: Visual inspection is good, but it would also be crucial to have a single numerical
    metric to compare your models. This is usually provided by the area under the
    ROC curve. You’ll see what is the area under the curve and how you can calculate
    in the next sections.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉检查是好的，但拥有一个单一的数值指标来比较你的模型也很重要。这通常由 ROC 曲线下的面积提供。你将在接下来的部分中了解曲线下的面积及其计算方法。
- en: Integrals
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 积分
- en: '*Integration* is the inverse operation of differentiation. Take a function *f(x)* and
    calculate its derivative *f′(x)*, the *indefinite integral* (also called *antiderivative*)
    of *f′(x)* gives you back *f(x)* (up to a constant, as you’ll soon see).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*积分*是微分的逆操作。取一个函数*f(x)*并计算其导数*f′(x)*，*不定积分*（也称为*原函数*）给你回到*f(x)*（到一个常数，如你很快将看到的）。'
- en: You can use integration to calculate the *area under the curve*, which is the
    area of the shape delimited by the function, as shown in Figure 5.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用积分来计算*曲线下的面积*，即由函数限定的形状的面积，如图 5 所示。
- en: '![Figure](../Images/f07a129e494d5752224664b14379ba83.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/f07a129e494d5752224664b14379ba83.png)'
- en: '*Figure 5: Area under the curve.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5：曲线下的面积。*'
- en: A *definite integral* is the integral over a specific interval. It corresponds
    to the area under the curve in this interval.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*确定积分*是指在特定区间上的积分。它对应于该区间内曲线下的面积。'
- en: Example
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: You’ll see through this example how to understand the relationship between the
    integral of a function and the area under the curve. To illustrate the process,
    you’ll approximate the integral of the function *g(x)=2x* using a discretization
    of the area under the curve.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过这个示例了解函数积分与曲线下的面积之间的关系。为了说明这个过程，你将通过离散化曲线下的面积来近似计算函数*g(x)=2x*的积分。
- en: '**Example Description**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例说明**'
- en: Let’s take again the example of the moving train. You saw that speed as a function
    of time was the derivative of distance as a function of time. These functions
    are represented in Figure 6.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次以移动火车为例。你看到速度作为时间的函数是距离作为时间的函数的导数。这些函数在图 6 中表示。
- en: '![Figure](../Images/3111fddbf419701aa8e167755e97a86c.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/3111fddbf419701aa8e167755e97a86c.png)'
- en: '*Figure 6: The left panel shows *f(x)* which is the distance as a function
    of time, and the right panel its derivative *g(x)*, which is the speed as a function
    of time.*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6：左侧面板显示了*f(x)*，它是时间的函数，表示距离，而右侧面板显示了其导数*g(x)*，它是时间的函数，表示速度。*'
- en: The function shown in the left panel of Figure 6 is defined as *f(x)=x²*. Its
    derivative is defined as *g(x)=2x*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6左侧面板中显示的函数定义为*f(x)=x²*。其导数定义为*g(x)=2x*。
- en: In this example, you’ll learn how to find an approximation of the area under
    the curve of *g(x)*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将学习如何找到*g(x)*曲线下面积的近似值。
- en: '**Slicing the Function**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**切片函数**'
- en: 'To approximate the area of a shape, you can use the slicing method: you cut
    the shape into small slices with an easy shape like rectangles, calculate the
    area of each of these slices and sum them.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要近似一个形状的面积，你可以使用切片方法：将形状切分成像矩形这样的简单形状的小切片，计算每个切片的面积并求和。
- en: You’ll do exactly that to find an approximation of the area under the curve
    of *g(x)*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将做 exactly 以找到*g(x)*曲线下面积的近似值。
- en: '![Figure](../Images/1908cc700b096a7ac86f4da2dd4fb59c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/1908cc700b096a7ac86f4da2dd4fb59c.png)'
- en: '*Figure 7: Approximation of the area under the curve by discretizing the area
    under the curve of speed as a function of time.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7：通过离散化速度对时间的函数曲线下的面积来近似曲线下的面积。*'
- en: Figure 7 shows the area under the curve of *f′(x)* sliced as one-second rectangles
    (let’s call this difference *Δx*). Note that we underestimate the area (look at
    the missing triangles), but we’ll fix that later.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7展示了* f′(x) *的曲线下面积被切分为一秒钟的矩形（我们称之为*Δx*）。请注意，我们低估了面积（看一下遗漏的三角形），但我们稍后会修正这个问题。
- en: 'Let’s try to understand the meaning of the slices. Take the first one: its
    area is defined as 2⋅12⋅1\. The height of the slice is the speed at one second
    (the value is 2). So there are two units of speed by one unit of time for this
    first slice. The area corresponds to a multiplication between speed and time:
    this is a distance.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解切片的含义。以第一个为例：它的面积定义为2⋅12⋅1。切片的高度是某一秒钟的速度（值为2）。因此，第一个切片中有两个速度单位对应一个时间单位。面积对应于速度与时间的乘积：这就是距离。
- en: 'For instance, if you drive at 50 miles per hour (speed) for two hours (time),
    you traveled *50⋅2=100 miles* (distance). This is because the unit of speed corresponds
    to a ratio between distance and time (like miles *per* hour). You get:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你以每小时50英里（速度）行驶两个小时（时间），你行驶了*50⋅2=100英里*（距离）。这是因为速度的单位对应于距离与时间之间的比例（例如每小时英里）。你得到：
- en: '![Image](../Images/215aa2a2d5a353ae41f3c673251339f1.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/215aa2a2d5a353ae41f3c673251339f1.png)'
- en: To summarize, the derivative of the distance by time function is the speed by
    time function, and the area under the curve of the speed by time function (its
    integral) gives you a distance. This is how derivatives and integrals are related.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，距离与时间函数的导数是速度与时间函数，而速度与时间函数下的曲线下面积（其积分）给出的是一个距离。这就是导数和积分之间的关系。
- en: '**Implementation**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现**'
- en: 'Let’s use slicing to approximate the integral of the function *g(x)=2x*. First,
    let’s define the function *g(x)*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用切片法来近似* g(x)=2x *的函数的积分。首先，让我们定义函数* g(x)*：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As illustrated in Figure 7, you’ll consider that the function is discrete and
    take a step of *Δx=1*. You can create an *x*-axis with values from zero to six,
    and apply the function `g_2x()` for each of these values. You can use the Numpy
    method `arange(start, stop, step)` to create an array filled with values from `start` to `stop` (not
    included):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7所示，你将考虑函数是离散的，并采取*Δx=1*的步长。你可以创建一个从零到六的*x*轴，并对这些值应用函数`g_2x()`。你可以使用Numpy方法`arange(start,
    stop, step)`来创建一个从`start`到`stop`（不包括）的值数组：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can then calculate the slice’s areas by iterating and multiplying the width
    (*Δx*) by the height (the value of *y* at this point). of the slice. As you saw,
    this area (`delta_x * y[i-1]` in the code below) corresponds to a distance (the
    distance of the moving train traveled during the *i*th slice). You can finally
    append the results to an array (`slice_area_all` in the code below).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过迭代并将宽度（*Δx*）与高度（此时的*y*值）相乘来计算切片的面积。正如你所见，这个面积（下方代码中的`delta_x * y[i-1]`）对应于一个距离（移动的火车在第*i*个切片中行驶的距离）。最后，你可以将结果附加到一个数组中（下方代码中的`slice_area_all`）。
- en: Note that the index of `y` is `i-1` because the rectangle is on the left of
    the *x* value we estimate. For instance, the area is zero for *x=0* and *x=1*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`y`的索引是`i-1`，因为矩形在我们估算的*x*值的左侧。例如，对于*x=0*和*x=1*，面积为零。
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These values are the slice’s areas.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是切片的面积。
- en: 'To calculate the distance traveled from the beginning to the corresponding
    time point (and not corresponding to each slice), you can calculate the cumulative
    sum of `slice_area_all` with the Numpy function `cumsum()`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算从开始到相应时间点的行程（而不是每个切片的相应时间点），你可以使用Numpy函数`cumsum()`计算`slice_area_all`的累计和：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is the estimated values of the area under the curve of *g(x)* as a function
    of *x*. We know that the function *g(x)* is the derivative of *f(x)=x²*, so we
    should get back *f(x)* by the integration of *g(x)*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*g(x)*在*x*下的曲线下的面积的估计值。我们知道*g(x)*是*f(x)=x²*的导数，所以我们应该通过对*g(x)*的积分得到*f(x)*。
- en: 'Let’s plot our estimation and f(x)f(x), which we’ll call the “true function”,
    to compare them:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制我们的估计值和*f(x)*，我们称之为“真实函数”，以进行比较：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Figure](../Images/7d1175a378bc8901953ffa92884e9a31.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/7d1175a378bc8901953ffa92884e9a31.png)'
- en: '*Figure 8: Comparison of estimated and original function.*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8：估计函数与原始函数的比较。*'
- en: The estimation represented in Figure 8 shows that the estimation is not bad,
    but could be improved. This is because we missed all these triangles represented
    in red in Figure
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8中显示的估计结果表明，估计并不差，但还可以改进。这是因为我们错过了图中红色表示的所有这些三角形。
- en: One way to reduce the error is to take a smaller value for ΔxΔx, as illustrated
    in the right panel in Figure 9.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少误差的一种方法是取较小的*Δx*值，如图9右侧面板所示。
- en: '![Figure](../Images/ac06608555a71e705993b2faafb6a93e.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/ac06608555a71e705993b2faafb6a93e.png)'
- en: '*Figure 9: Missing parts in slices of the speed function (in red). The error
    is smaller with a smaller *Δx*.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9：速度函数的切片中缺失的部分（以红色标出）。随着*Δx*的减小，误差也变小。*'
- en: 'Let’s estimate the integral function with *Δx=0.1*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用*Δx=0.1*来估计积分函数：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Figure](../Images/eb7532de963fc9ab64b708791ecd6004.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/eb7532de963fc9ab64b708791ecd6004.png)'
- en: '*Figure 10: Smaller slice widths lead to a better estimation of the original
    function.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10：较小的切片宽度可以更好地估计原始函数。*'
- en: As shown in Figure 10, we recovered (at least, up to an additive constant) the
    original function whose derivative we integrated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如图10所示，我们恢复了（至少，考虑到一个附加常数）我们所积分的原始函数的导数。
- en: '**Extension**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展**'
- en: In our previous example, you integrated the function *2x*, which is a linear
    function, but the principle is the same for any continuous function (see Figure
    11 for instance).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，你对函数*2x*进行了积分，这个函数是线性的，但对于任何连续函数原理是相同的（例如，见图11）。
- en: '![Figure](../Images/baae33f15e4740d3b6e55eb126e4e935.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/baae33f15e4740d3b6e55eb126e4e935.png)'
- en: '*Figure 11: The slicing method can be used with many linear or nonlinear function,
    including all continuous functions.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11：切片方法可以用于许多线性或非线性函数，包括所有连续函数。*'
- en: Riemann Sum
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Riemann和
- en: Approximating an integral using this slicing method is called a *Riemann sum*.
    Riemann sums can be calculated in different ways, as you can see in Figure 12.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种切片方法来近似积分被称为*Riemann和*。Riemann和可以通过不同的方式计算，如图12所示。
- en: '![Figure](../Images/479e0604f9d8c94823f9a2b6ebf7a091.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/479e0604f9d8c94823f9a2b6ebf7a091.png)'
- en: '*Figure 12: Four kinds of Riemann sums for integral approximation.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12：用于积分近似的四种Riemann和。*'
- en: As pictured in Figure 12, with the left Riemann sum, the curve is aligned with
    the left corner of the rectangle. With the right Riemann sum, the curve is aligned
    with the right corner of the rectangle. With the midpoint rule, the curve is aligned
    with the center of the rectangle. With the trapezoidal rule, a trapezoidal shape
    is used instead of a rectangle. The curve crosses both top corners of the trapezoid.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如图12所示，左Riemann和使曲线与矩形的左角对齐。右Riemann和使曲线与矩形的右角对齐。中点规则使曲线与矩形的中心对齐。梯形规则则使用梯形代替矩形。曲线穿过梯形的两个顶角。
- en: Mathematical Definition
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学定义
- en: In the last section, you saw the relationship between the area under the curve
    and integration (you got back the original function from the derivative). Let’s
    see now the mathematical definition of integrals.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到了曲线下的面积与积分之间的关系（你从导数中恢复了原始函数）。现在让我们来看一下积分的数学定义。
- en: 'The integrals of the function *f(x)* with respect to *x* is denoted as following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对函数*f(x)*相对于*x*的积分表示如下：
- en: '*∫f(x)dx*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*∫f(x)dx*'
- en: The symbol *dx* is called the *differential* of *x* and refers to the idea of
    an infinitesimal change of *x*. It is a difference in *x* that approaches 0\.
    The main idea of integrals is to sum an infinite number of slices which have an
    infinitely small width.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 符号*dx*被称为*x*的*微分*，表示*x*的一个无穷小的变化。它是*x*中接近0的差异。积分的主要思想是对宽度无穷小的无限多个切片进行求和。
- en: The symbol *∫* is the integral sign and refers to the sum of an infinite number
    of slices.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 符号*∫*是积分符号，表示无限多个切片的总和。
- en: The height of each slice is the value *f(x)*. The multiplication of *f(x)* and *dx* is
    thus the area of each slice. Finally, *∫f(x):dx* is the sum of the slice areas
    over an infinite number of slices (the width of the slices tending to zero). This
    is the *area under the curve*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个切片的高度是 *f(x)*。因此， *f(x)* 和 *dx* 的乘积就是每个切片的面积。最后， *∫f(x):dx* 是对无限多个切片的面积求和（切片的宽度趋向于零）。这就是*曲线下的面积*。
- en: 'You saw in the last section how to approximate function integrals. But if you
    know the derivative of a function, you can retrieve the integral knowing that
    it is the inverse operation. For example, if you know that:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一节中看到如何近似函数积分。但是如果你知道一个函数的导数，你可以通过知道它是逆操作来找回积分。例如，如果你知道：
- en: '*d(x2)dx=2x*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*d(x2)dx=2x*'
- en: You can conclude that the integral of *2x* is *x2*. However, there is a problem.
    If you add a constant to our function the derivative is the same because the derivative
    of a constant is zero. For instance,
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以得出结论，*2x*的积分是*x2*。但是，有一个问题。如果你在我们的函数中添加一个常数，导数是一样的，因为常数的导数为零。例如，
- en: '*d(x²+3)dx=2x*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*d(x²+3)dx=2x*'
- en: 'It is impossible to know the value of the constant. For this reason, you need
    to add an unknown constant to the expression, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能知道常数的值。因此，你需要在表达式中添加一个未知常数，如下：
- en: '*∫2xdx=x²+c*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*∫2xdx=x²+c*'
- en: with cc being a constant.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 cc 是一个常数。
- en: '**Definite Integrals**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**定积分**'
- en: 'In the case of *definite integrals*, you denote the interval of integration
    with numbers below and above the integral symbol, as following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在*定积分*的情况下，你可以用积分符号下方和上方的数字来表示积分的区间，如下所示：
- en: '*∫baf(x)dx*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*∫baf(x)dx*'
- en: It corresponds to the area under the curve of the function *f(x)* between *x=a* and *x=b*,
    as illustrated in Figure 13.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它对应于函数 *f(x)* 在 *x=a* 和 *x=b* 之间的曲线下的面积，如图13所示。
- en: '![Figure 13: Area under the curve between $x=a$ and $x=b$.](../Images/3449d551c9a611e27e7626847a3037bc.png)*Figure
    13: Area under the curve between *x=a* and *x=b*.*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13：$x=a$ 和 $x=b$ 之间的曲线下的面积。](../Images/3449d551c9a611e27e7626847a3037bc.png)*图13：曲线下的面积在 *x=a* 和 *x=b* 之间。*'
- en: Area Under the ROC Curve
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ROC曲线下的面积
- en: Now that you know how the area under the curve relates to integration, let’s
    see how to calculate it to compare numerically your models.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了曲线下的面积如何与积分相关，让我们看看如何计算它，以便数值上比较你的模型。
- en: 'Remember that you had the ROC curves represented in Figure 14:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你在图14中展示了ROC曲线：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Figure](../Images/00654d9a1a7a07306947b512ebcec2f4.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图](../Images/00654d9a1a7a07306947b512ebcec2f4.png)'
- en: '*Figure 14: ROC curves of the random model (blue) and the logistic regression
    model (green).*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14：随机模型（蓝色）和逻辑回归模型（绿色）的ROC曲线。*'
- en: 'Let’s start with the random model. You want to sum each value of true positive
    rate multiplied by the width on the *x*-axis that is the difference between the
    corresponding value of false positive rate and the one before. You can obtain
    these differences with:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从随机模型开始。你想对每个真实正例率的值乘以*x*轴上宽度的总和，即相应的假正例率与之前的值之间的差异。你可以通过以下方法获得这些差异：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So the area under the ROC curve of the random model is:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 随机模型下ROC曲线下的面积为：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or you can simply use the function `roc_auc_score()` from Sklearn using the
    true target values and the probabilities as input:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以直接使用Sklearn中的`roc_auc_score()`函数，输入真实目标值和概率：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: An area under the ROC curve of 0.5 corresponds to a model that is not better
    than random and an area of 1 corresponds to perfect predictions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ROC曲线下的面积为0.5对应于一个不比随机更好的模型，面积为1则对应于完美预测。
- en: 'Now, let’s compare this value to the area under the ROC curve of your model:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个值与模型的ROC曲线下的面积进行比较：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This shows that your model is actually not bad and your predictions of the quality
    of the wine are not random.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你的模型实际上并不差，你对葡萄酒质量的预测并不是随机的。
- en: In machine learning, you can use a few lines of code to train complex algorithms.
    However, as you saw here, a bit of math can help you to make the most of it and
    speed up your work. It will give you more ease in various aspects of your discipline,
    even, for instance, understanding the documentation of machine learning libraries
    like Sklearn.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，你可以用几行代码来训练复杂的算法。然而，正如你在这里看到的，一些数学知识可以帮助你充分利用这些算法并加快工作进程。它会让你在各个方面都更加得心应手，比如理解机器学习库（如
    Sklearn）的文档。
- en: '**Bio: [Hadrien Jean](https://hadrienj.github.io/)** is a machine learning
    scientist. He owns a Ph.D in cognitive science from the Ecole Normale Superieure,
    Paris, where he did research on auditory perception using behavioral and electrophysiological
    data. He previously worked in industry where he built deep learning pipelines
    for speech processing. At the corner of data science and environment, he works
    on projects about biodiversity assessement using deep learning applied to audio
    recordings. He also periodically creates content and teaches at Le Wagon (data
    science Bootcamp), and writes articles in his blog ([hadrienj.github.io](http://hadrienj.github.io)).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**个人简介：[Hadrien Jean](https://hadrienj.github.io/)** 是一位机器学习科学家。他拥有巴黎高等师范学院的认知科学博士学位，研究了听觉感知，并使用行为学和电生理学数据进行研究。他曾在工业界工作，构建了用于语音处理的深度学习管道。在数据科学与环境交汇的领域，他从事利用深度学习分析音频录音进行生物多样性评估的项目。他还定期在
    Le Wagon（数据科学训练营）创作内容并授课，并在他的博客中撰写文章（[hadrienj.github.io](http://hadrienj.github.io)）。'
- en: '[Original](https://hadrienj.github.io/posts/Essential-Math-Integrals/). Reposted
    with permission.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[原文](https://hadrienj.github.io/posts/Essential-Math-Integrals/)。已获许可转载。'
- en: '**Related:**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关内容：**'
- en: '[Boost your data science skills. Learn linear algebra.](/2018/05/boost-data-science-skills-learn-linear-algebra.html)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提升你的数据科学技能。学习线性代数。](/2018/05/boost-data-science-skills-learn-linear-algebra.html)'
- en: '[Preprocessing for Deep Learning: From covariance matrix to image whitening](/2018/10/preprocessing-deep-learning-covariance-matrix-image-whitening.html)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[深度学习的预处理：从协方差矩阵到图像白化](/2018/10/preprocessing-deep-learning-covariance-matrix-image-whitening.html)'
- en: '[Essential Math for Data Science:  ‘Why’ and ‘How’](/2018/09/essential-math-data-science.html)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学中的基础数学：‘为什么’和‘如何’](/2018/09/essential-math-data-science.html)'
- en: More On This Topic
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多相关内容
- en: '[How To Overcome The Fear of Math and Learn Math For Data Science](https://www.kdnuggets.com/2021/03/overcome-fear-learn-math-data-science.html)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何克服对数学的恐惧并学习数据科学中的数学](https://www.kdnuggets.com/2021/03/overcome-fear-learn-math-data-science.html)'
- en: '[Essential Math for Data Science: Eigenvectors and Application to PCA](https://www.kdnuggets.com/2022/06/essential-math-data-science-eigenvectors-application-pca.html)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学中的基础数学：特征向量及其在 PCA 中的应用](https://www.kdnuggets.com/2022/06/essential-math-data-science-eigenvectors-application-pca.html)'
- en: '[Essential Math for Data Science: Visual Introduction to Singular…](https://www.kdnuggets.com/2022/06/essential-math-data-science-visual-introduction-singular-value-decomposition.html)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学中的基础数学：奇异值分解的视觉介绍](https://www.kdnuggets.com/2022/06/essential-math-data-science-visual-introduction-singular-value-decomposition.html)'
- en: '[How Much Math Do You Need in Data Science?](https://www.kdnuggets.com/2020/06/math-data-science.html)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[你在数据科学中需要多少数学？](https://www.kdnuggets.com/2020/06/math-data-science.html)'
- en: '[5 Free Courses to Master Math for Data Science](https://www.kdnuggets.com/5-free-courses-to-master-math-for-data-science)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5 门免费的课程，掌握数据科学中的数学](https://www.kdnuggets.com/5-free-courses-to-master-math-for-data-science)'
- en: '[5 Free MIT Courses to Learn Math for Data Science](https://www.kdnuggets.com/5-free-mit-courses-to-learn-math-for-data-science)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5 门免费的 MIT 课程，学习数据科学中的数学](https://www.kdnuggets.com/5-free-mit-courses-to-learn-math-for-data-science)'
