- en: Road Lane Line Detection using Computer Vision models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2017/07/road-lane-line-detection-using-computer-vision-models.html](https://www.kdnuggets.com/2017/07/road-lane-line-detection-using-computer-vision-models.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**By Vijay Ramakrishnan**.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting lane lines is a fundamental task for autonomous vehicles while driving
    on the road. It is the building block to other path planning and control actions
    like breaking and steering. Lets get started implementing them!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7a992963ff20ff065c613a4986e26864.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Fig 1\. Final output of this project**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: This project was derived from [Udacity blog](https://github.com/udacity/CarND-LaneLines-P1).
    All media generated used custom CV configurations explained in this article.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Step 0: Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: Before we work with videos, lets work with static images since it is much easier
    to debug with. Here is the image we will be working with.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e8f072f35ceec435a7d0e66babd21c0d.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Fig. Input image***'
  prefs: []
  type: TYPE_NORMAL
- en: 'I am running python 3 with the following imports in a jupyter notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The lane detection pipeline follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-process image using grayscale and gaussian blur
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply canny edge detection to the image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply masking region to the image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply Hough transform to the image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extrapolate the lines found in the hough transform to construct the left and
    right lane lines
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the extrapolated lines to the input image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 1: Pre-processing of image**'
  prefs: []
  type: TYPE_NORMAL
- en: We grayscale the input image which is needed for canny edge detection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3890713a560d8e34476af175fcf028a9.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Fig. Gray-scaled image***'
  prefs: []
  type: TYPE_NORMAL
- en: We then apply a gaussian smoothing function to the image. Again, this is needed
    for the canny edge detection to average out anomalous gradients in the image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 2: Canny Edge Detection**'
  prefs: []
  type: TYPE_NORMAL
- en: We need to detect edges for lane detection since the contrast between the lane
    and the surrounding road surface provides us with useful information on detecting
    the lane lines.
  prefs: []
  type: TYPE_NORMAL
- en: Canny edge detection is an operator that uses the horizontal and vertical gradients
    of the pixel values of an image to detect edges. A more deeper understanding of
    the algorithm can be found [here](http://docs.opencv.org/trunk/da/d22/tutorial_py_canny.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/8e9646d2efb5b21233e6fae0a2961584.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Notice the edge detector captures all the lane lines, along with surrounding
    edges like trees*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Mask out points that are not in the region of interest**'
  prefs: []
  type: TYPE_NORMAL
- en: The region of interest for the car’s camera is only the two lanes immediately
    in it’s field of view and not anything extraneous. We can filter out the extraneous
    pixels by making a polygon region of interest and removing all other pixels that
    are not in the polygon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1fa94ca382f7d5cc7aff7f61ec5738e7.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Fig. Removed all pixels not in the region of interest***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Hough Transform**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have detected edges in the region of interest, we want to identify
    lines which indicate lane lines. This is where the hough transform comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: The Hough transformation converts a “x vs. y” line to a point in “gradient vs.
    intercept” space. Points in the image will correspond to lines in hough space.
    An intersection of lines in hough space will thus correspond to a line in Cartesian
    space. Using this technique, we can find lines from the pixel outputs of the canny
    edge detection output. A detailed explanation of the Hough transformation can
    be found here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[DINOv2: Self-Supervised Computer Vision Models by Meta AI](https://www.kdnuggets.com/2023/05/dinov2-selfsupervised-computer-vision-models-meta-ai.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TensorFlow for Computer Vision - Transfer Learning Made Easy](https://www.kdnuggets.com/2022/01/tensorflow-computer-vision-transfer-learning-made-easy.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Discover the World of Computer Vision: Introducing MLM''s Latest…](https://www.kdnuggets.com/2024/01/mlm-discover-the-world-of-computer-vision-ebook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Applications of Computer Vision](https://www.kdnuggets.com/2022/03/5-applications-computer-vision.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6 Things You Need To Know About Data Management And Why It Matters…](https://www.kdnuggets.com/2022/05/6-things-need-know-data-management-matters-computer-vision.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News March 9, 2022: Build a Machine Learning Web App in 5…](https://www.kdnuggets.com/2022/n10.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
