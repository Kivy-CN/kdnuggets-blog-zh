- en: Vector and Matrix Norms with NumPy Linalg Norm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2023/05/vector-matrix-norms-numpy-linalg-norm.html](https://www.kdnuggets.com/2023/05/vector-matrix-norms-numpy-linalg-norm.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/7358f625af3da5057e3573b28316189d.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '**Num**erical **Py**thon or **NumPy** is a popular library for scientific computing
    in Python. The NumPy library has a huge collection of built-in functionality to
    create n-dimensional arrays and perform computations on them.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in data science, computational linear algebra and related
    fields, learning how to compute vector and matrix norms can be helpful. And this
    tutorial will teach you how to do that using functions from NumPy’s **linalg**
    module.
  prefs: []
  type: TYPE_NORMAL
- en: To code along, you should have Python and NumPy installed in your development
    environment. For the f-strings in the `print()` statements to work without errors,
    you need to have Python 3.8 or a later version installed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: What is a Norm?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this discussion, we’ll first look at vector norms. We’ll get to matrix norms
    later. Mathematically, a norm is a function (or a mapping) from an n-dimensional
    vector space to the set of real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/5711822e157bdce711d26c52e5b9c19f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Note**: Norms are also defined on complex vector spaces **C^n → R** is a
    valid definition of norm, too. But we’ll restrict ourselves to the vector space
    of real numbers in this discussion.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Properties of Norms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For an n-dimensional vector **x** = (x1,x2,x3,...,xn), the norm of **x**, commonly
    denoted by ||**x**||, should satisfy the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '||**x**|| is a **non-negative** quantity. For a vector **x**, the norm ||**x**||
    is always greater than or equal to zero. And ||**x**|| is equal to zero if and
    only if the vector **x** is the vector of all zeros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For two vectors **x** = (x1,x2,x3,...,xn) and **y** = (y1,y2,y3,...,yn), their
    norms ||**x**|| and ||**y**|| should satisfy the **triangle inequality**: ||**x**
    + **y**|| <= ||**x**|| + ||**y**||.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, all norms satisfy ||α**x**|| = |α| ||**x**|| for a scalar α.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common Vector Norms: L1, L2, and L∞ Norms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, the Lp norm (or p-norm) of an n-dimensional vector **x** = (x1,x2,x3,...,xn)
    for p >= 0 is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/949698ab0104ea8f6bd3bbf5d3c5be9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s take a look at the common vector norms, namely, the L1, L2 and L∞ norms.
  prefs: []
  type: TYPE_NORMAL
- en: L1 Norm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The L1 norm is equal to the sum of the absolute values of elements in the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/334e1ceeaed5cb565d25ead443da73aa.png)'
  prefs: []
  type: TYPE_IMG
- en: L2 Norm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Substituting p =2 in the general Lp norm equation, we get the following expression
    for the L2 norm of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/d072dbf3fd7da9f6804c893cc25d497c.png)'
  prefs: []
  type: TYPE_IMG
- en: L∞ norm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a given vector **x**, the L∞ norm is the **maximum** of the *absolute*
    values of the elements of **x**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/db19cf650980003b693f8bcb9f0018ae.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s fairly straightforward to verify that all of these norms satisfy the properties
    of norms listed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: How to Compute Vector Norms in NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **linalg** module in NumPy has functions that we can use to compute norms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, let’s initialize a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: L2 Norm in NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s import the **linalg** module from NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `norm()` function to compute both matrix and vector norms. This function
    takes in a required parameter – the vector or matrix for which we need to compute
    the norm. In addition, it takes in the following *optional* parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ord` that decides the order of the norm computed, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`axis` that specifies the axis along which the norm is to be computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we don’t specify the `ord` in the function call, the `norm()` function
    computes the L2 norm by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify this by explicitly setting `ord` to 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: L1 Norm in NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To calculate the L1 norm of the vector, call the `norm()` function with `ord
    = 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As our examples `vector` contains only positive numbers, we can verify that
    L1 norm in this case is equal to the sum of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: L∞ Norm in NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compute the  L∞ norm, set `ord` to ''np.inf'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we get 6, the *maximum* element (in the absolute sense) in
    the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the `norm()` function, you can also set `ord` to '-np.inf'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have guessed, negative  L∞ norm returns the *minimum* element (in
    the absolute sense) in the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A Note on L0 Norm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The L0 norm gives the number of non-zero elements in the vector. Technically,
    it is not a norm. Rather it’s a pseudo norm given that it violates the property
    ||α**x**|| = |α| ||**x**||. This is because the number of non-zero elements *remains
    the same* even if the vector is multiplied by a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the number of non-zero elements in a vector, set `ord` to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `another_vector` has 3 non-zero elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Matrix Norms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have seen how to compute vector norms. Just the way you can think
    of vector norms as mappings from an n-dimensional vector space onto the set of
    real numbers, matrix norms are a mapping from an m x n matrix space to the set
    of real numbers. Mathematically, you can represent this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/b90c3f12b0aaa8fe9441d83fe3429480.png)'
  prefs: []
  type: TYPE_IMG
- en: Common matrix norms include the Frobenius and nuclear norms.
  prefs: []
  type: TYPE_NORMAL
- en: Frobenius Norm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For an m x n matrix A with m rows and n columns, the Frobenius norm is given
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/4f935b1f8583c4049e446e54a978b487.png)'
  prefs: []
  type: TYPE_IMG
- en: Nuclear Norm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Singular value decomposition or SVD is a matrix factorization technique used
    in applications such as topic modeling, image compression, and collaborative filtering.
  prefs: []
  type: TYPE_NORMAL
- en: SVD factorizes an input matrix into a matrix of a matrix of left singular vectors
    (U), a matrix of singular values (S), and a matrix of right singular vectors (V_T).
    And the nuclear norm is the largest singular value of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/65222385d97e70b2b4f9310c4fb704c1.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Compute Matrix Norms in NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To continue our discussion on computing matrix norms in NumPy, let’s reshape
    `vector` to a 2 x 3 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Matrix Frobenius Norm in NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do not specify the `ord` parameter, the `norm()` function, by default,
    calculates the Frobenius norm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s verify this by setting `ord` to `''fro''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we don’t pass in the optional `ord` parameter, we get the Frobenius norm,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To sum up, when the `norm()` function is called with a matrix as the input,
    it returns the Frobenius norm of the matrix by default.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Nuclear Norm in NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To calculate the nuclear norm of a matrix, you can pass in the matrix and set
    `ord` to ''nuc'' in the `norm()` function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Matrix Norms Along a Specific Axis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We generally do not compute L1 and L2 norms on matrices, but NumPy lets you
    compute norms of any `ord` on matrices (2D-arrays) and other multi-dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to compute the L1 norm of a matrix along a specific axis – along
    the rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can set `axis = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`axis = 0` denotes the rows of a matrix. If you set `axis = 0`, the L1 norm
    of the matrix is calculated **across the rows** (or along the columns), as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/6c64acb724eb702509298b4bb66ac0fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s verify this in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can set `axis = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`axis = 1` denotes the columns of a matrix. So the computation of the L1 norm
    of the matrix by setting `axis = 1` is **across the columns** (along the rows).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector and Matrix Norms with NumPy Linalg Norm](../Images/ba423c79ba54c08deb408fe0fc13979f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: I suggest that you play around with the `ord` and `axis` parameters on and try
    with different matrices until you get the hang of it.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you now understand how to compute vector and matrix norms using NumPy.
    It’s important, however, to note that the Frobenius and nuclear norms are defined
    only for matrices. So if you compute for vectors or multidimensional arrays with
    more than two dimensions, you’ll run into errors. That's all for this tutorial!
  prefs: []
  type: TYPE_NORMAL
- en: '**[Bala Priya C](https://www.linkedin.com/in/bala-priya/)** is a technical
    writer who enjoys creating long-form content. Her areas of interest include math,
    programming, and data science. She shares her learning with the developer community
    by authoring tutorials, how-to guides, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Python Vector Databases and Vector Indexes: Architecting LLM Apps](https://www.kdnuggets.com/2023/08/python-vector-databases-vector-indexes-architecting-llm-apps.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Perform Matrix Operations with NumPy](https://www.kdnuggets.com/how-to-perform-matrix-operations-with-numpy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Idiot''s Guide to Precision, Recall, and Confusion Matrix](https://www.kdnuggets.com/2020/01/guide-precision-recall-confusion-matrix.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Confusion Matrix, Precision, and Recall Explained](https://www.kdnuggets.com/2022/11/confusion-matrix-precision-recall-explained.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News, November 16: How LinkedIn Uses Machine Learning •…](https://www.kdnuggets.com/2022/n45.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vector Databases in AI and LLM Use Cases](https://www.kdnuggets.com/vector-databases-in-ai-and-llm-use-cases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
