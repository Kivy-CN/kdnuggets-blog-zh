["```py\nimport layer\nlayer.login()\nlayer.init(\"predictingCryptoPrices\")\n```", "```py\n@dataset(\"bitcoin\")\n@resources(path=\"./data\")\ndef getBitcoinData():\n    return pd.read_csv(\"data/bitcoin.csv\")\n\nlayer.run([getBitcoinData])\n```", "```py\nlayer.get_dataset(\"bitcoin\").to_pandas()\nlayer.get_dataset(\"ethereum\").to_pandas()\nlayer.get_dataset(\"polkadot\").to_pandas()\nlayer.get_dataset(\"stellar\").to_pandas()\n```", "```py\ndef runNoVolumePrediction(dataset):\n\n    # Defining the parameters\n    # test_size: proportion of data allocated to testing\n    # random_state: ensures the same test-train split each time for reproducibility\n\n    parameters = {\n      \"test_size\": 0.25,\n      \"random_state\": 15,\n    }\n\n    # Logging the parameters\n    # layer.log(parameters)\n    # Loading the dataset from Layer\n    df = layer.get_dataset(dataset).to_pandas()\n    df.dropna(inplace=True)\n\n    # Dropping columns we won't be using for the predictions of closing price\n    dfX = df.drop([\"Close\", \"Date\", \"Volume\", \"Market Cap\"], axis=1)\n\n    # Getting just the closing price column\n    dfy = df[\"Close\"]\n\n    # Test train split (with same random state)\n    X_train, X_test, y_train, y_test = train_test_split(dfX, dfy, test_size=parameters[\"test_size\"], random_state=parameters[\"random_state\"])\n\n    # Fitting the multiple linear regression model with the training data\n    regressor = LinearRegression()\n    regressor.fit(X_train,y_train)\n\n    # Making predictions using the testing data\n    predict_y = regressor.predict(X_test)\n\n    # .score returns the coefficient of determination RÂ² of the prediction\n    layer.log({\"Prediction Score :\":regressor.score(X_test,y_test)})\n\n    # Logging the coefficient corresponding to each variable\n    coeffs = regressor.coef_\n    layer.log({\"Opening price coeff\":coeffs[0]})\n    layer.log({\"Low price coeff\":coeffs[1]})\n    layer.log({\"High price coeff\":coeffs[2]})\n\n    # Plotting the predicted values against the actual values\n    plt.plot(y_test,predict_y, \"*\")\n    plt.ylabel('Predicted closing price')\n    plt.xlabel('Actual closing price')\n    plt.title(\"{} closing price prediction\".format(dataset))\n    plt.show()\n\n    #Logging the plot\n    layer.log({\"plot\":plt})\n    return regressor\n```", "```py\n@model(name='bitcoin_prediction')\ndef bitcoin_prediction():\n    return runNoVolumePrediction(\"bitcoin\")\n\nlayer.run([bitcoin_prediction])\n```", "```py\nlayer.get_model(\"bitcoin_prediction\")\nlayer.get_model(\"ethereum_prediction\")\nlayer.get_model(\"polkadot_prediction\")\nlayer.get_model(\"stellar_prediction\")\n```", "```py\nlayer.get_dataset(\"bitcoin_5Years\").to_pandas()\nlayer.get_dataset(\"ethereum_5Years\").to_pandas()\nlayer.get_dataset(\"polkadot_5Years\").to_pandas()\nlayer.get_dataset(\"stellar_5Years\").to_pandas()\n```"]