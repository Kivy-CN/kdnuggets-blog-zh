["```py\nimport torchtorch.manual_seed(0) **# keep things reproducible**x = torch.tensor([1., 2.]) **# create an input array**\nlinear_layer = torch.nn.Linear(2, 3) **# define a linear layer**\nprint(linear_layer(x)) **# putting the input array into the layer****# Output:\n# tensor([ 0.7393, -1.0621,  0.0441], grad_fn=<AddBackward0>)**\n```", "```py\nprint(linear_layer.weight @ x + linear_layer.bias) **# @ = matrix mult****# Output:\n# tensor([ 0.7393, -1.0621,  0.0441], grad_fn=<AddBackward0>)**\n```", "```py\nmodel = torch.nn.Sequential(\n    torch.nn.Linear(3, 6),\n    torch.nn.ReLU(),\n    torch.nn.Linear(6, 6),\n    torch.nn.ReLU(),\n    torch.nn.Linear(6, 6),\n    torch.nn.ReLU(),\n    torch.nn.Linear(6, 1),\n)print(model(torch.randn(4, 3))) **# feed it 4 random 3-dim. vectors**\n```", "```py\nimport torch\nimport mathclass MyLinearLayer(torch.nn.Module):\n    def __init__(self, in_features, out_features):\n        super().__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n\n        **# multiplicative weights\n        weights = torch.Tensor(out_features, in_features)\n        self.weights = torch.nn.Parameter(weights)\n        torch.nn.init.kaiming_uniform_(self.weights)** \n\n        # bias\n        bias = torch.Tensor(out_features)\n        self.bias = torch.nn.Parameter(bias)\n        bound = 1 / math.sqrt(in_features)\n        torch.nn.init.uniform_(self.bias, -bound, bound)   ** def forward(self, x):\n        return x @ self.weights.t() + self.bias**\n```", "```py\nclass BlockLinear(torch.nn.Module):\n    def __init__(self, n_blocks, in_features, out_features):\n        super().__init__()\n        self.n_blocks = n_blocks\n        self.in_features = in_features\n        self.out_features = out_features\n        self.block_weights = []\n        self.block_biases = []        **for i in range(n_blocks):\n            block_weight = torch.Tensor(out_features, in_features)\n            block_weight = torch.nn.Parameter(block_weight)\n            torch.nn.init.kaiming_uniform_(block_weight)\n            self.register_parameter(\n                f'block_weight_{i}',\n                block_weight\n            )\n            self.block_weights.append(block_weight)** **block_bias = torch.Tensor(out_features)\n            block_bias = torch.nn.Parameter(block_bias)\n            bound = 1 / math.sqrt(in_features)\n            torch.nn.init.uniform_(block_bias, -bound, bound)\n            self.register_parameter(\n                f'block_bias_{i}',\n                block_bias\n            )\n            self.block_biases.append(block_bias)**    def forward(self, x):\n        block_size = x.size(1) // self.n_blocks\n        **x_blocks = torch.split(\n            x,\n            split_size_or_sections=block_size,\n            dim=1\n        )** **block_outputs = []\n        for block_id in range(self.n_blocks):\n            block_outputs.append(\n                x_blocks[block_id] @ self.block_weights[block_id].t() + self.block_biases[block_id]\n            )**        return torch.cat(block_outputs, dim=1)\n```", "```py\nX = torch.randn(1000, 3)\ny = 3*X[:, 0] + 2*X[:, 1]**2 + X[:, 2]**3 + torch.randn(1000)\ny = y.reshape(-1, 1)\n```", "```py\nclass Model(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n\n        **self.features** = torch.nn.Sequential(\n            BlockLinear(3, 1, 20),\n            torch.nn.ReLU(),\n            BlockLinear(3, 20, 20),\n            torch.nn.ReLU(),\n            BlockLinear(3, 20, 20),\n            torch.nn.ReLU(),\n            BlockLinear(3, 20, 1),\n        )\n\n        **self.lr** = torch.nn.Linear(3, 1)\n\n    def forward(self, x):\n        x_pre = self.features(x)\n        return self.lr(x_pre)\n\nmodel = Model()\n```", "```py\noptimizer = torch.optim.Adam(model.parameters())\ncriterion = torch.nn.MSELoss()for i in range(2000):\n    optimizer.zero_grad()\n    y_pred = model(X)\n    loss = criterion(y, y_pred)\n    loss.backward()\n    optimizer.step()\n    if i % 100 == 0:\n        print(loss)\n```", "```py\nimport matplotlib.pyplot as pltx = torch.linspace(-5, 5, 100).reshape(-1, 1)\nx = torch.hstack(3*[x])for i in range(3):\n    plt.plot(\n        x[:, 0].detach().numpy(),\n        model.get_submodule('lr').weight[0][i].item() * model.get_submodule('features')(x)[:, i].detach().numpy())\n    plt.title(f'Feature {i+1}')\n    plt.show()\n```"]