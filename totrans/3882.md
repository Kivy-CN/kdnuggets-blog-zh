# 面向数据科学家的简明面向对象编程讲解

> 原文：[https://www.kdnuggets.com/2020/12/object-oriented-programming-explained-simply-data-scientists.html](https://www.kdnuggets.com/2020/12/object-oriented-programming-explained-simply-data-scientists.html)

[评论](#comments)![图示](../Images/96e2f31dc1eaa9686d222cb562061d96.png)

图片由 [Jelleke Vanooteghem](https://unsplash.com/@ilumire?utm_source=medium&utm_medium=referral) 拍摄，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)

* * *

## 我们的前三个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全领域。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织的 IT

* * *

面向对象编程（OOP）对于初学者来说可能是一个难以理解的概念。这主要是因为在很多地方它没有以正确的方式进行解释。通常很多书籍从解释面向对象编程开始，会提到三个主要术语——**封装、继承和多态**。但书籍解释这些主题时，刚刚入门的人已经会感到迷茫。

所以，我想到为同事程序员、数据科学家和 Python 爱好者简化这个概念。我打算通过去除所有术语并通过一些示例来实现。首先我会解释类和对象。然后我会解释为什么类在各种情况下很重要，以及它们如何解决一些基本问题。通过这种方式，读者也能够在文章结束时理解这三个主要术语。

在这一系列名为[**Python Shorts**](https://towardsdatascience.com/tagged/python-shorts)的文章中，我将解释 Python 提供的一些简单但非常有用的构造、一些必备技巧以及我在数据科学工作中经常遇到的一些用例。

***这篇文章旨在用通俗易懂的方式解释面向对象编程。***

### 什么是对象和类？

简而言之，Python 中的一切都是对象，而类是对象的蓝图。因此，当我们写下：

```py
a = 2
b = "Hello!"
```

我们正在创建一个`a`对象，属于`int`类，值为2，另一个`b`对象，属于`str`类，值为“Hello!”。从某种程度上说，这两个特定的类在我们使用数字或字符串时默认提供给我们。

除此之外，我们中的很多人最终会在不自觉的情况下使用类和对象。例如，当你使用任何 Scikit-Learn 模型时，你实际上是在使用一个类。

```py
clf = RandomForestClassifier()
clf.fit(X,y)
```

这里你的分类器`clf`是一个对象，fit 是在`RandomForestClassifier`类中定义的方法。

### 但为什么是类？

所以，我们在使用 Python 时经常用到它们。但到底为什么呢？类有什么特别之处？我能用函数实现相同的功能吗？

是的，你可以。但是，与函数相比，类确实提供了更多的功能。举个例子，`str`类为对象定义了很多函数，我们只需按下 tab 键即可访问。虽然也可以编写所有这些函数，但那样的话，按下 tab 键时它们将不会被使用。

![图片](../Images/f2e2a1c598d8cac648f0e27713f03d01.png)

这种类的特性被称为**封装**。从[维基百科](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))——***封装***指的是将数据与操作该数据的方法打包在一起，或限制对对象某些组件的直接访问。

所以，这里的`str`类将数据（“Hello!”）与所有操作数据的方法打包在一起。我将在帖子末尾解释该声明的第二部分。同样，`RandomForestClassifier`类将所有分类器方法（`fit`、`predict`等）打包在一起。

除此之外，类的使用还可以帮助我们使代码更模块化，更易于维护。比如说，我们要创建一个类似 Scikit-Learn 的库。我们需要创建许多模型，每个模型都会有一个 fit 和 predict 方法。如果我们不使用类，我们将为每个不同的模型编写大量的函数，如下所示：

```py
RFCFit
RFCPredict
SVCFit
SVCPredict
LRFit
LRPredict and so on.
```

这种代码结构简直是个噩梦，因此 Scikit-Learn 将每个模型定义为一个具有`fit`和`predict`方法的类。

### 创建类

现在我们理解了为什么要使用类以及它们的重要性，我们到底该如何使用它们呢？创建类非常简单。下面是任何你将编写的类的模板代码：

```py
class myClass:
    def __init__(self, a, b):
        self.a = a
        self.b = b    def somefunc(self, arg1, arg2):
        #SOME CODE HERE
```

我们看到很多新关键字。主要的有`class`、`__init__`和`self`。这些是什么？再次，通过一些例子很容易解释。

假设你在一家拥有许多账户的银行工作。我们可以创建一个名为`account`的类，用于处理任何账户。例如，下面我创建了一个简单的玩具类`Account`，它存储用户数据——即`account_name`和`balance`。它还提供了两个方法来`deposit`（存款）和`withdraw`（取款）。请仔细阅读，它遵循与上面代码相同的结构。

```py
class Account:
    def __init__(self, account_name, balance=0):
        self.account_name = account_name
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount

    def withdraw(self,amount):
        if amount <= self.balance:
            self.balance -= amount
        else:
            print("Cannot Withdraw amounts as no funds!!!")
```

我们可以使用以下代码创建一个名为 Rahul，金额为 100 的账户：

```py
myAccount = Account("Rahul",100)
```

我们可以使用以下代码访问这个账户的数据：

![图片](../Images/ab17d66ae51505be847d46b6329a25ef.png)

但是，这些属性`balance`和`account_name`是如何已经分别设置为100和“Rahul”的？我们从未调用`__init__`方法，那么对象为什么会得到这些属性？这里的答案是`__init__`是一个**魔术方法**（还有很多其他魔术方法，我将在下一篇关于魔术方法的帖子中详细展开），它会在我们创建对象时运行。因此，当我们创建`myAccount`时，它会自动运行`__init__`函数。

现在我们理解了`__init__`，让我们尝试向账户存入一些钱。我们可以这样做：

![Image for post](../Images/7d8f316ef9630bcc6180621607155e23.png)

我们的余额上升到200。然而，你是否注意到我们的函数`deposit`需要两个参数，即`self`和`amount`，但我们只提供了一个，结果它仍然能工作。

**那么，这个`**self**`到底是什么？** 我喜欢通过以不同的方式调用相同的函数来解释self。下面，我调用属于`account`类的相同函数deposit，并提供了`myAccount`对象和`amount`。现在函数接受两个参数，如它应该的那样。

![Image for post](../Images/e6fc0a58d32132bee7048b4e8e53d64d.png)

我们的`myAccount`余额如预期增加了100。所以这是我们调用的相同函数。现在，这只能发生在`self`和`myAccount`完全相同的对象时。当我调用`myAccount.deposit(100)`时，Python将相同的对象`myAccount`提供给函数调用作为参数`self`。这就是为什么函数定义中的`self.balance`实际上指的是`myAccount.balance`。

### 但是，仍然存在一些问题

![Figure](../Images/cf04bc78e16f04728298a8bdfeb0e9d0.png)

照片来自[Volodymyr Hryshchenko](https://unsplash.com/@lunarts?utm_source=medium&utm_medium=referral)在[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)

我们知道如何创建类，但仍然有一个重要的问题我还没有触及。

假设你在苹果iPhone部门工作，并且你需要为每个iPhone型号创建一个不同的类。对于这个简单的例子，假设我们iPhone的第一个版本目前只做一件事——打电话并且有一些内存。我们可以将类编写为：

```py
class iPhone:
    def __init__(self, memory, user_id):
         self.memory = memory
         self.mobile_id = user_id
    def call(self, contactNum):
         # Some Implementation Here
```

现在，苹果计划推出`iPhone1`，这个`iPhone`型号引入了一项新功能——拍照的能力。做到这一点的一种方法是复制粘贴上述代码并创建一个新的`iPhone1`类，如下所示：

```py
class iPhone1:
    **def __init__(self, memory, user_id):
         self.memory = memory
         self.mobile_id = user_id**
         self.pics = []    **def call(self, contactNum):
         # Some Implementation Here**    def click_pic(self):
         # Some Implementation Here
         pic_taken = ...
         self.pics.append(pic_taken)
```

但正如你所看到的，上面的代码有很多不必要的重复（以粗体显示），而Python有解决这些代码重复的方法。一个好的编写`iPhone1`类的方法是：

```py
Class iPhone1(**iPhone**):
    def __init__(self,**memory,user_id**):
         **super().__init__(memory,user_id)**
         self.pics = []
    def click_pic(self):
         # Some Implementation Here
         pic_taken = ...
         self.pics.append(pic_taken)
```

这就是继承的概念。根据 [维基百科](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming))：**继承** 是基于另一个对象或类来创建对象或类的机制，并保留相似的实现。简单来说，`iPhone1` 现在可以访问在 `iPhone` 类中定义的所有变量和方法。

在这种情况下，我们不需要进行任何代码重复，因为我们继承了父类 `iPhone` 的所有方法。因此，我们不需要再次定义 `call` 函数。此外，我们也不使用 super 在 `__init__` 函数中设置 `mobile_id` 和 `memory`。

**但这 `**super().__init__(memory,user_id)**` 是什么？**

在现实生活中，你的 `__init__` 函数不会像这样简洁的两行函数。你需要在类中定义大量的变量/属性，并且为子类（如 iphone1）复制粘贴这些变量会变得很繁琐。因此，存在 super()。这里 `**super().__init__()**` 实际上调用了父类 `iPhone` 的 `**__init__**` 方法。因此，当 `iPhone1` 类的 `__init__` 函数运行时，它会自动使用父类的 `__init__` 函数设置类的 `memory` 和 `user_id`。

***我们在机器学习/数据科学/深度学习中看到这个概念了吗？*** 以下是我们如何创建一个 [PyTorch](https://mlwhiz.com/blog/2020/09/09/pytorch_guide/) 模型。该模型从 `nn.Module` 类继承了一切，并使用 `super` 调用父类的 `__init__` 函数。

```py
class myNeuralNet(nn.Module):    def __init__(self):
        **super().__init__()**
        # Define all your Layers Here
        self.lin1 = nn.Linear(784, 30)
        self.lin2 = nn.Linear(30, 10)    def forward(self, x):
        # Connect the layer Outputs here to define the forward pass
        x = self.lin1(x)
        x = self.lin2(x)
        return x
```

**但什么是多态性？** 我们在理解类的工作方式上越来越好，所以我想现在尝试解释多态性。看下面的类。

这里我们有一个基础 `class Shape` 和其他派生类 — `Rectangle` 和 `Circle`。还可以看到我们在 `Square` 类中如何使用多级继承，`Square` 类继承自 `Rectangle`，而 `Rectangle` 类又继承自 `Shape`。这些类中的每一个都有一个名为 `area` 的函数，根据形状进行定义。因此，通过 **多态性**，一个同名函数可以执行多种操作。***事实上，这就是多态性的字面含义：“形态多样的东西”。*** 因此，我们的函数 `area` 具有多种形式。

多态性在 Python 中的另一种工作方式是使用 `isinstance` 方法。因此，使用上述类，如果我们执行：

![帖子图片](../Images/38955b28a6cae5d8f7f03bb8724618cf.png)

因此，`mySquare` 对象的实例类型是 `Square`，

`Rectangle` 和 `Shape`。因此，该对象是多态的。这具有很多良好的属性。例如，我们可以创建一个处理 `Shape` 对象的函数，并且它将完全适用于任何派生类（如 `Square`、`Circle`、`Rectangle` 等），这得益于多态性。

![帖子图片](../Images/479a55964aa987ef1806f878a927ac55.png)

### 更多信息：

为什么我们会看到以**单下划线和双下划线**开头的函数名或属性名？有时我们希望将类中的属性和函数设为私有，不允许用户查看它们。这是**封装**的一部分，我们希望“*限制对某些对象组件的直接访问*”。例如，假设我们不希望用户在创建 iPhone 后查看内存（RAM）。在这种情况下，我们会在变量名中使用下划线创建属性。

所以当我们以以下方式创建`iPhone`类时，你将无法通过 Tab 在你的 ipython notebooks 中访问你的手机`memory`或`privatefunc`，因为该属性现在使用 _ 被设置为私有。

![文章图片](../Images/d1853feefd419827342a8318a29d0cd4.png)

但你仍然可以使用它来更改变量值（尽管不推荐）。

![文章图片](../Images/5bee417978dd83037a2eddd0405ddaef.png)

你还可以使用`myphone._privatefunc()`方法。如果你想避免这种情况，可以在变量名前使用双下划线。例如，`print(myphone.__memory)` 的调用会抛出错误。此外，你不能通过`myphone.__memory = 1`来更改对象的内部数据。

![文章图片](../Images/c05f87c2f2ddd2dbfdb981150c7c9762.png)

但是，正如你所见，你可以在类定义中通过`setMemory`函数访问和修改这些`self.__memory`值。

### 结论

![图示](../Images/7a29c9ef2303425720d307e8d75a9347.png)

图片来源：[Jeshoots.com](https://unsplash.com/@jeshoots?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)

我希望这些对你理解类有所帮助。类还有很多内容，我会在下一个关于魔术方法的帖子中继续讲解。敬请关注。总的来说，在这篇文章中，我们学习了面向对象编程（OOP）及其创建类的各种基本知识：

+   **封装**：对象包含所有自己的数据。

+   **继承**：我们可以创建一个类层次结构，将父类的方法传递给子类。

+   **多态性**：一个函数可以有多种形式，或者对象可能具有多种类型。

结束这篇文章，我会给你一个练习，希望它能帮助你澄清一些概念。***创建一个类，让你管理 3D 对象（球体和立方体），包括体积和表面积。*** 基本的样板代码如下：

```py
import mathclass Shape3d:
    def __init__(self, name):
        self.name = name    def surfaceArea(self):
        pass

    def volume(self):
        pass

    def getName(self):
        return self.name

class Cuboid():
    passclass Cube():
    pass

class Sphere():
    pass
```

我会在这篇文章的评论中放置***答案。***

如果你想了解更多关于[Python](https://amzn.to/2XPSiiG)的内容，我推荐密歇根大学提供的[**中级 Python 课程**](https://bit.ly/2XshreA)。请务必查看一下。

我未来还会写更多这样的帖子。请告诉我你对这个系列的看法。可以在[**Medium**](https://medium.com/@rahul_agarwal)上关注我，或订阅我的[**博客**](http://eepurl.com/dbQnuX)以获取最新信息。如往常一样，我欢迎反馈和建设性的批评，可以在Twitter上通过[@mlwhiz](https://twitter.com/MLWhiz)与我联系。

此外，有一个小声明——此帖子中可能包含一些相关资源的附属链接，因为分享知识永远不是坏主意。

**个人简介：[Rahul Agarwal](https://www.linkedin.com/in/rahulagwl/)** 是 WalmartLabs 的高级统计分析师。在Twitter上关注他[@mlwhiz](https://twitter.com/MLWhiz)。

[原文](https://towardsdatascience.com/object-oriented-programming-explained-simply-for-data-scientists-ce2c7b5db1d)。已获转载许可。

**相关：**

+   [10种被低估的Python技能](/2020/10/10-underrated-python-skills.html)

+   [数据科学家的6条建议](/2019/09/advice-data-scientists.html)

+   [每位数据科学家必须知道的5个分类评估指标](/2019/10/5-classification-evaluation-metrics-every-data-scientist-must-know.html)

### 更多相关主题

+   [成为一名出色数据科学家所需的5项关键技能](https://www.kdnuggets.com/2021/12/5-key-skills-needed-become-great-data-scientist.html)

+   [每位初学者数据科学家应掌握的6个预测模型](https://www.kdnuggets.com/2021/12/6-predictive-models-every-beginner-data-scientist-master.html)

+   [2021年最佳ETL工具](https://www.kdnuggets.com/2021/12/mozart-best-etl-tools-2021.html)

+   [是什么使 Python 成为初创公司的理想编程语言](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)

+   [停止学习数据科学以寻找目标，并以寻找目标来……](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)

+   [建立一个坚实的数据团队](https://www.kdnuggets.com/2021/12/build-solid-data-team.html)
