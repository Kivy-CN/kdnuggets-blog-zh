["```py\nfor generation in range(num_generations):\n\n    print(\"Generation : \", generation)\n\n    # Measuring the fitness of each chromosome in the population.\n\n    fitness = GA.cal_pop_fitness(new_population, data_inputs, data_outputs, train_indices, test_indices)\n\n    best_outputs.append(numpy.max(fitness))\n\n    # The best result in the current iteration.\n\n    print(\"Best result : \", best_outputs[-1])\n\n    # Selecting the best parents in the population for mating.\n\n    parents = GA.select_mating_pool(new_population, fitness, num_parents_mating)\n\n    # Generating next generation using crossover.\n\n    offspring_crossover = GA.crossover(parents, offspring_size=(pop_shape[0]-parents.shape[0], num_feature_elements))\n\n    # Adding some variations to the offspring using mutation.\n\n    offspring_mutation = GA.mutation(offspring_crossover, num_mutations=num_mutations)\n\n    # Creating the new population based on the parents and offspring.\n\n    new_population[0:parents.shape[0], :] = parents\n\n    new_population[parents.shape[0]:, :] = offspring_mutation\n```", "```py\nfitness = GA.cal_pop_fitness(new_population, data_inputs, data_outputs, train_indices, test_indices)\n\n# Then return the index of that solution corresponding to the best fitness.\n\nbest_match_idx = numpy.where(fitness == numpy.max(fitness))[0]\n\nbest_match_idx = best_match_idx[0]\n\nbest_solution = new_population[best_match_idx, :]\n\nbest_solution_indices = numpy.where(best_solution == 1)[0]\n\nbest_solution_num_elements = best_solution_indices.shape[0]\n\nbest_solution_fitness = fitness[best_match_idx]\n\nprint(\"best_match_idx : \", best_match_idx)\n\nprint(\"best_solution : \", best_solution)\n\nprint(\"Selected indices : \", best_solution_indices)\n\nprint(\"Number of selected elements : \", best_solution_num_elements)\n\nprint(\"Best solution fitness : \", best_solution_fitness)\n\nmatplotlib.pyplot.plot(best_outputs)\n\nmatplotlib.pyplot.xlabel(\"Iteration\")\n\nmatplotlib.pyplot.ylabel(\"Fitness\")\n\nmatplotlib.pyplot.show()\n```", "```py\n\nimport numpy\nimport GA\nimport pickle\nimport matplotlib.pyplot\n\nf = open(\"dataset_features.pkl\", \"rb\")\ndata_inputs = pickle.load(f)\nf.close()\n\nf = open(\"outputs.pkl\", \"rb\")\ndata_outputs = pickle.load(f)\nf.close()\n\nnum_samples = data_inputs.shape[0]\nnum_feature_elements = data_inputs.shape[1]\n\ntrain_indices = numpy.arange(1, num_samples, 4)\ntest_indices = numpy.arange(0, num_samples, 4)\nprint(\"Number of training samples: \", train_indices.shape[0])\nprint(\"Number of test samples: \", test_indices.shape[0])\n\n\"\"\"\nGenetic algorithm parameters:\n    Population size\n    Mating pool size\n    Number of mutations\n\"\"\"\nsol_per_pop = 8 # Population size.\nnum_parents_mating = 4 # Number of parents inside the mating pool.\nnum_mutations = 3 # Number of elements to mutate.\n\n# Defining the population shape.\npop_shape = (sol_per_pop, num_feature_elements)\n\n# Creating the initial population.\nnew_population = numpy.random.randint(low=0, high=2, size=pop_shape)\nprint(new_population.shape)\n\nbest_outputs = []\nnum_generations = 100\nfor generation in range(num_generations):\n    print(\"Generation : \", generation)\n    # Measuring the fitness of each chromosome in the population.\n    fitness = GA.cal_pop_fitness(new_population, data_inputs, data_outputs, train_indices, test_indices)\n\n    best_outputs.append(numpy.max(fitness))\n    # The best result in the current iteration.\n    print(\"Best result : \", best_outputs[-1])\n\n    # Selecting the best parents in the population for mating.\n    parents = GA.select_mating_pool(new_population, fitness, num_parents_mating)\n\n    # Generating next generation using crossover.\n    offspring_crossover = GA.crossover(parents, offspring_size=(pop_shape[0]-parents.shape[0], num_feature_elements))\n\n    # Adding some variations to the offspring using mutation.\n    offspring_mutation = GA.mutation(offspring_crossover, num_mutations=num_mutations)\n\n    # Creating the new population based on the parents and offspring.\n    new_population[0:parents.shape[0], :] = parents\n    new_population[parents.shape[0]:, :] = offspring_mutation\n\n# Getting the best solution after iterating finishing all generations.\n# At first, the fitness is calculated for each solution in the final generation.\nfitness = GA.cal_pop_fitness(new_population, data_inputs, data_outputs, train_indices, test_indices)\n# Then return the index of that solution corresponding to the best fitness.\nbest_match_idx = numpy.where(fitness == numpy.max(fitness))[0]\nbest_match_idx = best_match_idx[0]\n\nbest_solution = new_population[best_match_idx, :]\nbest_solution_indices = numpy.where(best_solution == 1)[0]\nbest_solution_num_elements = best_solution_indices.shape[0]\nbest_solution_fitness = fitness[best_match_idx]\n\nprint(\"best_match_idx : \", best_match_idx)\nprint(\"best_solution : \", best_solution)\nprint(\"Selected indices : \", best_solution_indices)\nprint(\"Number of selected elements : \", best_solution_num_elements)\nprint(\"Best solution fitness : \", best_solution_fitness)\n\nmatplotlib.pyplot.plot(best_outputs)\nmatplotlib.pyplot.xlabel(\"Iteration\")\nmatplotlib.pyplot.ylabel(\"Fitness\")\nmatplotlib.pyplot.show()\n```", "```py\n\nimport numpy\n\nimport sklearn.svm\n\ndef reduce_features(solution, features):\n\n    selected_elements_indices = numpy.where(solution == 1)[0]\n\n    reduced_features = features[:, selected_elements_indices]\n\n    return reduced_features\n\ndef classification_accuracy(labels, predictions):\n\n    correct = numpy.where(labels == predictions)[0]\n\n    accuracy = correct.shape[0]/labels.shape[0]\n\n    return accuracy\n\ndef cal_pop_fitness(pop, features, labels, train_indices, test_indices):\n\n    accuracies = numpy.zeros(pop.shape[0])\n\n    idx = 0\n\n    for curr_solution in pop:\n\n        reduced_features = reduce_features(curr_solution, features)\n\n        train_data = reduced_features[train_indices, :]\n\n        test_data = reduced_features[test_indices, :]\n\n        train_labels = labels[train_indices]\n\n        test_labels = labels[test_indices]\n\n        SV_classifier = sklearn.svm.SVC(gamma='scale')\n\n        SV_classifier.fit(X=train_data, y=train_labels)\n\n        predictions = SV_classifier.predict(test_data)\n\n        accuracies[idx] = classification_accuracy(test_labels, predictions)\n\n        idx = idx + 1\n\n    return accuracies\n\ndef select_mating_pool(pop, fitness, num_parents):\n\n    # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\n\n    parents = numpy.empty((num_parents, pop.shape[1]))\n\n    for parent_num in range(num_parents):\n\n        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))\n\n        max_fitness_idx = max_fitness_idx[0][0]\n\n        parents[parent_num, :] = pop[max_fitness_idx, :]\n\n        fitness[max_fitness_idx] = -99999999999\n\n    return parents\n\ndef crossover(parents, offspring_size):\n\n    offspring = numpy.empty(offspring_size)\n\n    # The point at which crossover takes place between two parents. Usually, it is at the center.\n\n    crossover_point = numpy.uint8(offspring_size[1]/2)\n\n    for k in range(offspring_size[0]):\n\n        # Index of the first parent to mate.\n\n        parent1_idx = k%parents.shape[0]\n\n        # Index of the second parent to mate.\n\n        parent2_idx = (k+1)%parents.shape[0]\n\n        # The new offspring will have its first half of its genes taken from the first parent.\n\n        offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]\n\n        # The new offspring will have its second half of its genes taken from the second parent.\n\n        offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]\n\n    return offspring\n\ndef mutation(offspring_crossover, num_mutations=2):\n\n    mutation_idx = numpy.random.randint(low=0, high=offspring_crossover.shape[1], size=num_mutations)\n\n    # Mutation changes a single gene in each offspring randomly.\n\n    for idx in range(offspring_crossover.shape[0]):\n\n        # The random value to be added to the gene.\n\n        offspring_crossover[idx, mutation_idx] = 1 - offspring_crossover[idx, mutation_idx]\n\n    return offspring_crossover\n\n```"]