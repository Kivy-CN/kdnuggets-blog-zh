# 对抗性验证概述

> 原文：[https://www.kdnuggets.com/2020/02/adversarial-validation-overview.html](https://www.kdnuggets.com/2020/02/adversarial-validation-overview.html)

[评论](#comments)

如果你研究了一些Kaggle上的竞赛获胜解决方案，你可能会注意到提到“对抗性验证”的参考资料（[比如这个](https://www.kaggle.com/c/ieee-fraud-detection/discussion/111284)）。这是什么呢？

简而言之，我们建立一个分类器，尝试预测哪些数据行来自训练集，哪些来自测试集。如果这两个数据集来自相同的分布，这应该是不可能的。但如果你的训练数据集和测试数据集在特征值上有系统性的差异，那么一个分类器将能够成功地学习区分它们。你能学会区分它们的模型越好，你的问题就越大。

但好消息是*你可以分析学到的模型来帮助你诊断问题*。一旦你理解了问题，你就可以着手解决它。

本文旨在配合我制作的[YouTube视频](https://youtu.be/7cUCDRaIZ7I)，解释对抗性验证的直觉。这个博客帖子讲解了视频中示例的代码实现，但足够完整，足以独立存在。你可以在[GitHub](https://github.com/zjost/blog_code/tree/master/adversarial_validation)上找到这篇文章的完整代码。

### 学习对抗性验证模型

首先，添加一些常见的导入语句以避免混淆：

```py
import pandas as pd
from catboost import Pool, CatBoostClassifier

```

### 数据准备

对于本教程，我们将使用Kaggle上的[IEEE-CIS信用卡欺诈检测数据集](https://www.kaggle.com/c/ieee-fraud-detection/data)。首先，我假设你已经将训练数据和测试数据加载到pandas DataFrame中，并分别命名为*df_train*和*df_test*。然后，我们将通过替换缺失值来进行一些基本的清理。

```py
# Replace missing categoricals with ""
df_train.loc[:,cat_cols] = df_train[cat_cols].fillna('')
df_test.loc[:,cat_cols] = df_test[cat_cols].fillna('')

# Replace missing numeric with -999
df_train = df_train.fillna(-999)
df_test = df_test.fillna(-999)

```

对于对抗性验证，我们希望学习一个模型来预测哪些行在训练数据集中，哪些在测试集中。因此，我们创建了一个新的目标列，其中测试样本标记为1，训练样本标记为0，如下所示：

```py
df_train['dataset_label'] = 0
df_test['dataset_label'] = 1
target = 'dataset_label'

```

这是我们将训练一个模型来预测的目标。目前，训练集和测试集是分开的，每个数据集只有一个目标值标签。如果我们在*这个*训练集上训练模型，它将只会学到一切都是0。我们想要的是打乱训练集和测试集，然后创建新的数据集来拟合和评估对抗性验证模型。我定义了一个函数来合并、打乱和重新拆分：

```py
def create_adversarial_data(df_train, df_test, cols, N_val=50000):
    df_master = pd.concat([df_train[cols], df_test[cols]], axis=0)
    adversarial_val = df_master.sample(N_val, replace=False)
    adversarial_train = df_master[~df_master.index.isin(adversarial_val.index)]
    return adversarial_train, adversarial_val

features = cat_cols + numeric_cols + ['TransactionDT']
all_cols = features + [target]
adversarial_train, adversarial_test = create_adversarial_data(df_train, df_test, all_cols)

```

新的数据集，*adversarial_train*和*adversarial_test*，包括了原始训练集和测试集的混合，目标列表示原始数据集。*注意：我将* TransactionDT *添加到了特征列表中。这个原因将会显现出来。*

对于建模，我将使用 Catboost。我通过将 DataFrames 转换为 Catboost Pool 对象来完成数据准备。

```py
train_data = Pool(
    data=adversarial_train[features],
    label=adversarial_train[target],
    cat_features=cat_cols
)
holdout_data = Pool(
    data=adversarial_test[features],
    label=adversarial_test[target],
    cat_features=cat_cols
)

```

### 建模

这部分很简单：我们只需实例化一个 Catboost 分类器并在我们的数据上进行训练：

```py
params = {
    'iterations': 100,
    'eval_metric': 'AUC',
    'od_type': 'Iter',
    'od_wait': 50,
}

model = CatBoostClassifier(**params)
_ = model.fit(train_data, eval_set=holdout_data)

```

让我们继续在保留数据集上绘制 ROC 曲线：

![](../Images/f85665598d59b9f283d690f8207dbbfb.png)

这是一个完美的模型，这意味着可以清楚地判断任何给定的记录是属于训练集还是测试集。这违反了我们训练集和测试集应当具有相同分布的假设。

### 诊断问题并进行迭代

要了解模型是如何做到这一点的，我们来看看最重要的特征：

![](../Images/41ce4a631fbd77d8648a2dffc386b240.png)

TransactionDT 迄今为止是最重要的特征。这完全有意义，因为原始的训练集和测试集来自不同的时间段（测试集发生在训练集之后）。模型已经学会了如果 TransactionDT 大于最后一个训练样本，那么它就是测试集中的样本。

我包括了 TransactionDT 只是为了说明这一点——通常不建议将原始日期作为模型特征。但是，值得庆幸的是，这种技术以如此戏剧性的方式发现了这一点。这项分析显然能帮助你识别出这样的错误。

让我们排除 TransactionDT，并再次进行分析。

```py
params2 = dict(params)
params2.update({"ignored_features": ['TransactionDT']})
model2 = CatBoostClassifier(**params2)
_ = model2.fit(train_data, eval_set=holdout_data)

```

现在 ROC 曲线看起来像这样：

![](../Images/ad8f85b1360a4d48945cf9297ee74bdf.png)

这仍然是一个相当强大的模型，AUC > 0.91，但比之前弱得多。让我们看看这个模型的特征重要性：

![](../Images/e4ee0d6af6f44b5053021a591cf35934.png)

现在，*id_31* 是最重要的特征。让我们查看一些值以了解它是什么。

```py
[
    '', 'samsung browser 6.2', 'mobile safari 11.0',
    'chrome 62.0', 'chrome 62.0 for android', 'edge 15.0',
    'mobile safari generic', 'chrome 49.0', 'chrome 61.0', 'edge 16.0'
]

```

这一列包含软件版本号。显然，这与包含原始日期的概念类似，因为特定软件版本的首次出现将对应于其发布日期。

让我们通过去掉列中任何非字母字符来解决这个问题：

```py
def remove_numbers(df_train, df_test, feature):
    df_train.loc[:, feature] = df_train[feature].str.replace(r'[^A-Za-z]', '', regex=True)
    df_test.loc[:, feature] = df_test[feature].str.replace(r'[^A-Za-z]', '', regex=True)

remove_numbers(df_train, df_test, 'id_31')

```

现在我们列中的值看起来像这样：

```py
[
    'UNK', 'samsungbrowser', 'mobilesafari',
    'chrome', 'chromeforandroid', 'edge',
    'mobilesafarigeneric', 'safarigeneric',
]

```

让我们使用这个清理过的列训练一个新的对抗验证模型：

```py
adversarial_train_scrub, adversarial_test_scrub = create_adversarial_data(
    df_train,
    df_test,
    all_cols,
)

train_data_scrub = Pool(
    data=adversarial_train_scrub[features],
    label=adversarial_train_scrub[target],
    cat_features=cat_colsc
)

holdout_data_scrub = Pool(
    data=adversarial_test_scrub[features],
    label=adversarial_test_scrub[target],
    cat_features=cat_colsc
)

model_scrub = CatBoostClassifier(**params2)
_ = model_scrub.fit(train_data_scrub, eval_set=holdout_data_scrub)

```

现在 ROC 图看起来像这样：

![](../Images/5e0a44192531181d62184c1f42b7b23f.png)

性能从 AUC 0.917 降到了 0.906。这意味着我们让模型区分训练集和测试集的数据集变得稍微困难了一些，但模型仍然非常强大。

### 结论

当我们天真地将交易日期放入特征集时，对抗验证过程帮助我们清楚地诊断了问题。额外的迭代给了我们更多的线索，表明包含软件版本信息的列在训练集和测试集之间存在明显差异。

但该过程无法告诉我们*如何修复它*。我们仍需在这里发挥创造力。在这个例子中，我们只是从软件版本信息中删除了所有数字，但这样做丢弃了潜在有用的信息，可能会*最终对我们的欺诈建模任务产生负面影响*，这是我们的真实目标。我们的想法是*你要去除那些对预测欺诈不重要但对分离训练集和测试集重要的信息*。

更好的方法可能是找到一个提供每个软件版本的软件发布日期的数据集，然后创建一个“自发布以来的天数”列来替换原始版本号。这可能会使训练和测试分布的匹配更好，同时保持软件版本信息所编码的预测能力。

**相关：**

+   [对抗性验证解释](https://www.kdnuggets.com/2016/10/adversarial-validation-explained.html)

+   [可重复性、复制性与数据科学](https://www.kdnuggets.com/2019/11/reproducibility-replicability-data-science.html)

+   [小心！过多查看模型结果可能导致信息泄漏](https://www.kdnuggets.com/2019/05/careful-looking-model-results-cause-information-leakage.html)

* * *

## 我们的三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析水平

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织 IT 部门

* * *

### 更多相关话题

+   [什么是对抗性机器学习？](https://www.kdnuggets.com/2022/03/adversarial-machine-learning.html)

+   [为什么使用 k 折交叉验证？](https://www.kdnuggets.com/2022/07/kfold-cross-validation.html)

+   [使用 Pandera 进行 PySpark 应用的数据验证](https://www.kdnuggets.com/2023/08/data-validation-pyspark-applications-pandera.html)

+   [Pydantic 教程：简化 Python 数据验证](https://www.kdnuggets.com/pydantic-tutorial-data-validation-in-python-made-simple)

+   [MarshMallow: 最甜蜜的 Python 数据序列化和…库](https://www.kdnuggets.com/marshmallow-the-sweetest-python-library-for-data-serialization-and-validation)

+   [文本总结方法概述](https://www.kdnuggets.com/2019/01/approaches-text-summarization-overview.html)
