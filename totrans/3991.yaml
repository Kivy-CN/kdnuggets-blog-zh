- en: How to Speed Up Python Pandas by Over 300x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/how-to-speed-up-python-pandas-by-over-300x](https://www.kdnuggets.com/how-to-speed-up-python-pandas-by-over-300x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![How to Speed Up Python Pandas by Over 300x](../Images/4ccb0c246d992f847174ad475d82ca91.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Speed Up Pandas Code - Vectorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want our deep learning models to train on a dataset, we have to optimize
    our code to parse through that data quickly. We want to read our data tables as
    fast as possible using an optimized way to write our code. Even the smallest performance
    gain exponentially improves performance over tens of thousands of data points.
    In this blog, we will define Pandas and provide an example of how you can vectorize
    your Python code to optimize dataset analysis using Pandas to speed up your code
    over 300x times faster.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: What is Pandas for Python?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Pandas](https://pandas.pydata.org/docs/) is an essential and popular open-source
    data manipulation and data analysis library for the Python programming language.
    Pandas is widely used in various fields such as finance, economics, social sciences,
    and engineering. It is beneficial for data cleaning, preparation, and analysis
    in data science and machine learning tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: It provides powerful data structures (such as the DataFrame and Series) and
    data manipulation tools to work with structured data, including reading and writing
    data in various formats (e.g. CSV, Excel, JSON) and filtering, cleaning, and transforming
    data. Additionally, it supports time series data and provides powerful data aggregation
    and visualization capabilities through integration with other popular libraries
    such as NumPy and Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: Our Dataset and Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, we are going to create a random dataset in a [Jupyter Notebook](https://jupyter.org/) using
    NumPy to fill in our Pandas data frame with arbitrary values and strings. In this
    dataset, we are naming 10,000 people of varying ages, the amount of time they
    work, and the percentage of time they are productive at work. They will also be
    assigned a random favorite treat, as well as a random bad karma event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are first going to import our frameworks and generate some random code before
    we start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to create our dataset with some by creating some random data.
    Now your code will most likely rely on actual data but for our use case, we will
    create some arbitrary data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Parameters and Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If a person’s ‘time_at_work’ is at least 2 hours AND where ‘percentage_productive’
    is more than 50%, we return with 'favorite treat'.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, we give them 'bad_karma'.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they are over 65 years old, we return with a ‘favorite_treat’ since we our
    elderly to be happy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our dataset and our parameters for what we want to return,
    we can go ahead and explore the fastest way to execute this type of analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which Pandas Code Is Fastest: Looping, Apply, or Vectorization?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To time our functions, we will be using a Jupyter Notebook to make it relatively
    simple with the magic function %%timeit. There are other ways to time a function
    in Python but for demonstration purposes, our Jupyter Notebook will suffice. We
    will do a demo run on the same dataset with 3 ways of calculating and evaluating
    our problem using Looping/Iterating, Apply, and Vectorization.
  prefs: []
  type: TYPE_NORMAL
- en: Looping/Iterating
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Looping and Iterating is the most basic way to deliver the same calculation
    row by row. We call the data frame and iterate rows with a new cell called reward
    and run the calculation to fill in the new `reward` according to our previously
    defined `reward_calc` code block. This is the most basic and probably the first
    method learned when coding similar to For Loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what it returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inexperienced data scientists might see a couple of seconds as no big deal.
    But, 3.66 seconds is quite long to run a simple function through a dataset. Let’s
    see what the `apply` function can do for us for speed.
  prefs: []
  type: TYPE_NORMAL
- en: Apply
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `apply` function effectively does the same thing as the loop. It will create
    a new column titled reward and apply the calculation function every 1 row as defined
    by `axis=1`. The `apply` function is a faster way to run a loop to your dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The time it took to run is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Wow, so much faster! About 9x faster, a huge improvement to a Loop. Now the
    Apply Function is perfectly fine to use and will be applicable in certain scenarios,
    but for our use case, let's see if we can speed it up more.
  prefs: []
  type: TYPE_NORMAL
- en: Vectorization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our last and final way to evaluate this dataset is to use vectorization. We
    will call our dataset and apply the default reward being `bad_karma` to the entire
    data frame. Then we will only check for those that satisfy our parameters using
    boolean indexing. Think of it like setting a true/false value for each row. If
    any or all of the rows return false in our calculation, then the `reward` row
    will remain `bad_karma`. While if all the rows are true, we will redefine the
    data frame for the `reward` row as `favorite_treat`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The time it took to run this function on our dataset is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That is extremely fast. **40x faster than the Apply** and approximately **360x
    faster than Looping…**
  prefs: []
  type: TYPE_NORMAL
- en: Why Vectorization in Pandas is over 300x Faster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason why vectorization is so much faster than Looping/Iterating and Apply
    is that it doesn’t calculate the entire row every single time but instead applies
    the parameters to the entire dataset as a whole. Vectorization is a process where
    operations are applied to entire arrays of data at once, instead of operating
    on each element of the array individually. This allows for much more efficient
    use of memory and CPU resources.
  prefs: []
  type: TYPE_NORMAL
- en: When using Loops or Apply to perform calculations on a Pandas data frame, the
    operation is applied sequentially. This causes repeated access to memory, calculations,
    and updated values which can be slow and resource intensive.
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized operations, on the other hand, are implemented in Cython (Python
    in C or C++) and utilize the CPU's vector processing capabilities, which can perform
    multiple operations at once, further increasing performance by calculating multiple
    parameters at the same time. Vectorized operations also avoid the overhead of
    constantly accessing memory which is the crutch of Loop and Apply.
  prefs: []
  type: TYPE_NORMAL
- en: How to Vectorize your Pandas Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Built-in Pandas and NumPy Functions that have implemented C like **sum()**,
    **mean()**, or **max()**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use vectorized operations that can apply to entire DataFrames and Series including
    mathematical operations, comparisons, and logic to create a boolean mask to select
    multiple rows from your data set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the **.values** attribute or the `.to_numpy()` to return the underlying
    NumPy array and perform vectorized calculations directly on the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use vectorized string operations to apply to your dataset such as `.str.contains()`,
    `.str.replace()`, and `.str.split()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you’re writing functions on Pandas DataFrames, try to vectorize your
    calculations as much as possible. As datasets get larger and larger and your calculations
    get more and more complex, the time savings add up exponentially when you utilize
    vectorization. It's worth noting that not all operations can be vectorized and
    sometimes it's necessary to use loops or apply functions. However, wherever it's
    possible, vectorized operations can greatly improve performance and make your
    code more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Kevin Vu](https://blog.exxactcorp.com/)** manages [Exxact Corp blog](https://blog.exxactcorp.com/)
    and works with many of its talented authors who write about different aspects
    of Deep Learning.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Machine Learning Over Encrypted Data](https://www.kdnuggets.com/2022/08/machine-learning-encrypted-data.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Is Academia Obsessing Over Methodology at the Cost of True Insights?](https://www.kdnuggets.com/is-academia-obsessing-over-methodology-at-the-cost-of-true-insights)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3 Simple Ways to Speed Up Your Python Code](https://www.kdnuggets.com/2022/10/3-simple-ways-speed-python-code.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How To Speed Up SQL Queries Using Indexes [Python Edition]](https://www.kdnuggets.com/2023/08/speed-sql-queries-indexes-python-edition.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How To Speed Up Python Code with Caching](https://www.kdnuggets.com/how-to-speed-up-python-code-with-caching)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Python Tips for Data Efficiency and Speed](https://www.kdnuggets.com/5-python-tips-for-data-efficiency-and-speed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
