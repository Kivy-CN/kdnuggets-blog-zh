# 不要再伤害你的 Pandas 了！

> 原文：[https://www.kdnuggets.com/2020/04/stop-hurting-pandas.html](https://www.kdnuggets.com/2020/04/stop-hurting-pandas.html)

[comments](#comments)

**作者：[Pawel Rzeszucinski](https://www.linkedin.com/in/pawelrzeszucinski/)，[Codewise](http://www.codewise.com/)**

![Figure](../Images/47801c4858e2d8ce22b79bb7b046ad4b.png)

来源：Wikimedia Commons

Pandas 是几乎所有在 Python 中执行的数据处理任务的王者。它已经存在了 12 年，尽管我们直到 2020 年 1 月才见到了 1.0 版本的发布。使用 Pandas 进行数据操作、切片和更新非常直观，这可能就是为什么这个包从一开始就取得了成功的原因。尽管语法简单而一致，但在某些情况下，仍需特别小心，以确保准确实现预期的操作。本文将讨论在不当使用 Pandas 切片时可能出现的问题。如果你看到警告信息 "*A value is trying to be set on a copy of a slice from a DataFrame*"，那么这篇文章适合你。

Pandas 提供了明确的规则来正确切片 DataFrame，详细概述可以在 [这里](/2019/06/select-rows-columns-pandas.html) 找到。然而，我们并不总是遵循最佳实践，因为这需要获取必要的知识并保持一定的自我严格。除了指南中概述的选项外，Pandas 还允许我们以多种不同的方式访问 DataFrame 元素。这可能会引发试图以不适当的方式进行数据分配的诱惑，从而产生一些意想不到的效果。

我们首先定义一个简单的测试数据框：

```py` ``` df = pd.DataFrame({'x':[1,5,4,3,4,5],  				   'y':[.1,.5,.4,.3,.4,.5],  				   'w':[11,15,14,13,14,15]})       x    y   w  0  1  0.1  11  1  5  0.5  15  2  4  0.4  14  3  3  0.3  13  4  4  0.4  14  5  5  0.5  15 ```py ````

假设我们想找到所有 'x' 列大于 3 的 DataFrame 元素，并基于此将所有对应的 'y' 值更改为 50。

如何根据 Pandas 的最佳实践正确执行此操作？在这种情况下，使用 `.loc` 方法：

```py` ``` df.loc[df['x']>3,'y']=50 ```py ````

我们定位符合初始标准的行元素（第一个参数），以及我们想更新的列（第二个参数），所有这些都在对 DataFrame 的一次调用中进行评估。

结果如预期那样。

```py` ```    x     y   w  0  1   0.1  11  1  5  50.0  15  2  4  50.0  14  3  3   0.3  13  4  4  50.0  14  5  5  50.0  15 ```py ````

如前所述，Pandas 提供了多种访问（但不一定是修改！）数据的方式。

不遵守脚本（指南）可能会让我们陷入困境。例如，有些人可能会更自然地写出以下相同的操作：

```py` ``` df[df['x']>3]['y']=50 ```py ````

很明显，不是吗？选择对应于 `'x'>3` 的 `df` 子集，然后将列'y'的值更改为 50。

让我们试试：

```py` ```    x    y   w  0  1  0.1  11  1  5  0.5  15  2  4  0.4  14  3  3  0.3  13  4  4  0.4  14  5  5  0.5  15 ```py ````

我可能打错了什么，重新运行一次。

```py` ``` df[df['x']>3]['y']=50       x    y   w  0  1  0.1  11  1  5  0.5  15  2  4  0.4  14  3  3  0.3  13  4  4  0.4  14  5  5  0.5  15 ```py ````

完全没有变化！为什么？

我们遇到了所谓的“链式索引”效应，本质上是一个接一个地使用两个索引器，例如 `df[][]`

让我们分解一下我们的命令：

+   `df[df['x']>3]` 导致 Pandas 创建了原始 DataFrame 的单独副本

+   `df[df['x']>3]['y'] = 50` 将新值赋给列'y'，但这是在临时创建的副本上，而不是原始 DataFrame 上。

通过使用[基础 'id' 函数](https://docs.python.org/3/library/functions.html#id)可以明确观察到这一点，该函数返回给定对象在机器内存中的地址。

```py` ``` id(df)  2838845867680    id(df[df['x']>3])  2838845989832    id(id) == id(df[df['x']>3])  False ```py ````

有趣的是，当我们倒转命令中的切片顺序，即先调用列，然后是我们要满足的条件时，我们会得到预期的结果：

```py` ``` df['y'][df['x']>3]=50       x     y   w  0  1   0.1  11  1  5  50.0  15  2  4  50.0  14  3  3   0.3  13  4  4  50.0  14  5  5  50.0  15 ```py ````

这是因为当我们只从 DataFrame 中选择一列时，Pandas 创建了视图，而不是副本。

什么是视图？它本质上是同一对象的代理，即在此过程中没有创建新对象。

```py` ``` z = df['y'] # z 是 df['y'] 的视图  id(df['y']) == id(z)  True ```py ````

尽管我们达到了目标，但可能会触发一些副作用：

让我们看看这一系列命令。

```py` ``` df # 原始 DataFrame     x    y   w  0  1  0.1  11  1  5  0.5  15  2  4  0.4  14  3  3  0.3  13  4  4  0.4  14  5  5  0.5  15    z = df['y'] # 列'y'的视图  z[z>=0.5] = 30    z  0     0.1  1    30.0  2     0.4  3     0.3  4     0.4  5    30.0    df     x     y   w  0  1   0.1  11  1  5  30.0  15  2  4   0.4  14  3  3   0.3  13  4  4   0.4  14  5  5  30.0  15 ```py ````

哇！我们以为我们创建了一个独立于`df`的对象'z'，并且在操作'z'时`df`的值是安全的。不对。

我们只创建了一个视图。好在 Pandas 会显示传统的警告。

Pandas 这样做是因为它不知道我们是想仅仅修改'y'系列（通过代理'z'），还是想改变原始`df`的值。

好的，那么如果我们想提取'z'作为独立对象呢？Pandas 方法 `.copy()` 正好可以实现这个目的。

当我们将命令更新为下方所示时，我们将创建一个具有自己内存地址的全新对象，任何对 'z' 的更新都将不会影响到 `df`。

```py` ``` z = df['y'].copy()  id(df['y']) == id(z)  False ```py ````

实际上，有两个要点可以防止我们在处理切片和数据操作时出现不必要的副作用：

1.  避免链式索引。始终选择 `.loc`/`.iloc`（或 `.at`/`.iat`）选项。

1.  `copy()` 你的变量以创建独立的对象，并保护原始数据源不被无意间修改。

**简介： [Pawel Rzeszucinski 博士](https://www.linkedin.com/in/pawelrzeszucinski/)** 是 30 多篇出版物和专利的作者，涉及广义的数据分析领域。他获得了克兰菲尔德大学计算机科学硕士学位，然后前往曼彻斯特大学，获得了与 QinetiQ 相关的直升机齿轮箱诊断分析解决方案的博士学位。回到波兰后，他曾在 ABB 企业研究中心担任高级科学家，并在汇丰银行战略分析部担任高级风险建模师。他目前在 AdTech 公司 Codewise 担任首席数据科学家。Pawel Rzeszucinski 博士是《福布斯》技术委员会成员。

**相关内容：**

+   [如何使用 [ ]、.loc、iloc、.at 和 .iat 在 Pandas 中选择行和列](/2019/06/select-rows-columns-pandas.html)

+   [数据分析的 Python… 真的那么简单吗？！?](/2020/04/python-data-analysis-really-that-simple.html)

+   [使用 pdpipe 构建管道](/2019/12/build-pipelines-pandas-pdpipe.html)

* * *

## 我们的三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业道路。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织的 IT

* * *

### 更多相关话题

+   [停止学习数据科学以寻找目标，并通过寻找目标来…](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)

+   [分析 90 亿美元 AI 失败](https://www.kdnuggets.com/2021/12/9b-ai-failure-examined.html)

+   [学习数据科学统计的顶级资源](https://www.kdnuggets.com/2021/12/springboard-top-resources-learn-data-science-statistics.html)

+   [成功数据科学家的 5 个特征](https://www.kdnuggets.com/2021/12/5-characteristics-successful-data-scientist.html)

+   [是什么让 Python 成为初创公司的理想编程语言](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)

+   [每个数据科学家都应该知道的三个 R 库（即使你使用 Python）](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)
