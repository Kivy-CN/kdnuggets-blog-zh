["```py\nimport pandas as pd\n\nimport numpy as np\n\ndf = fb_sms_sends[[\"ds\",\"type\",\"phone_number\"]]\n\ndf1 = df[df[\"type\"].isin(['confirmation','friend_request']) == False]\n\ndf1_grouped = df1.groupby('ds')['phone_number'].count().reset_index(name='count')\n\ndf1_grouped_0804 = df1_grouped[df1_grouped['ds']=='08-04-2020']\n\ndf2 = fb_confirmers[[\"date\",\"phone_number\"]]\n\ndf3 = pd.merge(df1,df2, how ='left',left_on =[\"phone_number\",\"ds\"], right_on = [\"phone_number\",\"date\"])\n\ndf3_grouped = df3.groupby('date')['phone_number'].count().reset_index(name='confirmed_count')\n\ndf3_grouped_0804 = df3_grouped[df3_grouped['date']=='08-04-2020']\n\nresult = (float(df3_grouped_0804['confirmed_count'])/df1_grouped_0804['count'])*100\n```", "```py\nimport pandas as pd\n\nimport numpy as np\n\ndf = pd.merge(db_employee, db_dept, how = 'left',left_on = ['department_id'], right_on=['id'])\n\ndf1=df[df[\"department\"]=='engineering']\n\ndf_eng = df1.groupby('department')['salary'].max().reset_index(name='eng_salary')\n\ndf2=df[df[\"department\"]=='marketing']\n\ndf_mkt = df2.groupby('department')['salary'].max().reset_index(name='mkt_salary')\n\nresult = pd.DataFrame(df_mkt['mkt_salary'] - df_eng['eng_salary'])\n\nresult.columns = ['salary_difference']\n\nresult\n```", "```py\nclass Solution:\n\n    def letterCombinations(self, digits: str) -> List[str]:\n\n        # If the input is empty, immediately return an empty answer array\n\n        if len(digits) == 0: \n\n            return []\n\n        # Map all the digits to their corresponding letters\n\n        letters = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \n\n                   \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"}\n\n        def backtrack(index, path):\n\n            # If the path is the same length as digits, we have a complete combination\n\n            if len(path) == len(digits):\n\n                combinations.append(\"\".join(path))\n\n                return # Backtrack            \n\n            # Get the letters that the current digit maps to, and loop through them\n\n            possible_letters = letters[digits[index]]\n\n            for letter in possible_letters:\n\n                # Add the letter to our current path\n\n                path.append(letter)\n\n                # Move on to the next digit\n\n                backtrack(index + 1, path)\n\n                # Backtrack by removing the letter before moving onto the next\n\n                path.pop()\n\n        # Initiate backtracking with an empty path and starting index of 0\n\n        combinations = []\n\n        backtrack(0, [])\n\n        return combinations\n```", "```py\nfrom collections import defaultdict\n\nclass Solution:\n\n    def solveSudoku(self, board):\n\n        \"\"\"\n\n        :type board: List[List[str]]\n\n        :rtype: void Do not return anything, modify board in-place instead.\n\n        \"\"\"\n\n        def could_place(d, row, col):\n\n            \"\"\"\n\n            Check if one could place a number d in (row, col) cell\n\n            \"\"\"\n\n            return not (d in rows[row] or d in columns[col] or \\\n\n                    d in boxes[box_index(row, col)])        \n\n        def place_number(d, row, col):\n\n            \"\"\"\n\n            Place a number d in (row, col) cell\n\n            \"\"\"\n\n            rows[row][d] += 1\n\n            columns[col][d] += 1\n\n            boxes[box_index(row, col)][d] += 1\n\n            board[row][col] = str(d)            \n\n        def remove_number(d, row, col):\n\n            \"\"\"\n\n            Remove a number which didn't lead \n\n            to a solution\n\n            \"\"\"\n\n            del rows[row][d]\n\n            del columns[col][d]\n\n            del boxes[box_index(row, col)][d]\n\n            board[row][col] = '.'                \n\n        def place_next_numbers(row, col):\n\n            \"\"\"\n\n            Call backtrack function in recursion\n\n            to continue to place numbers\n\n            till the moment we have a solution\n\n            \"\"\"\n\n            # if we're in the last cell\n\n            # that means we have the solution\n\n            if col == N - 1 and row == N - 1:\n\n                nonlocal sudoku_solved\n\n                sudoku_solved = True\n\n            #if not yet    \n\n            else:\n\n                # if we're in the end of the row\n\n                # go to the next row\n\n                if col == N - 1:\n\n                    backtrack(row + 1, 0)\n\n                # go to the next column\n\n                else:\n\n                    backtrack(row, col + 1)                         \n\n        def backtrack(row = 0, col = 0):\n\n            \"\"\"\n\n            Backtracking\n\n            \"\"\"\n\n            # if the cell is empty\n\n            if board[row][col] == '.':\n\n                # iterate over all numbers from 1 to 9\n\n                for d in range(1, 10):\n\n                    if could_place(d, row, col):\n\n                        place_number(d, row, col)\n\n                        place_next_numbers(row, col)\n\n                        # if sudoku is solved, there is no need to backtrack\n\n                        # since the single unique solution is promised\n\n                        if not sudoku_solved:\n\n                            remove_number(d, row, col)\n\n            else:\n\n                place_next_numbers(row, col)                    \n\n        # box size\n\n        n = 3\n\n        # row size\n\n        N = n * n\n\n        # lambda function to compute box index\n\n        box_index = lambda row, col: (row // n ) * n + col // n       \n\n        # init rows, columns and boxes\n\n        rows = [defaultdict(int) for i in range(N)]\n\n        columns = [defaultdict(int) for i in range(N)]\n\n        boxes = [defaultdict(int) for i in range(N)]\n\n        for i in range(N):\n\n            for j in range(N):\n\n                if board[i][j] != '.': \n\n                    d = int(board[i][j])\n\n                    place_number(d, i, j)\n\n        sudoku_solved = False\n\n        backtrack()\n```"]