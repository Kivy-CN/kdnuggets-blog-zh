- en: 5 Tricky SQL Queries Solved
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2020/11/5-tricky-sql-queries-solved.html](https://www.kdnuggets.com/2020/11/5-tricky-sql-queries-solved.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![5 Tricky SQL Queries Solved](../Images/e41f609976ecb9e58bec1bbd218eec5d.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Sql vector created by freepik - www.freepik.com](https://www.freepik.com/vectors/sql)'
  prefs: []
  type: TYPE_NORMAL
- en: SQL(Structured Query Language) is a very important tool in a data scientist’s
    toolbox. Mastering SQL is not only essential in an interview point of view, but
    a good understanding of SQL by being able to solve complex queries will keep us
    above everyone in the race.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I will talk about 5 tricky questions I found and my approaches
    to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note — **Each query can be written in different ways. Try to think about
    the approach before moving on to my solutions. You can also suggest different
    approaches in the response section.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Query 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are given a table consisting of two columns, **Name,** and** Profession**.
    We need to query* all the names immediately followed by the first letter in the
    profession column enclosed in parenthesis*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../Images/820325e10e82bd2a333a08bdaad95b9c.png)'
  prefs: []
  type: TYPE_IMG
- en: '**My Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since we need to combine the name and profession we can use`CONCAT`. We also
    need to have only *one letter* inside the parenthesis. Hence we will use `SUBSTR`and
    pass the column name, start index, end index. Since we need only the first letter
    we will pass 1,1(start index is inclusive and the end index is not inclusive)
  prefs: []
  type: TYPE_NORMAL
- en: Query 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tina was asked to compute the average salary of all employees from the EMPLOYEES
    table she created but realized that the zero key in her keyboard is not working
    after the result showed a very less average. She wants our help in finding out
    the difference between miscalculated average and actual average.
  prefs: []
  type: TYPE_NORMAL
- en: We must write a query finding the error( Actual AVG — Calculated AVG).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image for post](../Images/99c74ba461c52ff24fe191cfe5f9eb34.png)'
  prefs: []
  type: TYPE_IMG
- en: '**My Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A point to note here is that we have only one table that consists of actual
    salary values. To create the error scenario we use `REPLACE` to replace 0’s. We
    will pass the column name, value to be replaced, and the value with which we will
    replace the `REPLACE` method. Then we find the difference in averages using the
    aggregate function `AVG`.
  prefs: []
  type: TYPE_NORMAL
- en: Query 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are given a table, which is a [Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree) consisting
    of two columns **Node** and **Parent. **We must write a query that returns the
    node type ordered by the value of nodes in ascending order. There are 3 types.
  prefs: []
  type: TYPE_NORMAL
- en: Root — if the node is a root
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leaf — if the node is a leaf
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inner — if the node is neither root nor leaf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Image for post](../Images/44f62ec80dd7c87217a7583fb281cb28.png)'
  prefs: []
  type: TYPE_IMG
- en: '**My Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: Upon initial analysis, we can conclude that if a given node N has its corresponding
    P-value as NULL it is the root. And for a given Node N if it exists in the P column
    it is not an inner node. Based on this idea let us write a query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can use `CASE` which acts as a switch function. As I mentioned if P is null
    for a given node N then N is the root. Hence we used`CONCAT` for combining the
    node value and label. Similarly, if a given node N is in column P it is an inner
    node. To get all nodes from column P we wrote a subquery which returns all the
    distinct nodes in column P. Since we were asked to order the output by node values
    in ascending order we used the `ORDER BY` Clause.
  prefs: []
  type: TYPE_NORMAL
- en: Query 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are given a transaction table that consists of **transaction_id, user_id,
    transaction_date, product_id, and quantity**. We need to query the number of users
    who purchased products on multiple days(Note that a given user can purchase multiple
    products on a single day).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image for post](../Images/3ae645ecd6a7862668cb13e5b007a2c9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**My Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: To solve this query, we cannot directly count the occurrence of user_id’s and
    if it is more than one return that user_id because a given user can have more
    than one transaction on a single day. Hence if a given user_id has more than one
    distinct date associated with it means he purchased products on multiple days.
    Following the same approach, I wrote a query. (Inner query)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since the question asked for the number of user_ids and not the user_id’s itself
    we use `COUNT` in the outer query.
  prefs: []
  type: TYPE_NORMAL
- en: Query 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are given a subscription table which consists of subscription start and end
    date for each user. We need to write a query that returns true/false for each
    user based on the overlapping of dates with other users. For instance, If user1's
    subscription period overlaps with any other user the query must return **True** for
    user1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image for post](../Images/ca171480f7cbd202e9aca36df46684db.png)'
  prefs: []
  type: TYPE_IMG
- en: '**My Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: Upon initial analysis, we understand that we must compare every subscription
    against every other one. Let us consider start and end dates of **userA** as `**startA**` and `**endA**`,
    similarly for **userB**,`**startB**` and `**endB**`**.**
  prefs: []
  type: TYPE_NORMAL
- en: If `**startA**`**≤**`**endB**`** and **`**endA**`**≥**`**startB**` then we can
    say the two date ranges overlap. Let us take two examples. Let us compare U1 AND
    U3 first.
  prefs: []
  type: TYPE_NORMAL
- en: '`startA` = 2020–01–01'
  prefs: []
  type: TYPE_NORMAL
- en: '`endA` = 2020–01–31'
  prefs: []
  type: TYPE_NORMAL
- en: '`startB` = 2020–01–16'
  prefs: []
  type: TYPE_NORMAL
- en: '`endB` = 2020–01–26'
  prefs: []
  type: TYPE_NORMAL
- en: Here we can see `**startA**`(2020–01–01) is less than `**endB**`**(**2020–01–26)
    and similarly, **endA**(2020–01–31) is greater than `**startB**`(2020–01–16) and
    hence can conclude that the dates overlap. Similarly, if you compare U1 and U4
    the above condition fails and will return false.
  prefs: []
  type: TYPE_NORMAL
- en: We must also ensure that a user is not compared to his own subscription. We
    also want to run a left join on itself to match a user with each other user that
    satisfies our condition. We will create two replicas s1 and s2 of the same table
    now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Given the conditional join, a user_id from s2 should exist for each user_id
    in s1 on the condition where there exists an overlap between the dates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image for post](../Images/85f7bf83f0e6d113639947f141b5cba6.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see there exists another user for each user in case the dates overlap.
    For user1 there are 2 rows indicating that he matches with 2 users. For user 4
    the corresponding id is null indicating that he does not match with any other
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping it all together now, we can group by the s1.user_id field and just
    check if any value exists true for a user where s2.user_id IS NOT NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Final query**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We used the `CASE` clause to label 1 and 0 depending on the s2.user_id value
    for a given user. The final output looks like this -
  prefs: []
  type: TYPE_NORMAL
- en: '![Image for post](../Images/449b151ef25a57b0838a6082d5becc1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Before concluding, I would like to suggest a good book on SQL which I thoroughly
    enjoyed and found very useful.
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Cookbook: Query Solutions and Techniques for Database Developers (Cookbooks
    (O’Reilly))](https://www.amazon.in/gp/product/B0026OR3KI/ref=as_li_tl?ie=UTF8&camp=3638&creative=24630&creativeASIN=B0026OR3KI&linkCode=as2&tag=kurasaiteja-21&linkId=e1ca4cf824b67c4fff6865a5163712c2)'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering SQL requires lots of practice. In this article, I took 5 tricky questions
    and explained the approaches to solve them. The specialty of SQL is that each
    query can be written in many different ways. Do feel free to share your approaches
    in the responses. I hope you learned something new today!
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to get in touch, **connect with me on **[**LinkedIn**](https://www.linkedin.com/in/saiteja-kura-49803b13b/)**.**
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](https://medium.com/towards-artificial-intelligence/5-tricky-sql-queries-solved-919266e2d524).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Saiteja Kura](https://www.linkedin.com/in/saiteja-kura-49803b13b/)** is
    sincere, friendly, and ambitious, and is interested in Web Development, Data Science,
    and NLP.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Solving 5 Complex SQL Problems: Tricky Queries Explained](https://www.kdnuggets.com/2022/07/5-hardest-things-sql.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4 Useful Intermediate SQL Queries for Data Science](https://www.kdnuggets.com/2022/12/4-useful-intermediate-sql-queries-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News, December 7: Top 10 Data Science Myths Busted • 4…](https://www.kdnuggets.com/2022/n47.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Optimize SQL Queries for Faster Data Retrieval](https://www.kdnuggets.com/2023/06/optimize-sql-queries-faster-data-retrieval.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How To Speed Up SQL Queries Using Indexes [Python Edition]](https://www.kdnuggets.com/2023/08/speed-sql-queries-indexes-python-edition.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leveraging GPT Models to Transform Natural Language to SQL Queries](https://www.kdnuggets.com/leveraging-gpt-models-to-transform-natural-language-to-sql-queries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
