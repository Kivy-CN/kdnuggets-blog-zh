- en: Implementing Your Own k-Nearest Neighbor Algorithm Using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2016/01/implementing-your-own-knn-using-python.html/3](https://www.kdnuggets.com/2016/01/implementing-your-own-knn-using-python.html/3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Getting the neighbours to vote on the class of the test points**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using the nearest neighbours you just identified, you can get a prediction
    for the class of the test instance by majority voting - simply tally up which
    class comes up the most often among the nearest neighbours.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The [neighbour[1] for neighbour in neighbours] just grabs the class of the nearest
    neighbours (that's why it was good to also keep the training instance information
    in _get_tuple_distance instead of keeping track of the distances only).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, Counter, which is a dictionary subclass, counts the number of occurrences
    of objects. Try out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the most_common method of Counter can be used to return tuples with the
    most common elements and their frequencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In a similar way, you can grab the classes of the nearest neighbours, tally
    up how frequently the different class labels occur, and then find the most common
    label. This most common label will be the class prediction of the test instance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running our algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: That's about it. Now, just string the data loading and these 3 primary functions
    together with a main method and run it. Let's set k equal to 5, i.e. look at the
    5 nearest neighbours to do the classification of new test instances. Once the
    predictions for classes of test cases are made, it would be useful to get a report
    of how good our predictions are. You can get these summary statistics from scikit's
    [accuracy_score](http://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html)
    and [classification_score](http://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html)
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method just brings together the previous functions and should be relatively
    self-explanatory. One potentially confusing point may be the very end of the script
    - instead of just calling main() to run the script, it is useful to instead first
    check if `__name__ == "__main__"`. This would make no difference at all if you
    only want to run this script as is from the command line or in an interactive
    shell - when reading the source code, the Python interpreter would set the special
    `__name__` variable to `"__main__"` and run everything. However, say that you
    wanted to just import the functions to another module (another .py file) without
    running all of the code. Then, __name__ would be set to the other module’s name.
    This would let us use the kNN code without having it execute every time. So, this
    check allows the script to behave differently based on whether the script is run
    directly or being imported from somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: '**Refinements**'
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, when trying to classify new data points, we calculated
    the distance between each test instance and every single data point in our training
    set. This is inefficient, and there exist alterations to kNN which subdivide the
    search space in order to minimize the number of pairwise calculations (e.g. see
    [k-d trees](https://www.youtube.com/watch?v=TLxWtXEbtFE)). Another refinement
    to the kNN algorithm can be made by weighting the importance of specific neighbours
    based on their distance from the test case. This would allow closer neighbours
    to have more of an impact on the class voting process, which is intuitively sensible.
  prefs: []
  type: TYPE_NORMAL
- en: A separate point to keep in mind is that, although here we arbitrarily chose
    k=5, we could have chosen other values (which would influence accuracy, noise
    sensitivity, etc.). Ideally, k would be optimized by seeing which value produces
    the most accurate predictions (see [cross-validation](http://scikit-learn.org/stable/modules/cross_validation.html)).
  prefs: []
  type: TYPE_NORMAL
- en: An excellent overview of kNN can be read [here](https://saravananthirumuruganathan.wordpress.com/2010/05/17/a-detailed-introduction-to-k-nearest-neighbor-knn-algorithm/).
    A more in depth implementation with weighting and search trees is [here](http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_ml/py_knn/py_knn_understanding/py_knn_understanding.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Full script**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The full script follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Want to learn more? Check out our two-day Data Science Bootcamp**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cambridgecoding.com/datascience-bootcamp](https://cambridgecoding.com/datascience-bootcamp)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bio: [Natasha Latysheva](http://blog.cambridgecoding.com/author/natlat/)**
    is a computational biology PhD student at the MRC Laboratory of Molecular Biology.
    Her research is focused on cancer genomics, statistical network analysis, and
    protein structure. More generally, her research interests lie in data-intensive
    molecular biology, machine learning (especially deep learning) and data science.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](http://blog.cambridgecoding.com/2016/01/16/machine-learning-under-the-hood-writing-your-own-k-nearest-neighbour-algorithm/).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Scikit-learn and Python Stack Tutorials: Introduction, Implementing Classifiers](/2016/01/scikit-learn-tutorials-introduction-classifiers.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7 Steps to Mastering Machine Learning With Python](/2015/11/seven-steps-machine-learning-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7 Steps to Understanding Deep Learning](/2016/01/seven-steps-deep-learning.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[From Theory to Practice: Building a k-Nearest Neighbors Classifier](https://www.kdnuggets.com/2023/06/theory-practice-building-knearest-neighbors-classifier.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nearest Neighbors for Classification](https://www.kdnuggets.com/2022/04/nearest-neighbors-classification.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[K-nearest Neighbors in Scikit-learn](https://www.kdnuggets.com/2022/07/knearest-neighbors-scikitlearn.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LangChain 101: Build Your Own GPT-Powered Applications](https://www.kdnuggets.com/2023/04/langchain-101-build-gptpowered-applications.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Build Your Own PandasAI with LlamaIndex](https://www.kdnuggets.com/build-your-own-pandasai-with-llamaindex)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Make Your Own GPTs with ChatGPT''s GPTs!](https://www.kdnuggets.com/make-your-own-gpts-with-chatgpts-gpts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
