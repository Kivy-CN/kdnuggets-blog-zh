- en: What You Should Know About Python Decorators And Metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2023/03/know-python-decorators-metaclasses.html](https://www.kdnuggets.com/2023/03/know-python-decorators-metaclasses.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![What You Should Know About Python Decorators And Metaclasses](../Images/4e82b4b27debd7736c591470becfef6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: What are Python Decorators?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: After hearing the word decorators, most of you probably guess it is something
    used for decoration. You guessed it right. At festivals like Christmas or new
    year, we decorate our houses using various lights and materials. But in python,
    the decorators are used to modify or enhance the functionality of python functions
    or methods.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are functions that wrap around the original function and add some
    additional functionalities without directly modifying the original code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine you are an owner of a bakery and an expert in making cakes.
    You make different cakes like Chocolate, Strawberry, and Pineapple. All cakes
    are made from different ingredients, but some steps are common to all cakes, like
    preparing the baking pan, pre-heating the oven, baking the cake, or removing the
    cake from the oven. So, we can make a common decorator function to perform all
    the common steps, make separate functions for different types of cakes, and use
    the decorators to add common functionality to these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the below code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The function `comman_steps` is defined as a decorator and contains all the common
    steps like baking or pre-heating. And the functions `chocolate_cake`, `strawberry_cake`,
    and `pineapple_cake` are defined, which contain different steps for different
    types of cakes.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are defined using the `@` symbol, followed by the name of the decorator
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a function is defined with a decorator, the original function is called
    with the decorator, and the decorator function returns a new function that replaces
    the original function.
  prefs: []
  type: TYPE_NORMAL
- en: The new function performs the additional functionalities before and after calling
    the original function.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the `@` symbol, you can define the decorators in another way that
    provides the same results. E.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Benefits of using Decorators:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the same code repeatedly without redundancy and avoid DRY (Don’t
    Repeat Yourself) principle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This makes your code more readable and easier to maintain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can keep your code organized and clear, which helps you with concerns like
    Input Validation, Error Handling, or Optimization issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using decorators, you can add new functionalities to the existing functions
    or classes without modifying the code. This allows you to extend the code according
    to your business requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Metaclasses?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is the class of a class and defines how a class can behave. A class is itself
    an instance of a metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: Before understanding the definition of a metaclass, first, understand the basic
    definition of python class and objects. Class is like a constructor that is used
    to create objects. We are creating classes to create objects. Objects are also
    known as the instance of a class used to access the class's attributes. Attributes
    can be any datatype like an integer, string, tuple, list, function, or even a
    class. So to use these attributes, we have to create instances (objects) in the
    class, and the method to create these instances is known as instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in python is treated as an object. Even a class is also treated like
    an object. That means a class is instantiated from a different class. The class
    from which all the other classes are instantiated is known as a **metaclass**.
    The class defines the behavior of an object it belongs to. In the same way, the
    behavior of the class is defined by its metaclass, which is a **Type** class by
    default. In simpler terms, all classes are instances of a metaclass in python.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Type Class?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In python, the **Type** class is the metaclass for all classes.  Every time
    you define a new class, by default, it is instantiated from the Type class unless
    you define another metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: Type class is also responsible for the dynamic creation of python classes. When
    we define a new class, python sends the class definition to the type class, and
    then this class creates a new class object according to the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A new class named `College` is created, and an object `obj` of that class is
    instantiated. But when we print the object type, it outputs as `<class '__main__.College>`,
    which means that a particular object is created from the `College` class. But
    on the other hand, when we print the type of the `College` class, it outputs as
    `<class 'type'>`, which means that this class is created from the **type class**
    (metaclass) by default.
  prefs: []
  type: TYPE_NORMAL
- en: We can also change the default metaclass of these user-defined classes. Consider
    the below example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we print the type of the `Student` class, it refers to the `College` as
    a metaclass, but when we print the type of the `College` class, it refers to the
    **type** class as a metaclass. So this forms a hierarchy, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![What You Should Know About Python Decorators And Metaclasses](../Images/a05d7d9d0ca9438db815303744bcb027.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We can also use **type** class for the dynamic creation of new classes. Let
    us understand this more by the below example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Both ways of defining the classes are equivalent. The type() function is used
    in this example to create a new class. It takes three arguments. The first argument
    takes the class name, the second is a tuple of the parent classes (empty in this
    case), and the third argument is a dictionary that takes the attributes of that
    class (also empty in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Consider another example which is using the inheritance concept.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A class named `College` is created having the argument `clgName` as `MIT University`.
    Another class `Student` is created, inherited from the `College` class, and an
    attribute `stuName` as `Kevin Peterson` is created.
  prefs: []
  type: TYPE_NORMAL
- en: When we create an object of the `Student` class, we can see that it can access
    the attributes of both classes. It means that the inheritance works perfectly
    in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we have discussed Decorators and Metaclasses in python. Both
    metaclass and decorators modify the behavior of classes and functions but operate
    using different mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Metaclasses operate at the lower level and allow you to change the structure
    or behavior of the class, like the class methods, attributes, and inheritance.
    Decorators, however, are used to modify the functions' behavior. They allowed
    you to add functionality to the existing functions without changing the code.
    Decorators operate at a higher level as compared to metaclasses. That’s why they
    are somewhat easier to understand and less complex than metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '![What You Should Know About Python Decorators And Metaclasses](../Images/de57c9f0d8c2873fa04a621088c37494.png)'
  prefs: []
  type: TYPE_IMG
- en: Difference between Metaclass & Decorators | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: It is all for today. I hope you have enjoyed reading this article. If you have
    any comments or suggestions, please get in touch with me via [Linkedin](https://www.linkedin.com/in/aryan-garg-1bbb791a3/).
  prefs: []
  type: TYPE_NORMAL
- en: '**[Aryan Garg](https://www.linkedin.com/in/aryan-garg-1bbb791a3/)** is a B.Tech.
    Electrical Engineering student, currently in the final year of his undergrad.
    His interest lies in the field of Web Development and Machine Learning. He have
    pursued this interest and am eager to work more in these directions.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[8 Built-in Python Decorators to Write Elegant Code](https://www.kdnuggets.com/8-built-in-python-decorators-to-write-elegant-code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News, April 13: Python Libraries Data Scientists Should…](https://www.kdnuggets.com/2022/n15.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Three R Libraries Every Data Scientist Should Know (Even if You Use Python)](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Concepts You Should Know About Gradient Descent and Cost Function](https://www.kdnuggets.com/2020/05/5-concepts-gradient-descent-cost-function.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets™ News 22:n03, Jan 19: A Deep Look Into 13 Data…](https://www.kdnuggets.com/2022/n03.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[More Performance Evaluation Metrics for Classification Problems You…](https://www.kdnuggets.com/2020/04/performance-evaluation-metrics-classification.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
