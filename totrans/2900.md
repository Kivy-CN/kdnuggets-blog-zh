# 面向数据科学家的面向对象编程：构建你的ML估算器

> 原文：[https://www.kdnuggets.com/2019/08/object-oriented-programming-data-scientists-estimator.html](https://www.kdnuggets.com/2019/08/object-oriented-programming-data-scientists-estimator.html)

![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [评论](#comments)

**更新**: 你可以在[**这里**](https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/OOP_in_ML/Class_MyLinearRegression.py)找到最新的Python脚本（包含线性回归类定义和方法）。使用它来进行进一步的构建或实验。

### 问题是什么？

* * *

## 我们的前三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 加入网络安全职业的快速通道。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析能力

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌IT支持专业证书](https://www.kdnuggets.com/google-itsupport) - 在IT方面支持你的组织

* * *

数据科学家通常来自与传统计算机科学/软件工程相距甚远的背景——物理学、生物学、统计学、经济学、电气工程等。

![图](../Images/14047e07e857d9d8af0a64fd62947456.png)

**来源**: [“数据科学家来自哪里？”](https://medium.com/indeed-engineering/where-do-data-scientists-come-from-fc526023ace)

但最终，他们被期望掌握足够的编程/软件工程知识，以对他们的组织和业务产生真正的影响。

**[成为数据科学家并不等于成为软件工程师！](https://towardsdatascience.com/being-a-data-scientist-does-not-make-you-a-software-engineer-c64081526372?source=post_page-----7da416751f64----------------------)**

如何构建可扩展的机器学习系统——第1/2部分

那么，现代编程语言和软件工程范式的核心是什么呢？

[面向对象编程 (OOP)。](https://www.webopedia.com/TERM/O/object_oriented_programming_OOP.html)

但[OOP的原则](https://realpython.com/python3-object-oriented-programming/)对初学者来说可能感觉陌生甚至令人畏惧。因此，那些背景没有接受正式计算机编程培训的数据科学家，可能会发现OOP的概念在日常工作中有些难以接受。

受欢迎的MOOCs和数据科学/AI/ML的训练营也没有帮助。

他们试图给新兴的数据科学家提供统计学、数值分析、科学编程、机器学习（ML）算法、可视化，甚至可能还有一些用于部署这些ML模型的Web框架的混合味道。

几乎所有这些都可以在不严格遵守 OOP 原则的情况下学习和实践。实际上，渴望学习最新神经网络架构或最酷的数据可视化技术的年轻数据科学家，可能会因被 OOP 编程范式的琐事所困扰而感到窒息。因此，MOOCs 通常不会在数据科学课程中混合或强调这些内容。

![](../Images/7fd218516dbca417bf02d9ed323659c7.png)

### 一个简单的例子（以及更多…）

让我用 Python 给出这个问题的一个例子，因为它是 [数据科学和机器学习任务中增长最快的语言](https://stackoverflow.blog/2017/09/14/python-growing-quickly/)。

### 算术例子

如果让你编写一个程序来实现涉及两个数字 `a` 和 `b` 的加法、减法、乘法和除法，你最有可能会怎么做？

你最有可能会打开一个 Jupyter notebook，并在一个单元格中输入以下内容，按 *shift-enter* 键并获得结果。

[PRE0]

如果你喜欢通过函数来整理事物，那么你可以这样做，

[PRE1]

但你会不会定义一个（包含初始化方法的）Calc ***类***，并将这些函数放在该类中作为 ***方法*** 呢？这些都是类似性质的操作，并且作用于类似的数据。为什么不将它们 [封装](https://stackify.com/oop-concept-for-beginners-what-is-encapsulation/) 在一个更高层次的对象中呢？为什么不使用以下代码？

[PRE2]

不，你不会这么做。对于这个特定的问题，可能也没有意义这样做。但这个想法是有效的——*如果你有数据和函数（在面向对象编程中称为方法），这些可以逻辑上组合在一起，那么它们应该封装在一个类中*。

但仅仅为了快速回答一些简单的数值计算，就显得工作量太大了。那么，这有什么意义？数据科学家的价值常常在于他们是否能解决数据问题，而不是他们在代码中使用了什么复杂的对象。

### 数据科学家的例子

如果数据科学家不是这样编写代码的，那是否意味着他们真的不需要使用这些复杂的编程结构？

**错误。**

数据科学家在不自觉的情况下充分利用了 OOP 范式的好处。**一直以来**。

记得在 `import matplotlib.pyplot as plt` 之后使用 `plt.plot` 吗？

那些 **.** 符号。你有一点面向对象编程的感觉。就在这里。

或者，你是否还记得在 Jupyter notebook 中学会了一个很酷的技巧——在输入一个点（.）后按 Tab 键，从而显示所有可以与一个*object* 关联的函数？就像这样，

![](../Images/97c267ebc460ca2af1652a07ac458847.png)

### 这个例子展示了什么？

这个例子展示了逻辑一致性。

如果没有OOP范式，我们必须将这些函数命名为`linear_model_linear_regression_fit`、`linear_model_linear_regression_predict`等。它们不会被归在一个共同的逻辑单元下。

为什么？因为它们是不同的函数，并且处理不同的数据集。虽然`fit`函数需要训练特征和目标，但`predict`只需要一个测试数据集。`fit`函数没有返回值的要求，而`predict`则需要返回一组预测值。

**那么，为什么它们会出现在同一个下拉菜单下**？尽管它们不同，但它们有一个共同点，即*它们可以被认为是整体线性回归过程中的重要部分*——我们期望线性回归适合一些训练数据，然后能够对未来的未见数据进行预测。我们还期望线性回归模型能提供一些关于拟合优度的指示——通常以回归系数或R²的形式表示。正如预期的那样，我们看到一个函数`score`，它正是返回那个R²数字，同时也与`fit`和`predict`关联。

整洁且干净，不是吗？

> 数据、函数和参数共同存在于一个逻辑单元中。

![](../Images/50eb96c8a9e886ec5e8981b520522367.png)

### 这怎么实现的？

这之所以可能，是因为**我们超越了个体差异，从高层次考虑线性回归过程**，并决定它应提供哪些基本操作以及应告知用户哪些关键参数。

我们创建了一个高层次的类`LinearRegression`，在这个类下，所有这些看似不相关的函数可以被归类在一起，以便于管理和提高可用性。

一旦我们从库中导入了这个类，只需创建一个类的实例——我们称之为`lm`。就是这样。所有在类下的函数，通过新定义的实例`lm`变得可用。

如果我们对某些函数的内部实现不满意，可以对其进行修改，然后在修改后重新附加到主类中。只有内部函数的代码发生变化，其他部分不会变。

看，这听起来逻辑性强且具有可扩展性吗？

![](../Images/b574d609433e3dac521a60cf30c50316.png)

### 创建你自己的机器学习估计器

传统的面向对象编程（OOP）介绍通常会使用诸如动物、运动、几何形状等类的示例。

但对于数据科学家来说，**为什么不使用他们在代码中每天都用的对象来说明这些概念——一个机器学习估计器**。就像上图中的Scikit-learn库的`lm`对象一样。

### 一个带有变化的经典线性回归估计器

[**在这个Github仓库**](https://github.com/tirthajyoti/Machine-Learning-with-Python/tree/master/OOP_in_ML)中，我逐步展示了如何按照OOP范式构建一个简单的线性回归（单变量或多变量）估计器类。

是的，这是传统的线性回归类。它具有`fit`和`predict`方法，类似于Scikit-learn中的`LinearRegression`类。但它还有更多功能。这里是一个小预览……

![](../Images/8c58fd137523c1bcd9c3dd1cd79a8707.png)

是的，这个估计器比Scikit-learn估计器更丰富，因为它除了标准的`fit`、`predict`和R² `score`函数外，还有**一系列线性回归建模任务所必需的其他实用工具**。

特别是对于数据科学家和统计建模人员——他们不仅想进行预测，还希望

+   衡量[拟合优度](https://blog.minitab.com/blog/adventures-in-statistics-2/regression-analysis-how-do-i-interpret-r-squared-and-assess-the-goodness-of-fit)，

+   验证[线性回归的假设](https://statisticsbyjim.com/regression/ols-linear-regression-assumptions/)，

+   检查数据中的[多重共线性](https://blog.minitab.com/blog/understanding-statistics/handling-multicollinearity-in-regression-analysis)，或者

+   检测[异常值](https://stattrek.com/regression/influential-points.aspx)。

**[你如何在Python中检查回归模型的质量？](https://towardsdatascience.com/how-do-you-check-the-quality-of-your-regression-model-in-python-fa61759ff685?source=post_page-----7da416751f64----------------------)**

线性回归在统计学习中根深蒂固，因此模型必须检查“优度……

### 你如何开始构建这个类？

我们从一个简单的代码片段开始定义这个类。我们将其命名为`MyLinearRegression`。

在这里，`self`表示对象本身，`__init__`是[在创建类实例时调用的特殊函数](https://micropyramid.com/blog/understand-self-and-__init__-method-in-python-class/)。顾名思义，`__init__`可以用来初始化类及其必要的参数（如果有的话）。

![](../Images/70c02f5518e56cd53bb6ddc03a6d9c9a.png)

我们可以添加一个简单的描述字符串以保持真实性 :-)

![](../Images/6be0608e25d1f6584625e0e2da6593ef.png)

接下来我们添加核心的`fit`方法。注意[**文档字符串**](https://www.geeksforgeeks.org/python-docstrings/)，它描述了该方法的目的、功能以及它期望的数据类型。[这些都是良好面向对象编程原则的一部分](https://towardsdatascience.com/how-a-simple-mix-of-object-oriented-programming-can-sharpen-your-deep-learning-prototype-19893bd969bd)。

![](../Images/b0999e6f072e96e626a33d5bb4fee98f.png)

我们可以生成一些随机数据来测试我们的代码。目前，我们创建了一个两个变量的线性函数。这里是数据的散点图。

![](../Images/7f6ba261575fc70a25b26bb4a2b5df46.png)

现在，我们可以创建一个名为`mlr`的`MyLinearRegression`类的实例。如果我们尝试打印回归参数，会发生什么？

![](../Images/050574a0011945253ffa1324d61e849f.png)

因为 `self.coef_` 被设置为 `None`，所以在尝试打印 `mlr.coef_` 时得到相同的结果。注意，一旦创建了 `mlr`，`self` 就变成了类的实例的代名词。

但是 `fit` 的定义包括在拟合完成后设置属性。因此，我们可以直接调用 `mlr.fit()` 并打印拟合的回归参数。

![](../Images/49eef3affe2909fca466bf5317cf6d43.png)

### 典型的 `Predict` 方法

拟合之后，便是预测。我们可以轻松地将该方法添加到我们的回归类中。

![](../Images/adc25f937a8be3e2e63a7dbe181fc39e.png)

### 如果我们想添加一个（或几个）绘图实用函数怎么办？

在这一点上，我们开始扩展我们的回归类并 **添加标准 scikit-learn 类中甚至不存在的功能！** 例如，我们总是想看到拟合值与真实值的比较。为此创建一个函数很简单。我们将其命名为 `plot_fitted`。

注意 [方法就像普通函数](https://stackoverflow.com/questions/155609/whats-the-difference-between-a-method-and-a-function/29379748)。它可以接受额外的参数。在这里，我们有一个参数 `reference_line`（默认设置为 `False`），它在拟合与真实图上绘制了一个 45 度的参考线。还要注意文档字符串描述。

![](../Images/aa3ddeee84b3de9e4bd2fcd2c3992387.png)

我们可以通过简单地执行以下操作来测试方法 `plot_fitted`，

[PRE3]

或者，我们可以选择绘制参考线，

[PRE4]

我们得到以下图形！

![](../Images/dc458160e528deab2021214f05391f73.png)

一旦我们理解了可以向类中添加任何有用的方法以处理相同数据（训练集），与相同目的（线性回归）相关，我们的想象力就没有界限了！如何将以下图形添加到我们的类中？

+   **对角图**（绘制所有特征和输出之间的成对关系，很像 R 中的 `pairs` 函数）

+   **拟合值 vs. 残差** 图（这属于线性回归的诊断图，即检查基本假设的有效性）

+   **直方图** 和 **分位数-分位数 (Q-Q)** 图（用于检验误差分布的正态性假设）

### 继承 — 不要让你的主类负担过重

当我们热衷于计划添加到类中的实用方法时，我们认识到这种方法可能使主类的代码非常长且难以调试。为了解决这个难题，我们可以利用 OOP 的另一个美妙原则 — [**继承**](https://www.geeksforgeeks.org/inheritance-in-python/)。

**[Python 中的继承 - GeeksforGeeks](https://www.geeksforgeeks.org/inheritance-in-python/?source=post_page-----7da416751f64----------------------)**

继承是一个类从另一个类派生或继承属性的能力。好处包括...

我们进一步认识到**所有图形并不是同一类型**。配对图和拟合与真实数据图是类似的，因为它们仅能从数据中推导出。其他图形与拟合优度和残差相关。

因此，我们可以创建两个包含这些绘图功能的独立类——`Data_plots` 和 `Diagnostic_plots`。

猜猜怎么着！我们可以将我们的主类`MyLinearRegression` ***定义为这些工具类的组合***。这就是继承的实例。

**注意**：这可能与标准的父类-子类继承实践有所不同，但这里使用了相同的语言特性，以保持主类的简洁和紧凑，同时从其他类似构造的类中继承有用的方法。

![](../Images/dbf1bccc0045c88bdf44e7a8f63f493b.png)

请注意以下代码片段仅供说明。请使用上面的Github链接查看实际代码。

![图像](../Images/7e6d3e16ced328bdd829de63c91082f2.png)

`Data_plots` 类![图像](../Images/e7df0082a7f0bcc4978c3d4321977433.png)

`Diagnostics_plots` 类

`MyLinearregression` 的定义仅有轻微变化，

[PRE5]

只需将`Data_plots` 和 `Diagnostics_plots` 的引用传递给 `MyLinearRegression` 类的定义，我们就继承了这些类的所有方法和属性。

现在，为了检查误差项的正态性假设，我们可以简单地拟合模型并运行这些方法。

[PRE6]

我们得到，

![](../Images/4c438910375e2697d073be9b2086c20b.png)

同样，这里代码的分离也在起作用。你可以在不触及主类的情况下修改和改进核心绘图工具。高度灵活且更少出错的方式！

### 利用面向对象编程的强大功能做更多事情

我们不会进一步详细说明可以添加到`MyLinearRegression`的各种工具类和方法。你可以[**查看Github仓库**](https://github.com/tirthajyoti/Machine-Learning-with-Python/tree/master/OOP_in_ML)。

### 添加的额外类

为了完整性，我们添加了，

+   一个类`Metrics` 用于计算各种回归指标——SSE、SST、MSE、*R*²和调整后的*R*²。

+   一个类`Outliers` 用于绘制Cook距离、杠杆值和影响图

+   一个类`Multicollinearity` 用于计算方差膨胀因子 (VIF)

总的来说，宏观方案如下，

![](../Images/c7cd17cb8c128a37c79da2a641840506.png)

这个类比Scikit-learn的LinearRegression类更丰富吗？由你决定。

### 通过创建分组工具添加语法糖

一旦你继承了其他类，它们的行为就像你熟悉的普通Python模块一样。因此，你可以向主类添加工具方法，以一起执行子类中的多个方法。

例如，以下方法一次运行所有常见的诊断检查。注意我们是如何通过简单的**.DOT** 访问绘图方法，即`Diagnostics_plot.histogram_resid`。就像从Pandas或NumPy库中访问函数一样！

![图](../Images/5d7eb84d02341a5bb80965d32df8a8bb.png)

主类中的`run_diagnostics`方法

这样，我们可以在拟合数据后用一行代码运行所有的诊断。

[PRE7]

![](../Images/84ee9de902da24ad8cfd0c739fc0275e.png)

同样，你可以将所有的离群点图添加到一个实用方法中。

### 模块化——将类作为模块导入

虽然这不是一个经典的面向对象编程（OOP）原则，但遵循OOP范式的一个重要优势是[**能够模块化你的代码**](https://atomicobject.com/resources/oo-programming/encapsulation-modularity)。

你可以在标准Jupyter笔记本中实验和开发所有这些代码。但为了最大限度地模块化，考虑将笔记本转换为独立的可执行Python脚本（.py扩展名）。作为一个好的实践，从这个文件中移除所有不必要的注释和测试代码，只保留类。

[**这里是我为这篇文章整理的脚本链接**](https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/OOP_in_ML/Class_MyLinearRegression.py)。

一旦你这样做，你可以从一个完全不同的Notebook中导入`MyLinearRgression`类。这通常是**测试你的代码的推荐方式**，因为它不接触核心模型，而只是用各种数据样本和功能参数对其进行测试。

![](../Images/8abefd0c466c96cfb71776b25f19d539.png)

在这一点上，你可以考虑将这个Python脚本放在Github上，创建一个Setup.py文件，创建适当的目录结构，并[将其发布为一个独立的线性回归包](https://towardsdatascience.com/build-your-first-open-source-python-project-53471c9942a7)，该包进行拟合、预测、绘图、诊断等功能。

当然，你必须添加大量的[文档字符串描述](https://www.geeksforgeeks.org/python-docstrings/)、函数的使用示例、[断言检查](https://airbrake.io/blog/python-exception-handling/python-assertionerror)和[单元测试](http://softwaretestingfundamentals.com/unit-testing/)，以使其成为一个优秀的包。

> 但作为一名数据科学家，你现在已经为你的技能库添加了一项重要技能——遵循OOP原则的软件开发。

这并不难，对吧？

### 结尾

### 动机和相关文章

写这篇文章时，我受到[这篇精彩文章](https://dziganto.github.io/classes/data%20science/linear%20regression/machine%20learning/object-oriented%20programming/python/Understanding-Object-Oriented-Programming-Through-Machine-Learning/)的启发，该文章详细阐述了在机器学习背景下Python中的OOP概念。

**[通过机器学习理解面向对象编程](https://dziganto.github.io/classes/data%20science/linear%20regression/machine%20learning/object-oriented%20programming/python/Understanding-Object-Oriented-Programming-Through-Machine-Learning/?source=post_page-----7da416751f64----------------------)**

面向对象编程（OOP）并不容易理解。你可以一遍又一遍地阅读教程并筛选……

我写了一篇类似的文章，涉及更多基本方法，尤其是在深度学习的背景下。查看文章，

**[简单的面向对象编程混合如何提升你的深度学习原型](https://towardsdatascience.com/how-a-simple-mix-of-object-oriented-programming-can-sharpen-your-deep-learning-prototype-19893bd969bd?source=post_page-----7da416751f64----------------------)**

通过混合简单的面向对象编程概念，如功能化和类继承，你可以添加……

### 课程？

我尝试寻找相关课程，但如果你使用Python，找到的资源很少。大多数软件工程课程使用Java教授。这里有两个可能会有帮助的课程，

+   [数据科学家的Python软件工程](https://www.datacamp.com/courses/software-engineering-for-data-scientists-in-python)

+   [Python类和继承](https://www.coursera.org/learn/python-classes-inheritance/)

如果你有任何问题或想法，请通过[**tirthajyoti[AT]gmail.com**](mailto:tirthajyoti@gmail.com)联系作者。此外，你还可以查看作者的GitHub仓库，获取更多有趣的Python、R或MATLAB代码片段和机器学习资源。如果你和我一样，对机器学习/数据科学充满热情，请随时[在LinkedIn上添加我](https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/)或[关注我在Twitter上的动态。](https://twitter.com/tirthajyotiS)

[原文](https://towardsdatascience.com/object-oriented-programming-for-data-scientists-build-your-ml-estimator-7da416751f64)。经许可转载。

**相关内容：**

+   [简单的面向对象编程混合如何提升你的深度学习原型](/2019/08/simple-mix-object-oriented-programming-sharpen-deep-learning-prototype.html)

+   [数学编程——提升数据科学的关键习惯](/2019/05/mathematical-programming-key-habit-advancing-data-science.html)

+   [用Python优化：如何以最少的风险赚取最多的钱？](/2019/06/optimization-python-money-risk.html)

### 更多相关话题

+   [成为出色数据科学家所需的5项关键技能](https://www.kdnuggets.com/2021/12/5-key-skills-needed-become-great-data-scientist.html)

+   [每个初学者数据科学家应掌握的6种预测模型](https://www.kdnuggets.com/2021/12/6-predictive-models-every-beginner-data-scientist-master.html)

+   [2021年最佳ETL工具](https://www.kdnuggets.com/2021/12/mozart-best-etl-tools-2021.html)

+   [是什么让Python成为初创企业理想的编程语言](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)

+   [停止学习数据科学以寻找目的，并寻找目的去……](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)

+   [建立一个稳固的数据团队](https://www.kdnuggets.com/2021/12/build-solid-data-team.html)
