- en: How to do “Limitless” Math in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2021/10/limitless-math-python.html](https://www.kdnuggets.com/2021/10/limitless-math-python.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[comments](#comments)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/418f1da603edd720a002262c0db00ee0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Image source**: [Pixabay](https://pixabay.com/photos/steelwool-fire-infinite-firespin-458842/) (Free
    to use)'
  prefs: []
  type: TYPE_NORMAL
- en: Limitless math?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sounds like a catchy title? Well, what we really meant by that term is **arbitrary-precision
    computation** i.e. breaking away from the **restriction of 32-bit or 64-bit arithmetic** that
    we are normally familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a quick example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/38b45d0cdc8ef9f67786e226adfd4fe6.png)'
  prefs: []
  type: TYPE_IMG
- en: This is what you will get as the value for the square-root of 2 if you just
    import from the standard `math` module of Python.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Numpy to choose if you want the result to be 32-bit or 64-bit floating-point
    number.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/518f161f6fbca038f07629993195c0d4.png)'
  prefs: []
  type: TYPE_IMG
- en: But what if you wanted the result up to 25 decimal places…
  prefs: []
  type: TYPE_NORMAL
- en: '1.414213562373095048801689'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Or, 50 decimal places?
  prefs: []
  type: TYPE_NORMAL
- en: '1.4142135623730950488016887242096980785696718753769'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How are we getting these results?
  prefs: []
  type: TYPE_NORMAL
- en: Just by using a neat little package called `**mpmath**`. Let’s examine it in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary-precision computation with `mpmath`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Mpmath` is a Python library for arbitrary-precision floating-point arithmetic.
    For general information about `mpmath`, see the [project website](http://mpmath.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: From its [website](https://mpmath.org/doc/current/#advanced-mathematics), apart
    from arbitrary-precision arithmetic, “`*mpmath*`* provides extensive support for
    transcendental functions, evaluation of sums, integrals, limits, roots, and so
    on”*. It also does many standard mathematical tasks like,
  prefs: []
  type: TYPE_NORMAL
- en: Polynomials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root-finding and optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sums, products, limits, and extrapolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical integration (quadrature)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving ordinary differential equations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function approximation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical inverse Laplace transform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, it’s a power-packed math library with limitless possibilities! We
    will explore some of the features in this article.
  prefs: []
  type: TYPE_NORMAL
- en: '**arbitrary-precision computation is **breaking away from the **restriction
    of 32-bit or 64-bit arithmetic** that we are normally familiar with…'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Installing and choosing a fast backend engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just pip.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By default, `mpmath` uses Python integers internally. If `[gmpy](https://code.google.com/p/gmpy/)` version
    1.03 or later is installed in the system, `mpmath` will automatically detect it
    and use `gmpy` integers w/o any change to the high-level user experience. Using
    this backend makes its operations much faster, especially at high precision.
  prefs: []
  type: TYPE_NORMAL
- en: '`gmpy2` is a **C-coded Python extension module** that supports multiple-precision
    arithmetic. [**Here is how to install it**](https://gmpy2.readthedocs.io/en/latest/intro.html#installation).'
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the [Notebook with all the code](https://github.com/tirthajyoti/Stats-Maths-with-Python/blob/master/mpmath-1.ipynb) shown
    in this article.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Precision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a whole lot of material about choosing and controlling precision with `mpmath`.
    Readers are encouraged to consult [this reference directly](https://mpmath.org/doc/current/basics.html).
  prefs: []
  type: TYPE_NORMAL
- en: I am just going to show you the quick way to set precision as you work along.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f731fd70fab5a4f8a23193bfd8ef6726.png)'
  prefs: []
  type: TYPE_IMG
- en: You can print the `mp` context anytime to see the current global precision settings.
    The `mp.prec` shows the precision in bits and `mp.dps` shows in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a8839e3bc1ad8113bfe8e9654f7623c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Use ``mpf`` instances instead of regular float
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the code snippets above you might have noticed a function `mpf`. An `mpf` instance
    holds a real-valued floating-point number. They work analogously to Python floats,
    but support arbitrary-precision arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: You should define `mpf` using strings (and not Python floats) as arguments to
    get true accuracy. You can also set `mp.pretty` to `True` for rounding w/o losing
    the internal accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/be7d7c7fa4663b3f81d27aeb4c9c7f82.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](../Images/7108f7ae37a7395070b9181bd836683d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now some magic! Factorial calculation 11,000 times faster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mpmath` can do large calculations using smart tricks whenever applicable.
    One example is factorial. For large numbers, it can use approximations appropriately
    without being instructed and give us the result much faster than the default Python
    math module.
  prefs: []
  type: TYPE_NORMAL
- en: Here is what happens when we attempt to calculate the factorial of 100,000. `mpmath` is **11,333X
    faster**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6cef4d5219e16dc5e367ec78b38e050d.png)'
  prefs: []
  type: TYPE_IMG
- en: Rational and complex numbers are native citizens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can throw in rational or complex numbers as easily as floating-point numbers
    into the mix. For this, we need to use a magic function `**mpmathify**` which
    works with `**sympy**` internals to interpret those quantities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/63db5f296a89cb4e3b382a59092b2446.png)'
  prefs: []
  type: TYPE_IMG
- en: We don’t have to import Python modules like `[**fraction**](https://docs.python.org/3/library/fractions.html)` or `[**cmath**](https://docs.python.org/3/library/cmath.html)` to
    work with such quantities at a precision of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Learn about all other [general utility functions that ](https://mpmath.org/doc/current/general.html)`[mpmath](https://mpmath.org/doc/current/general.html)`[ offers
    here](https://mpmath.org/doc/current/general.html).
  prefs: []
  type: TYPE_NORMAL
- en: Quick plotting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If Matplotlib is available on the system, `mpmath` offers a fast and easy plotting
    choice just by passing a list of functions and the corresponding ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a single-line code example,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9cdc119df497a054554836b11075afe5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Image source**: Generated by the author'
  prefs: []
  type: TYPE_NORMAL
- en: Another example with [Fresnel functions](https://en.wikipedia.org/wiki/Fresnel_integral),
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9d7383e601178bd033d5d79d0e7be8b7.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Image source**: Generated by the author'
  prefs: []
  type: TYPE_NORMAL
- en: Complex quantities can be plotted as easily with `cplot`. By default, the complex
    argument (phase) is shown as color (hue) and the magnitude is shown as brightness.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0e600123b97fa9d5021df5db1212ac48.png)![](../Images/efc1545296ece318cf8e9a04fd9eeed0.png)**Image
    source**: Generated by the author'
  prefs: []
  type: TYPE_NORMAL
- en: Surface plots are also game,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d936db770139f81e14bdd6da30c38581.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Image source**: Generated by the author'
  prefs: []
  type: TYPE_NORMAL
- en: Special functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mpmath` supports hundreds of special functions out-of-the-box. Here is a partial
    screenshot of that list. Refer to this documentation for details.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5bb0d1bfbd8ebf4bcd96093dd493696b.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](../Images/2937704eaefc538e246628f69b258538.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](../Images/f86daf22f90b8e6b1eb813960f3fb25e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Image source**: Generated by the author'
  prefs: []
  type: TYPE_NORMAL
- en: Binomial coefficients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fast and easy computation of binomial coefficients for statistics and combinatorial
    math with `binomial` function,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/67608c71757f619c61f0713f340834f0.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](../Images/2d619ef98c4b0913498d584de3b5cbec.png)'
  prefs: []
  type: TYPE_IMG
- en: This function supports **massively large arguments, which is where this really
    shines**. Scipy calculation is faster but for large numbers, Scipy does not even
    run!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f71a76a939b65c7358f2be5d4a3f6a6d.png)'
  prefs: []
  type: TYPE_IMG
- en: And, extensions to non-integers and negative arguments are natural (using Gamma
    function),
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b8adf27f87e432e8768bc84649e8d3ee.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](../Images/bb9454a828a3c7119ff0ae06499c65b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Hyperfactorials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For integers, hyperfactorials are defined as,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/65bf3558a90616d6434a19f7cded40ac.png)'
  prefs: []
  type: TYPE_IMG
- en: They are really large. Can you think of an easy way to calculate this kind of
    number?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8853e4e7575bdfe3f3ecb0e0bf7c1725.png)'
  prefs: []
  type: TYPE_IMG
- en: This number is 1.1425…something followed by 41908 zeroes! To get an idea about
    that, just consider this fact — there are roughly [10⁸⁰ atoms in the universe](https://www.thoughtco.com/number-of-atoms-in-the-universe-603795) i.e.
    1 followed by 80 zeros.
  prefs: []
  type: TYPE_NORMAL
- en: Limitless math (in a fast manner), isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calculating the Fibonacci sequence with naive Python (recursive function) is
    a popular interview question because it can be done in a few different ways which
    differ dramatically in efficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: However, calculating approximate solutions with large arguments or non-integer
    (even complex) arguments is natural and easy for `mpmath`. This is not so straightforward
    to achieve using native Python coding.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d621a23a7d0264ebc8f91298d003658d.png)'
  prefs: []
  type: TYPE_IMG
- en: Polynomial evaluation and roots
  prefs: []
  type: TYPE_NORMAL
- en: Easy and fast evaluation of polynomials of any order and root finding using `polyeval` and `polyroots` functions.
    Of course, `polyroots` evaluates all real and complex roots at one go.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4e47e25465d0fae02a57739228b119a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Root-finding of arbitrary functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `rootfind` function to search for roots of any arbitrary function.
    Here is an example,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/37a1dfab44e93c99922c8fce069c15a2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Image source**: Generated by the author'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we look for solutions near all the integers from -2 to 5 and it finds
    multiple solutions corresponding to all the values of x at which the function
    crosses zero.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/38d0ed8ab7cb18156d98355b2b019a00.png)'
  prefs: []
  type: TYPE_IMG
- en: Numerical calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Evaluate derivatives of any order and any function,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/610ea28d82304333574bf52b5b7eaa81.png)'
  prefs: []
  type: TYPE_IMG
- en: Partial derivatives are easy,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/72fef53fb77c38febf39fa09dd374c9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Look at [this reference](https://mpmath.org/doc/current/calculus/differentiation.html) to
    see other advanced examples and functions related to derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: 1-D integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple and fast evaluation to arbitrary precision,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/662bdb6ffaaedc141262138212378317.png)'
  prefs: []
  type: TYPE_IMG
- en: 2-D or 3-D integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two- or three-dimensional integrals are also game!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f078a7c0d85a8bdfa994fdb42f52e40d.png)'
  prefs: []
  type: TYPE_IMG
- en: Read more [details here](https://mpmath.org/doc/current/calculus/integration.html).
  prefs: []
  type: TYPE_NORMAL
- en: Ordinary differential equation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `odefun` to solve for ordinary differential equations with known
    boundary conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ca6855e9b70af69d2a87803d8dc25931.png)'
  prefs: []
  type: TYPE_IMG
- en: Or, a more difficult one,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/af3bfcab740e3e1ec6837cce2ce1464e.png)'
  prefs: []
  type: TYPE_IMG
- en: Matrix and linear algebra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mpmath` package also offers all the standard operations involving matrices
    and linear algebra. For brevity, we just [refer to the documentation](https://mpmath.org/doc/current/matrices.html) here
    instead of showing examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this article, we showed a powerful Python library and its capabilities for
    performing arbitrary-precision numerical computation involving all kinds of numbers
    and functions. Basically, the main advantage of this library is that it covers
    a very large swath of mathematical domains (algebraic, number-theory, calculus,
    special functions, etc.) and **everything is available under a single roof without
    loading multiple libraries**.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the usages of this library are in complex scientific/ technological
    domains such as finite-element simulations or cryptography, but as a number-enthusiast,
    you can always pick up useful functions from this package whenever you need for
    your data science or machine learning work.
  prefs: []
  type: TYPE_NORMAL
- en: Again, here is the [Notebook with all the code](https://github.com/tirthajyoti/Stats-Maths-with-Python/blob/master/mpmath-1.ipynb) shown
    in this article.
  prefs: []
  type: TYPE_NORMAL
- en: Happy number crunching!
  prefs: []
  type: TYPE_NORMAL
- en: You can check the author’s [**GitHub**](https://github.com/tirthajyoti?tab=repositories)** repositories **for
    code, ideas, and resources in machine learning and data science. If you are, like
    me, passionate about AI/machine learning/data science, please feel free to [add
    me on LinkedIn](https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/) or [follow
    me on Twitter](https://twitter.com/tirthajyotiS).
  prefs: []
  type: TYPE_NORMAL
- en: '**Bio: [Tirthajyoti Sarkar](https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/)**
    is a Data Science/ML Manager at Adapdix Corp. He contributes regularly to publications
    such as KDnuggets and TDS on diverse topics related to data science and machine
    learning. He has authored data science books and contributes to open source software.
    Tirthajyoti holds a Ph.D. in EE and is working on an M.S. degree in Computational
    Data Analytics. Email him at tirthajyoti at gmail[dot]com.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Essential Math for Data Science:  ‘Why’ and ‘How’](/2018/09/essential-math-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why and how should you learn “Productive Data Science”?](/2021/07/learn-productive-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Teaching AI to Classify Time-series Patterns with Synthetic Data](/2021/10/teaching-ai-classify-time-series-patterns-synthetic-data.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[How To Overcome The Fear of Math and Learn Math For Data Science](https://www.kdnuggets.com/2021/03/overcome-fear-learn-math-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Essential Math for Data Science: Visual Introduction to Singular…](https://www.kdnuggets.com/2022/06/essential-math-data-science-visual-introduction-singular-value-decomposition.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Essential Math for Data Science: Eigenvectors and Application to PCA](https://www.kdnuggets.com/2022/06/essential-math-data-science-eigenvectors-application-pca.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Much Math Do You Need in Data Science?](https://www.kdnuggets.com/2020/06/math-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Learn Math for Machine Learning](https://www.kdnuggets.com/2022/02/learn-math-machine-learning.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets™ News 22:n07, Feb 16: How to Learn Math for Machine…](https://www.kdnuggets.com/2022/n07.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
