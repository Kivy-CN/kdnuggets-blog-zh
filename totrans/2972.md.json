["```py\n\nimport numpy\n\nimport GA\n\nimport pickle\n\nimport ANN\n\nimport matplotlib.pyplot\n\nf = open(\"dataset_features.pkl\", \"rb\")\n\ndata_inputs2 = pickle.load(f)\n\nf.close()\n\nfeatures_STDs = numpy.std(a=data_inputs2, axis=0)\n\ndata_inputs = data_inputs2[:, features_STDs>50]\n\nf = open(\"outputs.pkl\", \"rb\")\n\ndata_outputs = pickle.load(f)\n\nf.close()\n\n#Genetic algorithm parameters:\n\n#    Mating Pool Size (Number of Parents)\n\n#    Population Size\n\n#    Number of Generations\n\n#    Mutation Percent\n\nsol_per_pop = 8\n\nnum_parents_mating = 4\n\nnum_generations = 1000\n\nmutation_percent = 10\n\n#Creating the initial population.\n\ninitial_pop_weights = []\n\nfor curr_sol in numpy.arange(0, sol_per_pop):\n\n    HL1_neurons = 150\n\n    input_HL1_weights = numpy.random.uniform(low=-0.1, high=0.1,\n\n                                             size=(data_inputs.shape[1], HL1_neurons))\n\n    HL2_neurons = 60\n\n    HL1_HL2_weights = numpy.random.uniform(low=-0.1, high=0.1,\n\n                                             size=(HL1_neurons, HL2_neurons))\n\n    output_neurons = 4\n\n    HL2_output_weights = numpy.random.uniform(low=-0.1, high=0.1,\n\n                                              size=(HL2_neurons, output_neurons))\n\n    initial_pop_weights.append(numpy.array([input_HL1_weights,\n\n                                                HL1_HL2_weights,\n\n                                                HL2_output_weights]))\n\npop_weights_mat = numpy.array(initial_pop_weights)\n\npop_weights_vector = GA.mat_to_vector(pop_weights_mat)\n\nbest_outputs = []\n\naccuracies = numpy.empty(shape=(num_generations))\n\nfor generation in range(num_generations):\n\n    print(\"Generation : \", generation)\n\n    # converting the solutions from being vectors to matrices.\n\n    pop_weights_mat = GA.vector_to_mat(pop_weights_vector,\n\n                                       pop_weights_mat)\n\n    # Measuring the fitness of each chromosome in the population.\n\n    fitness = ANN.fitness(pop_weights_mat,\n\n                          data_inputs,\n\n                          data_outputs,\n\n                          activation=\"sigmoid\")\n\n    accuracies[generation] = fitness[0]\n\n    print(\"Fitness\")\n\n    print(fitness)\n\n    # Selecting the best parents in the population for mating.\n\n    parents = GA.select_mating_pool(pop_weights_vector,\n\n                                    fitness.copy(),\n\n                                    num_parents_mating)\n\n    print(\"Parents\")\n\n    print(parents)\n\n    # Generating next generation using crossover.\n\n    offspring_crossover = GA.crossover(parents,\n\n                                       offspring_size=(pop_weights_vector.shape[0]-parents.shape[0], pop_weights_vector.shape[1]))\n\n    print(\"Crossover\")\n\n    print(offspring_crossover)\n\n    # Adding some variations to the offsrping using mutation.\n\n    offspring_mutation = GA.mutation(offspring_crossover,\n\n                                     mutation_percent=mutation_percent)\n\n    print(\"Mutation\")\n\n    print(offspring_mutation)\n\n    # Creating the new population based on the parents and offspring.\n\n    pop_weights_vector[0:parents.shape[0], :] = parents\n\n    pop_weights_vector[parents.shape[0]:, :] = offspring_mutation\n\npop_weights_mat = GA.vector_to_mat(pop_weights_vector, pop_weights_mat)\n\nbest_weights = pop_weights_mat [0, :]\n\nacc, predictions = ANN.predict_outputs(best_weights, data_inputs, data_outputs, activation=\"sigmoid\")\n\nprint(\"Accuracy of the best solution is : \", acc)\n\nmatplotlib.pyplot.plot(accuracies, linewidth=5, color=\"black\")\n\nmatplotlib.pyplot.xlabel(\"Iteration\", fontsize=20)\n\nmatplotlib.pyplot.ylabel(\"Fitness\", fontsize=20)\n\nmatplotlib.pyplot.xticks(numpy.arange(0, num_generations+1, 100), fontsize=15)\n\nmatplotlib.pyplot.yticks(numpy.arange(0, 101, 5), fontsize=15)\n\nf = open(\"weights_\"+str(num_generations)+\"_iterations_\"+str(mutation_percent)+\"%_mutation.pkl\", \"wb\")\n\npickle.dump(pop_weights_mat, f)\n\nf.close()\n\n```", "```py\n\nimport numpy\n\nimport random\n\n# Converting each solution from matrix to vector.\n\ndef mat_to_vector(mat_pop_weights):\n\n    pop_weights_vector = []\n\n    for sol_idx in range(mat_pop_weights.shape[0]):\n\n        curr_vector = []\n\n        for layer_idx in range(mat_pop_weights.shape[1]):\n\n            vector_weights = numpy.reshape(mat_pop_weights[sol_idx, layer_idx], newshape=(mat_pop_weights[sol_idx, layer_idx].size))\n\n            curr_vector.extend(vector_weights)\n\n        pop_weights_vector.append(curr_vector)\n\n    return numpy.array(pop_weights_vector)\n\n# Converting each solution from vector to matrix.\n\ndef vector_to_mat(vector_pop_weights, mat_pop_weights):\n\n    mat_weights = []\n\n    for sol_idx in range(mat_pop_weights.shape[0]):\n\n        start = 0\n\n        end = 0\n\n        for layer_idx in range(mat_pop_weights.shape[1]):\n\n            end = end + mat_pop_weights[sol_idx, layer_idx].size\n\n            curr_vector = vector_pop_weights[sol_idx, start:end]\n\n            mat_layer_weights = numpy.reshape(curr_vector, newshape=(mat_pop_weights[sol_idx, layer_idx].shape))\n\n            mat_weights.append(mat_layer_weights)\n\n            start = end\n\n    return numpy.reshape(mat_weights, newshape=mat_pop_weights.shape)\n\ndef select_mating_pool(pop, fitness, num_parents):\n\n    # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\n\n    parents = numpy.empty((num_parents, pop.shape[1]))\n\n    for parent_num in range(num_parents):\n\n        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))\n\n        max_fitness_idx = max_fitness_idx[0][0]\n\n        parents[parent_num, :] = pop[max_fitness_idx, :]\n\n        fitness[max_fitness_idx] = -99999999999\n\n    return parents\n\ndef crossover(parents, offspring_size):\n\n    offspring = numpy.empty(offspring_size)\n\n    # The point at which crossover takes place between two parents. Usually, it is at the center.\n\n    crossover_point = numpy.uint8(offspring_size[1]/2)\n\n    for k in range(offspring_size[0]):\n\n        # Index of the first parent to mate.\n\n        parent1_idx = k%parents.shape[0]\n\n        # Index of the second parent to mate.\n\n        parent2_idx = (k+1)%parents.shape[0]\n\n        # The new offspring will have its first half of its genes taken from the first parent.\n\n        offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]\n\n        # The new offspring will have its second half of its genes taken from the second parent.\n\n        offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]\n\n    return offspring\n\ndef mutation(offspring_crossover, mutation_percent):\n\n    num_mutations = numpy.uint8((mutation_percent*offspring_crossover.shape[1])/100)\n\n    mutation_indices = numpy.array(random.sample(range(0, offspring_crossover.shape[1]), num_mutations))\n\n    # Mutation changes a single gene in each offspring randomly.\n\n    for idx in range(offspring_crossover.shape[0]):\n\n        # The random value to be added to the gene.\n\n        random_value = numpy.random.uniform(-1.0, 1.0, 1)\n\n        offspring_crossover[idx, mutation_indices] = offspring_crossover[idx, mutation_indices] + random_value\n\n    return offspring_crossover\n\n```", "```py\n\nimport numpy\n\ndef sigmoid(inpt):\n\n    return 1.0 / (1.0 + numpy.exp(-1 * inpt))\n\ndef relu(inpt):\n\n    result = inpt\n\n    result[inpt < 0] = 0\n\n    return result\n\ndef predict_outputs(weights_mat, data_inputs, data_outputs, activation=\"relu\"):\n\n    predictions = numpy.zeros(shape=(data_inputs.shape[0]))\n\n    for sample_idx in range(data_inputs.shape[0]):\n\n        r1 = data_inputs[sample_idx, :]\n\n        for curr_weights in weights_mat:\n\n            r1 = numpy.matmul(a=r1, b=curr_weights)\n\n            if activation == \"relu\":\n\n                r1 = relu(r1)\n\n            elif activation == \"sigmoid\":\n\n                r1 = sigmoid(r1)\n\n        predicted_label = numpy.where(r1 == numpy.max(r1))[0][0]\n\n        predictions[sample_idx] = predicted_label\n\n    correct_predictions = numpy.where(predictions == data_outputs)[0].size\n\n    accuracy = (correct_predictions / data_outputs.size) * 100\n\n    return accuracy, predictions\n\ndef fitness(weights_mat, data_inputs, data_outputs, activation=\"relu\"):\n\n    accuracy = numpy.empty(shape=(weights_mat.shape[0]))\n\n    for sol_idx in range(weights_mat.shape[0]):\n\n        curr_sol_mat = weights_mat[sol_idx, :]\n\n        accuracy[sol_idx], _ = predict_outputs(curr_sol_mat, data_inputs, data_outputs, activation=activation)\n\n    return accuracy\n\n```"]