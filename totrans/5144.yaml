- en: 4 Useful Intermediate SQL Queries for Data Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2022/12/4-useful-intermediate-sql-queries-data-science.html](https://www.kdnuggets.com/2022/12/4-useful-intermediate-sql-queries-data-science.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![4 Useful Intermediate SQL Queries for Data Science](../Images/44aeb01bc678cfb6066fcc2941b03b98.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Shubham Dhage](https://unsplash.com/@theshubhamdhage?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/data-science?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: So in this post, we will discuss some of the essential intermediate SQL queries
    for data professionals. We will discuss 4 SQL queries, and the question is, why
    learn these 4 SQL queries?
  prefs: []
  type: TYPE_NORMAL
- en: We all are familiar with making a database in **SQL, **but more important is
    knowing how to clean and filter data effectively according to our needs. That's
    how these queries help us, so let's see what these queries are
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigger in SQL, **and how to use it in our query?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Partition By** in SQL'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Limit in SQL, **and how do we use** LIMIT **syntax to limit our query in
    a SQL table?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**COALESCE function **in the SQL, and how it helps us to get rid of **NULL **values?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Trigger in SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![4 Useful Intermediate SQL Queries for Data Science](../Images/0fae18dd20bd6da1e32b8b1281f52e4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'TRIGGER in SQL | Source: Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we will talk about the power of **triggers in SQL.**
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a Trigger in SQL?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The trigger is a SQL code that runs automatically when an event is performed.
    for example: In the below query, our trigger runs when the user tries to Insert
    values in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: The trigger is mainly divided into three parts
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. Trigger_Time**'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Trigger_Event
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Table_name
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. Trigger_Time:** Trigger time means when you want this trigger to run,
    for example, before or after an event.'
  prefs: []
  type: TYPE_NORMAL
- en: In our below query, we used before why? Because we want our code to run before
    the code is inserted into our table.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Trigger_Event:** The trigger event is when we want to run this trigger,
    such as **INSERT**, **UPDATE**, and **DELETE**'
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, we use INSERT because we want to run our trigger when
    the INSERT event is performed.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Table_name:** table name is the name of our table'
  prefs: []
  type: TYPE_NORMAL
- en: '**So let''s discuss the trigger syntax in detail with a proper practical explanation**'
  prefs: []
  type: TYPE_NORMAL
- en: of the code between **BEGIN **and **END **is whenever we insert a value in the
    Voter table, the trigger checks the age, whether it is less than 18 or greater
    than 18\. Nothing happens if it is greater than or equal to 18, but if it is less
    than 18, the trigger will show an error, and we set the message.
  prefs: []
  type: TYPE_NORMAL
- en: For example, see the above image, **we set message_text = ' age must be >=18',** so
    whenever we try to **insert the value less than 18, this error message shows**.
    In the output section, when we try to insert Andrew, 17, the query shows an error,
    which contains our **custom message**. So that's what triggers in SQL and how
    to use them in your query.
  prefs: []
  type: TYPE_NORMAL
- en: '**Check the below code for a more practical understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 2\. Partition by in SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![4 Useful Intermediate SQL Queries for Data Science](../Images/26b5951da96782fef7329530dce67219.png)'
  prefs: []
  type: TYPE_IMG
- en: 'PARTITION BY in SQL | Source: Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: This post will discuss **partition **and how to use it in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: So the first question is, what is a **partition in SQL**?
  prefs: []
  type: TYPE_NORMAL
- en: '**The work of a partition is to group the rows with similar values but without
    limiting the rows.**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example for more clarity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Please see the second image above.**'
  prefs: []
  type: TYPE_NORMAL
- en: There are five rows in the table in which there is a column named gender with
    three male candidates and two female candidates, so what if we want a new column
    that shows the number of males and females?
  prefs: []
  type: TYPE_NORMAL
- en: The partition syntax group the rows according to a similar value, which means
    that in our query, we use partition by gender. It means that we want to group
    our rows according to gender, so there are only two unique values in the gender
    column first is M and the second is F, so it divides the rows into two groups.
  prefs: []
  type: TYPE_NORMAL
- en: 1 The rows which contain M in the gender column
  prefs: []
  type: TYPE_NORMAL
- en: 2 The rows have F in the gender column, so that's the work of partition in SQL,
    and we use the count function to count several rows in the group.
  prefs: []
  type: TYPE_NORMAL
- en: In the output, you can see that the new column is built whose name is no_of_male_female,
    and this column contains the number of rows in the group. For example, there are
    two rows in the F group, so it shows 2, and there are three rows in the M group,
    so it shows 3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Some might wonder**'
  prefs: []
  type: TYPE_NORMAL
- en: what the difference is between group by and partition by in SQL because both
    works are similar. So the answer is that if you use a group, your five rows convert
    only into two rows. Why?
  prefs: []
  type: TYPE_NORMAL
- en: Because the group by shows the number of groups, in our above query, our table
    is divided into two groups, M and F, so the group by only shows the first row
    of every group, which means that if the group contains ten rows but it shows only
    1 rowin the output because it shows 1 row of every group.
  prefs: []
  type: TYPE_NORMAL
- en: But if you use partition by then, your number of rows remains unchanged as you
    see the number of rows in the output and the number of rows in the table remains
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partition in SQL shows all rows.**'
  prefs: []
  type: TYPE_NORMAL
- en: Both have advantages and disadvantages you can use them according to your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Check the below code if you need it**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 3\. Limit query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![4 Useful Intermediate SQL Queries for Data Science](../Images/1b465a57842324bc9cc1f741dd091e87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'LIMIT in SQL | Source: Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIMIT in SQL and How it works, although LIMIT is not supported in some SQL
    databases, such as SQL servers and MS access.**'
  prefs: []
  type: TYPE_NORMAL
- en: LIMIT clause is widely used in SQL databases and primarily to limit the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: If we want to find the top 10 or worst ten albums from the database,
    then the limit is beneficial. We use LIMIT 10 in the last of the query, and our
    work is done.'
  prefs: []
  type: TYPE_NORMAL
- en: But here is a question how does LIMIT work, and how can we use it effectively?
  prefs: []
  type: TYPE_NORMAL
- en: '**We can use LIMIT in two types**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. LIMIT ( any constant value )**'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the below code selects the first eight rows from the table
  prefs: []
  type: TYPE_NORMAL
- en: '**SELECT * FROM table_name LIMIT 8;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. LIMIT(x, y)**'
  prefs: []
  type: TYPE_NORMAL
- en: It's a more precise way to limit our tables.
  prefs: []
  type: TYPE_NORMAL
- en: The x argument is used to eliminate several rows from the top.
  prefs: []
  type: TYPE_NORMAL
- en: The y argument shows the number of rows you want after elimination.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Select * FROM table_name LIMIT 3,2;**'
  prefs: []
  type: TYPE_NORMAL
- en: this query eliminates three rows from the top and then shows the two rows after
    eliminating the three rows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Check the below code.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 4\. COALESCE function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![4 Useful Intermediate SQL Queries for Data Science](../Images/3a5f300f8b55ce8a616c85e3bb05afb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'COALESCE function in SQL | Source: Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: Do you know that there are some great functions in SQL which save you time?
  prefs: []
  type: TYPE_NORMAL
- en: Here I am talking about the **COALESCE function,** and this function amazes
    you, so please read the full post.
  prefs: []
  type: TYPE_NORMAL
- en: '**The COALESCE function takes n number of values.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So let's understand this; please see the above 4th image. You see that there
    is an EMPLOYEE table that contains a column whose name is located, and in that
    column, there are 3 NULL values. So what if we want to replace that NULL value
    with a meaningful word? So as in the above image, we want to replace all the NULL
    values with the word Missing_value.
  prefs: []
  type: TYPE_NORMAL
- en: We can do that with COALESCE function simply by seeing the code in the above
    image. The COALESCE function replaces all the NULL values with the word Missing_value.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand COALESCE function step by step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: **The first argument we pass in the COALESCE function is the column
    name in which we want to find NULL values. That''s why we use location.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**: If it found some values, then nothing happens; as you will see
    in the output of the code in the image, the value remains the same, but if it
    found NULL values, then what it does that it simply replaces that NULL values
    with the word we give as the second argument in COALESCE function and we gave
    Missing_value as a second argument, and that''s why it replaces all NULL value
    present in the location column with Missing_value.'
  prefs: []
  type: TYPE_NORMAL
- en: So that's how to COALESCE function work in SQL. We were given the example of
    using a single column. We also do the same thing if we want to replace NULL values
    in multiple columns; we can also do that by following the above syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '**Check the below code.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I hope this post will briefly explain how you use these essential queries in
    SQL and what are the benefits of using it. If you have any questions, feel free
    to ask in the comment section.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Ashbab Khan](https://www.linkedin.com/in/ashbabkhan/)** is a data scientist,
    SQL expert, and creative tech writer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](https://medium.com/@ashbabkhan12/useful-intermediate-sql-queries-for-data-science-408c724b67d0).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[KDnuggets News, December 7: Top 10 Data Science Myths Busted • 4…](https://www.kdnuggets.com/2022/n47.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Free Intermediate Python Programming Crash Course](https://www.kdnuggets.com/2022/12/free-intermediate-python-programming-crash-course.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Optimize SQL Queries for Faster Data Retrieval](https://www.kdnuggets.com/2023/06/optimize-sql-queries-faster-data-retrieval.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top SQL Queries for Data Scientists](https://www.kdnuggets.com/top-sql-queries-for-data-scientists)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Tricky SQL Queries Solved](https://www.kdnuggets.com/2020/11/5-tricky-sql-queries-solved.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solving 5 Complex SQL Problems: Tricky Queries Explained](https://www.kdnuggets.com/2022/07/5-hardest-things-sql.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
