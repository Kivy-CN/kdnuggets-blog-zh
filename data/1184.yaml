- en: Streamlit Tips, Tricks, and Hacks for Data Scientists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 提示、技巧和黑客技巧，适合数据科学家
- en: 原文：[https://www.kdnuggets.com/2021/07/streamlit-tips-tricks-hacks-data-scientists.html](https://www.kdnuggets.com/2021/07/streamlit-tips-tricks-hacks-data-scientists.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2021/07/streamlit-tips-tricks-hacks-data-scientists.html](https://www.kdnuggets.com/2021/07/streamlit-tips-tricks-hacks-data-scientists.html)
- en: '[comments](#comments)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](#comments)'
- en: '**By [Kaveh Bakhtiyari](https://kaveh.bakhtiyari.com/), PhD Candidate in Artificial
    Intelligence, Data Scientist at SSENSE**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**由 [Kaveh Bakhtiyari](https://kaveh.bakhtiyari.com/)，人工智能博士候选人，SSENSE 数据科学家**'
- en: The data science team at SSENSE usually builds very complex tools and dashboards.
    On the other hand, their maintenance was a challenge for the team. It has been
    more than a year since the SSENSE data science team has been using [Streamlit](https://www.streamlit.io/) actively.
    Before employing Streamlit, we were using Dash, Flask, R Shiny, etc. to build
    our tools and make them available to stakeholders within the company. In October
    2019, we started to evaluate the potential power of Streamlit for our projects
    by understanding its benefits and how to integrate it into our data science infrastructure.
    At the end of 2019, we began some pilot projects on Streamlit instead of Flask
    and Dash.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SSENSE 的数据科学团队通常构建非常复杂的工具和仪表板。另一方面，它们的维护对团队来说是一个挑战。自从 SSENSE 数据科学团队积极使用 [Streamlit](https://www.streamlit.io/)
    已经超过一年了。在使用 Streamlit 之前，我们使用 Dash、Flask、R Shiny 等来构建我们的工具并使其对公司内的利益相关者可用。2019
    年 10 月，我们开始评估 Streamlit 在我们项目中的潜在能力，通过了解其优点以及如何将其整合到我们的数据科学基础设施中。到 2019 年底，我们开始了一些基于
    Streamlit 的试点项目，取代了 Flask 和 Dash。
- en: '* * *'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our Top 3 Course Recommendations
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的前三大课程推荐
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity)
    - 快速进入网络安全职业生涯'
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics)
    - 提升你的数据分析技能'
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport)
    - 支持你在 IT 领域的组织'
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: After the evaluation period of Streamlit, we quickly realized that it had a
    lot of potentials and that it could increase development pace, and decrease the
    maintenance effort significantly. Besides all the cool features and being easy
    to work with, Streamlit does not provide the customized behaviors, events, and
    UI designs that you could get from other web development libraries such as Flask.
    And eventually, because of the same limitations, it has been much easier to develop
    clean apps and maintain them easily in the long term. Its uniform UI was also
    a positive point from my point of view. Firstly, it is clear, clean, and responsive.
    Secondly, all team members can build tools with uniform designs. But still, how
    can we provide such custom elements which we had in our Flask applications? Well,
    the short answer is that it is not quite possible, but we can use some tricks
    and tips, which can help you to customize more on what you are designing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估了 Streamlit 之后，我们很快意识到它具有很大的潜力，可以加快开发速度，并显著减少维护工作。除了所有酷炫的功能和易于使用外，Streamlit
    不提供你可以从其他网络开发库（如 Flask）中获得的定制行为、事件和 UI 设计。最终，由于这些限制，开发干净的应用程序并在长期内轻松维护变得更容易。从我的角度来看，其统一的
    UI 也是一个积极点。首先，它清晰、简洁且响应迅速。其次，所有团队成员都可以创建具有统一设计的工具。但仍然，我们如何提供我们在 Flask 应用程序中拥有的自定义元素呢？简而言之，这并不完全可能，但我们可以使用一些技巧和窍门，帮助你在设计中进行更多自定义。
- en: Today, I am going to talk about a few tips that I learned within more than a
    year of using Streamlit, that you can also use to unleash your powerful DS/AI/ML
    (whatever they may be) applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我将讨论一些我在使用 Streamlit 超过一年的过程中学到的技巧，你也可以利用这些技巧来释放你强大的 DS/AI/ML（无论它们是什么）应用程序的潜力。
- en: Streamlit is an active open-source project and the community is providing new
    updates frequently. I personally have bookmarked their [Changelog page](https://docs.streamlit.io/en/stable/changelog.html) to
    keep track of new updates and features. Some of what we are discussing today are
    not natively supported in `Streamlit (0.82.0)`, which may not be the case in the
    future.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Streamlit 是一个活跃的开源项目，社区经常提供新更新。我个人已经将他们的[更新日志页面](https://docs.streamlit.io/en/stable/changelog.html)添加到书签中，以便跟踪新更新和功能。我们今天讨论的一些内容在`Streamlit
    (0.82.0)`中并未本地支持，但未来可能会有所变化。
- en: Page Config
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面配置
- en: This feature was initially introduced in the beta version, and it was moved
    to the Streamlit namespace in `version 0.70.0`. This cool feature allows you to
    set the page title, favicon, page layout mode, and sidebar state.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能最初是在测试版中引入的，后来在`version 0.70.0`中移到了 Streamlit 命名空间。这个很酷的功能允许你设置页面标题、网站图标、页面布局模式和侧边栏状态。
- en: By default, Streamlit sets the page title as the original python file name,
    with Streamlit favicon. Having this line of code, you can customize your page
    title, which is very beneficial if your users bookmark your apps. Then favicon
    allows them to differentiate the apps if they have many apps open in multiple
    browser tabs. Setting the layout and initial state of the sidebar can also run
    your app in the way you desire.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Streamlit 将页面标题设置为原始 Python 文件名，并使用 Streamlit 网站图标。使用这行代码，你可以自定义页面标题，这对于用户书签你的应用非常有利。然后，网站图标可以帮助他们区分如果他们在多个浏览器标签中打开了许多应用。设置布局和侧边栏的初始状态也可以让你的应用按照你希望的方式运行。
- en: 'Before introducing this functionality, some of these features could only be
    possible by injecting CSS into the page. For example, if you wanted to make a
    widescreen, you could do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入这一功能之前，有些功能只能通过将 CSS 注入页面来实现。例如，如果你想制作一个宽屏，可以做如下操作：
- en: This line must be the first Streamlit command on your page, and it can only
    be set once. Regardless of what you set for the layout (either centered or wide),
    users have control over them in the settings.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这行代码必须是页面上的第一个 Streamlit 命令，并且只能设置一次。无论你为布局设置了什么（居中或宽屏），用户都可以在设置中控制它们。
- en: Empty component
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空组件
- en: There are multiple occasions when you want to generate new elements on the page,
    or you want to replace an existing text or element with another. This is possible
    using `st.empty()`. This method creates an empty placeholder on your page, and
    moving forward you can replace it with any object or text that you want.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在多种情况下，你可能需要在页面上生成新元素，或者用另一个元素替换现有的文本或元素。这可以通过`st.empty()`实现。这个方法在页面上创建一个空的占位符，之后你可以用任何对象或文本替换它。
- en: The above code initially creates a placeholder on your page, then it writes *“this
    is a sample text.*” in that same place, and after that, it replaces it with an
    input number object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码最初在页面上创建一个占位符，然后在相同的位置写上*“这是一个示例文本。”*，之后将其替换为一个输入数字对象。
- en: This is very useful to have dynamic objects on the page, or simply showing the
    progress of some calculations such as progress percentage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这在页面上动态显示对象或显示某些计算进度（例如进度百分比）时非常有用。
- en: Query Strings
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询字符串
- en: Setting and retrieving query strings in your Streamlit apps is an experimental
    feature at the moment. I hope that it will be moved into the main namespace in
    the future since I personally love this feature. If you have wondered why we need
    query strings in Streamlit, you are not alone.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Streamlit 应用中设置和检索查询字符串目前是一个实验性功能。我希望它将来能够移入主命名空间，因为我个人非常喜欢这个功能。如果你曾经想知道为什么我们在
    Streamlit 中需要查询字符串，你并不孤单。
- en: When you set your customized inputs in query strings, it makes it possible for
    the users to share the links with the exact same parameters that they had. Otherwise,
    they have to enter their parameters as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在查询字符串中设置自定义输入时，用户可以分享带有完全相同参数的链接。否则，他们还需要输入自己的参数。
- en: The other use-case that I personally use is to share information between different
    Streamlit apps. In our team, each data scientist may work on different projects,
    and we may need to redirect users from one app to another. When we provide the
    link to the user to navigate to the other Streamlit app, we want to make sure
    that the user’s experience is as seamless as possible. Therefore, we pass the
    required parameters to the new app so that it loads with the data and analysis
    they are looking for.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人使用的另一个用例是共享不同 Streamlit 应用之间的信息。在我们的团队中，每个数据科学家可能在不同的项目上工作，我们可能需要将用户从一个应用程序重定向到另一个。当我们提供链接让用户导航到其他
    Streamlit 应用时，我们希望确保用户的体验尽可能无缝。因此，我们将所需的参数传递给新应用，以便它加载用户所寻找的数据和分析。
- en: For example, a few of our tools are related to the products that we have on
    the website (what a surprise). When they are viewing some analysis on Product
    1 on App 1, we want to make sure that once they go to App 2 to get more details
    or different analysis, it automatically shows Product 1, and the user does not
    need to reenter the information.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的一些工具与我们网站上的产品有关（真是惊喜）。当他们在应用 1 中查看产品 1 的分析时，我们希望确保一旦他们转到应用 2 获取更多细节或不同分析时，它会自动显示产品
    1，用户不需要重新输入信息。
- en: Running Streamlit in a Subfolder
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在子文件夹中运行 Streamlit
- en: There are scenarios in data science projects that we may need to have our Streamlit
    apps in a subfolder. In this case, since Streamlit runs the apps from a subfolder,
    the app does not have access to the libraries in the parent folders. In order
    to overcome this problem, we may need to either have our Streamlit main app file
    in the project root or add the root folder into the system path at the beginning
    of our Streamlit apps.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学项目中，我们可能需要将 Streamlit 应用放在子文件夹中。在这种情况下，由于 Streamlit 从子文件夹运行应用程序，该应用无法访问父文件夹中的库。为了解决这个问题，我们可能需要将
    Streamlit 主应用程序文件放在项目根目录中，或者在 Streamlit 应用程序的开头将根文件夹添加到系统路径中。
- en: Sessions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话
- en: Streamlit is a session-based application. It means that once a user comes to
    the app, Streamlit assigns him/her a session ID, and other consecutive actions
    and data transfers are associated with that session. Because of that when you
    have a process, it won’t affect the other simultaneous users unless you use caching.
    We will discuss **Caching** later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 是基于会话的应用程序。这意味着一旦用户访问应用程序，Streamlit 会为其分配一个会话 ID，其他连续的操作和数据传输都与该会话相关联。因此，当你有一个过程时，它不会影响其他同时的用户，除非你使用缓存。我们稍后会讨论**缓存**。
- en: By default, you do not have standard access to the Session controls in Streamlit,
    and it is not documented officially yet, and it is used for internal purposes
    only. However, you can still access them and make some benefits by using them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你没有对 Streamlit 中的会话控制的标准访问权限，这还没有正式记录，而且仅用于内部目的。然而，你仍然可以访问这些控制并从中获益。
- en: Streamlit apps are developed in a script-like format. It means that every interaction
    with the app will trigger the whole code to re-run from start to bottom. This
    makes Streamlit extremely easy to work with, but at the same time, very tricky
    to control consecutive events since there is no event handling capability for
    the developers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 应用程序以类似脚本的格式开发。这意味着对应用程序的每次交互都会触发从头到尾重新运行整个代码。这使得 Streamlit 非常易于使用，但同时也很难控制连续事件，因为开发者没有事件处理功能。
- en: Assume that you have a button (`st.button`) to start a process, and in the resulting
    screen, you want to give the user some interactive options to work with, for example,
    another checkbox, radio button, or simply another button. In this case, when you
    click on the first button (let’s call it `button_run`) becomes `True` when it
    reruns the whole code. There is nothing wrong, and the app runs smoothly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个按钮（`st.button`）用于启动一个过程，在结果屏幕中，你希望给用户一些交互选项，比如另一个复选框、单选按钮或简单的另一个按钮。在这种情况下，当你点击第一个按钮（我们称之为`button_run`）时，它在重新运行整个代码时会变为`True`。这没有问题，应用运行流畅。
- en: '![Image](../Images/4cab57e3eeb273633bf00868eb547656.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4cab57e3eeb273633bf00868eb547656.png)'
- en: Now, on the resulting page, there is another button (let’s call it `button_filter`)
    to filter the results. If you now click on the second button (`button_filter`),
    its value becomes `True`, and Streamlit runs the whole code again. But the problem
    is that now the first button (`button_run`) has become `False` because we did
    not click on that. In this case, when Streamlit reruns the whole code, there is
    the assumption that `button_run` is not clicked, and `button_filter` is clicked.
    And it does not remember that `button_run` was previously clicked. Therefore, `button_filter` clicked
    code will never be executed, because `button_filter` itself was the result of
    the first button, `button_run`click.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在生成的页面上，有另一个按钮（我们称之为 `button_filter`）用于过滤结果。如果你现在点击第二个按钮（`button_filter`），它的值变为
    `True`，Streamlit 会再次运行整个代码。但问题是现在第一个按钮（`button_run`）变成了 `False`，因为我们没有点击它。在这种情况下，当
    Streamlit 重新运行整个代码时，它假设 `button_run` 没有被点击，而 `button_filter` 被点击了。它不会记住 `button_run`
    之前被点击过。因此，`button_filter` 点击的代码将永远不会被执行，因为 `button_filter` 本身是第一个按钮 `button_run`
    点击的结果。
- en: '![Image](../Images/2437e39f0d955460a0d5bdb922d2c9f7.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../Images/2437e39f0d955460a0d5bdb922d2c9f7.png)'
- en: In such cases, we should register the events, so that Streamlit can remember
    when a user clicks on the first button, and once the next button is clicked, it
    can understand that these are two consecutive actions and both buttons should
    be considered as clicked.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该注册事件，以便 Streamlit 可以记住当用户点击第一个按钮时，并且一旦下一个按钮被点击时，它可以理解这些是连续的操作，两者都应该被视为点击。
- en: You may think that, well, we can save that information in a DB or temporary
    text file. It is possible, but how do you differentiate the potential different
    users?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，我们可以将这些信息保存到数据库或临时文本文件中。这是可能的，但你如何区分潜在的不同用户呢？
- en: Streamlit has a built-in undocumented Session object that can store some temporary
    information for every user. In this case, when a user clicks on `button_run`,
    we store the clicked event in the Session, and once `button_filter` is clicked,
    we can check if `button_run` was previously clicked to control the correct flow
    of data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 有一个内置的未文档化的 Session 对象，可以为每个用户存储一些临时信息。在这种情况下，当用户点击 `button_run` 时，我们将点击事件存储在
    Session 中，而一旦 `button_filter` 被点击，我们可以检查 `button_run` 是否之前被点击过，以控制数据的正确流动。
- en: 'Here is the session class that you can include in your app:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你可以在应用中包含的会话类：
- en: Once you have the session class added, you can use the session to store and
    retrieve the information.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了会话类，你可以使用会话来存储和检索信息。
- en: SQLAlchemy
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLAlchemy
- en: SQLAlchemy is one of the standard popular libraries to connect to multiple types
    of databases such as SQLite, MySQL, etc. SQLAlchemy can be used for multiple platforms
    as desktop apps, web apps, or even mobile apps. If you have used this library
    before, you have realized that it is pretty simple, but when it comes to web development
    it may become a bit tricky. The main challenge of using this library for web applications
    is to control the number of database connections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 是连接到多种类型数据库（如 SQLite、MySQL 等）的标准流行库之一。SQLAlchemy 可以用于多种平台，如桌面应用、网页应用，甚至是移动应用。如果你以前使用过这个库，你会发现它相当简单，但在网络开发中可能会变得有些棘手。使用这个库进行
    Web 应用开发的主要挑战是控制数据库连接的数量。
- en: For that purpose, we have separate libraries for Flask (`sqlalchemy-flask`)
    and Tornado (`sqlalchemy-tornado`) which developers can use without any worry.
    But to my knowledge, we do not have any specific library for Streamlit. Since
    Streamlit is built upon Tornado, maybe we can use the tornado version, but I personally
    did not test that.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们有 Flask (`sqlalchemy-flask`) 和 Tornado (`sqlalchemy-tornado`) 的独立库，开发者可以放心使用。但据我所知，我们没有专门为
    Streamlit 提供的库。由于 Streamlit 是建立在 Tornado 之上的，也许我们可以使用 Tornado 版本，但我个人没有进行过测试。
- en: As you remember, Streamlit is session-based, which means that it runs a separate
    instance for every user. SQLAlchemy here is no exception. If you’re not careful,
    Streamlit will create a database connection for every user and maybe for every
    interaction. Depending on your database, your connections may get rejected if
    there are so many active connections available. As a result, python may end up
    with some strange error such as “double free or corruption” and crash your application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，Streamlit 是基于会话的，这意味着它为每个用户运行一个独立的实例。SQLAlchemy 也不例外。如果不小心的话，Streamlit
    会为每个用户甚至每次交互创建一个数据库连接。根据你的数据库，如果活动连接过多，你的连接可能会被拒绝。因此，Python 可能会出现一些奇怪的错误，如“双重释放或损坏”，并崩溃你的应用程序。
- en: In the Streamlit forum, there is a suggestion of caching the connection, which
    works well on SQLLite, but not very well on MySQL for example. When you cache
    your database connection, it won’t be open for an unlimited time, so that you
    may solve that issue with `ttl`. In this case, you can make sure that your connection
    object has expired before hitting a wall on the database side because the connection
    was already killed. Theoretically, this works fine if you have a very limited
    number of simultaneous users.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Streamlit 论坛上，有建议缓存连接，这在 SQLLite 上效果很好，但在 MySQL 上效果不佳。例如，当你缓存数据库连接时，它不会无限期保持打开状态，因此你可能需要通过`ttl`来解决这个问题。在这种情况下，你可以确保在连接对象到达数据库端时已经过期，因为连接已经被关闭。从理论上讲，如果你有非常有限的同时用户，这种方法效果很好。
- en: The main problem with caching the connection starts when two users run the code
    which caches the object at the same time. And at the end, the cached connection
    may not be the right one, but the expired one since there were two connections
    created at the same time, but only one was cached.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存连接的问题主要在于当两个用户同时运行缓存对象的代码时。最后，缓存的连接可能不是正确的连接，而是已经过期的连接，因为在同一时间创建了两个连接，但只有一个被缓存。
- en: SQLAlchamy has an object called Session, in which we can create our database
    connections (engines) and execute our SQL queries. This would check if the new
    connection is already existing in the pool, and if it is existing, it won’t create
    a new connection to prevent the database connection saturation issue. In this
    case, you do not need to use Streamlit caching anymore to store your database
    connection. The following code snippet will help you understand how to use Session
    to connect to MySQL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 有一个名为 Session 的对象，我们可以在其中创建数据库连接（引擎）并执行 SQL 查询。这会检查新连接是否已存在于池中，如果存在，它不会创建新连接以防止数据库连接饱和问题。在这种情况下，你不再需要使用
    Streamlit 缓存来存储数据库连接。以下代码片段将帮助你了解如何使用 Session 连接 MySQL。
- en: Remember that, prior to using Session in SQLAlchemy, if you were using engine
    only, you had to return `conn = engine.connect()` instead of the session, and
    you could use `df = pd.read_sql(query, conn)` to run the query. However, these
    methods are not working on SQLAlchemy Sessions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用 SQLAlchemy 的 Session 之前，如果你只使用引擎，你必须返回`conn = engine.connect()`而不是会话，你可以使用`df
    = pd.read_sql(query, conn)`来运行查询。然而，这些方法在 SQLAlchemy Sessions 中不起作用。
- en: Caching
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: Streamlit has very thorough, useful documentation on Caching, and honestly,
    it is one of its most useful features. Not using or misusing it can hugely impact
    the app performance and load/running time. I do not want to go through the details
    of caching which is already available in [Streamlit documentation](https://docs.streamlit.io/en/stable/caching.html) but
    only mentioning a few tips and findings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 有非常全面且有用的缓存文档，老实说，这是它最有用的功能之一。不使用或误用缓存会极大地影响应用性能和加载/运行时间。我不想详细讨论已经在[Streamlit
    文档](https://docs.streamlit.io/en/stable/caching.html)中提供的缓存内容，只提几个提示和发现。
- en: App Wide Access
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用范围访问
- en: Unlike Session objects, cached objects are app-wide accessible. It means that
    once you cache information, it is accessible to all users of the app. So it is
    important not to cache user-specific settings and data, and instead, we can use
    Session as we discussed earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Session 对象不同，缓存对象是全应用范围可访问的。这意味着一旦你缓存了信息，所有应用用户都可以访问。因此，重要的是不要缓存用户特定的设置和数据，而是如前所述使用
    Session。
- en: Caching Parameters
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存参数
- en: Caching mechanism has few parameters which can control how an object must be
    cached.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存机制有几个参数可以控制对象的缓存方式。
- en: '**ttl **`**<float, None>**`**:** This stands for Time-to-Live and sets how
    long a cached object must be alive. This expiry is set in seconds.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ttl `**<float, None>**`**:** 这代表生存时间，用于设置缓存对象的生存时间。这个过期时间以秒为单位。'
- en: '**max_entries **`**<int, None>**`**:** Once you start calling a function with
    different parameters, it starts caching all those variations, and in a short time,
    it can be a huge amount of cached data. This parameter can set how many variations
    of a function can be cached, and the old ones will be deleted. This controls and
    limits the amount of memory consumed.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**max_entries `**<int, None>**`**:** 一旦你开始调用具有不同参数的函数，它会开始缓存所有这些变化，并且在短时间内，缓存数据量可能非常庞大。此参数可以设置可以缓存的函数变化数量，旧的变化将被删除。这控制和限制了消耗的内存量。'
- en: '**persistent **`**<bool>**`**:** It is a boolean parameter to set if the cached
    data must be stored in a hard drive or memory. Just remember that, once you set
    it to True, Streamlit is pickling the object and storing it on the hard drive,
    and not all objects (such as SQLAlchamy database connection) can be pickled. So
    you may get an error for some persistent caching functions.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**persistent **`**<bool>**`**:** 这是一个布尔参数，用于设置缓存的数据是存储在硬盘还是内存中。只需记住，一旦将其设置为
    True，Streamlit 就会将对象序列化并存储在硬盘上，而并非所有对象（例如 SQLAlchemy 数据库连接）都可以被序列化。因此，对于一些持久缓存函数，你可能会遇到错误。'
- en: '**allow_output_mutation **`**<bool>**`**:** Once the output of a function is
    cached, if you change the output (mutate), the results will be stored in the cached
    object and as I mentioned earlier, this is accessible to all users. So the best
    practice is to avoid changing the cached object. But still, there are some cases
    where you need to change the cached object directly. In this case, this parameter
    would allow Streamlit to mutate the cached object.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allow_output_mutation **`**<bool>**`**:** 一旦函数的输出被缓存，如果你更改了输出（突变），结果将被存储在缓存对象中，正如我之前提到的，这对所有用户都是可访问的。因此，最佳实践是避免更改缓存对象。但仍然有一些情况下你需要直接更改缓存对象。在这种情况下，此参数将允许
    Streamlit 突变缓存对象。'
- en: '**suppress_st_warning **`**<bool>**`**:** Sometimes Streamlit raises some warnings
    to the user/developer so that they are aware of some consequences of caching.
    Setting this to False will stop those warnings.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**suppress_st_warning **`**<bool>**`**:** 有时 Streamlit 会向用户/开发者发出一些警告，以提醒他们缓存的某些后果。将此设置为
    False 将停止这些警告。'
- en: '**show_spinner **`**<bool>**`**:** Each time that Streamlit runs functions
    that are supposed to be cached, you will see a message on your UI saying “Running
    function_name”. It may not bother you that much unless you have lots of functions.
    Then you will see all those kinds of messages on your UI. Setting this parameter
    to False will prevent showing those messages.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**show_spinner **`**<bool>**`**:** 每当 Streamlit 运行应该被缓存的函数时，你会在 UI 上看到一条消息，显示“Running
    function_name”。除非你有很多函数，否则这可能不会太打扰你。如果你有很多函数，你会在 UI 上看到这些消息。将此参数设置为 False 将会阻止显示这些消息。'
- en: The above code only caches the results for 60 seconds, and it only keeps the
    last 20 variations of this function. It also does not show any warning, does not
    show you any message on Streamlit UI when running this function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅缓存结果 60 秒，并且只保留此函数的最后 20 个变体。它还不会显示任何警告，也不会在运行此函数时在 Streamlit UI 上显示任何消息。
- en: Since we set `allow_output_mutation` to `False`, the following code is not allowed,
    and we can not update (mutate) the result of the function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 `allow_output_mutation` 设置为 `False`，以下代码是不允许的，我们不能更新（突变）函数的结果。
- en: Clearing Cache
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除缓存
- en: There are some cases that you may need to clear the cache programmatically.
    Clearing all cached data is manually possible through the hamburger menu at the
    top right of the Streamlit apps, but if you want to do it programmatically, you
    can use the following undocumented method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下你可能需要以编程方式清除缓存。虽然可以通过 Streamlit 应用右上角的汉堡菜单手动清除所有缓存数据，但如果你想以编程方式进行，你可以使用以下未文档化的方法。
- en: SQLAlchemy Session / Scoped Session
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLAlchemy 会话 / 作用域会话
- en: Now that you could successfully connect to the database using SQLAlchemy Session,
    Scoped Session, and Pooling, you may need to cache your sessions or the functions
    that are using the database connection. As discussed earlier, since we are using
    Pool and Scoped Session, we may not need to cache the connection, but we may still
    need to cache our functions. Below, we are suggesting two recommendations on caching
    the functions that are using sessions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 SQLAlchemy 会话、作用域会话和连接池成功连接到数据库，你可能需要缓存会话或使用数据库连接的函数。如前所述，由于我们使用了连接池和作用域会话，我们可能不需要缓存连接，但仍然可能需要缓存我们的函数。以下是我们对缓存使用会话的函数的两个建议。
- en: The following example would use `hash_funcs` to identify which parameter of
    Session must be monitored for hashing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用 `hash_funcs` 来识别 Session 的哪个参数必须进行哈希监控。
- en: 'If the above example is not working, for example in the case of using `scoped_session`,
    you can simply ask Streamlit to ignore hashing session as below:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述示例不起作用，例如在使用 `scoped_session` 的情况下，你可以简单地要求 Streamlit 忽略哈希会话，如下所示：
- en: UI Hacks
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI 黑客
- en: '![](../Images/174d8e25e70c2ceb5398dcdedf7f7efc.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/174d8e25e70c2ceb5398dcdedf7f7efc.png)'
- en: The simplicity of Streamlit is because you do not need to deal with UI, and
    it comes with pre-built-in responsive UI elements which will be placed elegantly
    on your page. Even though in the recent versions, they have provided new beta
    updates which enable you to create columns and arrange your elements in them,
    there is not much customization to do with its UI.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 的简洁性在于你不需要处理 UI，它自带预构建的响应式 UI 元素，这些元素会优雅地放置在你的页面上。即使在最近的版本中，他们提供了新的
    beta 更新，允许你创建列并在其中排列元素，但对 UI 的自定义仍然有限。
- en: When I deploy my apps, there is a wide range of users in the company to work
    with them. I heavily use caching mechanisms to control the performance and speed
    of my apps. Some of my functions take a few minutes to run, and I use a caching
    mechanism to make sure that other users won’t wait again for the same request
    and will have a high-performance experience with the app. But, if a user clicks
    on that hamburger menu button at the top right, and selects “*Clear Cache*’’,
    it can hugely impact the performance of the app for the other users, until the
    function caches the results again. Or for example, some of my apps are designed
    to be shown the best in the wide mode, and if a user selects the “center” mode,
    it can affect how my app looks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我部署我的应用程序时，公司中有各种各样的用户在使用它们。我大量使用缓存机制来控制我的应用程序的性能和速度。我的一些函数需要几分钟才能运行，我使用缓存机制来确保其他用户不会再次等待相同的请求，并且能够获得高性能的应用体验。但是，如果用户点击右上角的汉堡菜单按钮，并选择“*清除缓存*”，这可能会对其他用户的应用性能产生巨大影响，直到函数再次缓存结果。例如，我的一些应用程序设计为在宽模式下显示最佳，如果用户选择“居中”模式，这可能会影响应用程序的显示效果。
- en: Besides all those that can directly affect my app, there are other options in
    the hamburger menu that a normal user may not need to have access to. For example,
    access to the Streamlit Github, documentation, etc.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些可能直接影响我的应用程序的选项外，汉堡菜单中还有一些普通用户可能不需要访问的选项。例如，访问 Streamlit Github、文档等。
- en: There is a [proposed idea on Streamlit Github](https://github.com/streamlit/streamlit/issues/395) to
    limit those hamburger menu options once the app is deployed, but until today,
    this issue is still open, and we can not manage them directly. Therefore, I came
    with my CSS solution to solve this issue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Streamlit Github 上提出的想法](https://github.com/streamlit/streamlit/issues/395)
    是限制应用程序部署后汉堡菜单选项的数量，但截至今天，这个问题仍然开放，我们无法直接管理它们。因此，我提出了我的 CSS 解决方案来解决这个问题。
- en: '![](../Images/3f26d4ff8debd215650e27fb445c425d.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3f26d4ff8debd215650e27fb445c425d.png)'
- en: In my proposed solution, you can remove (hide) the Streamlit footer, and control
    the items in the hamburger menu. You simply need to inject the following CSS into
    your application using `st.markdown` and allowing “unsafe” HTML codes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我提出的解决方案中，你可以移除（隐藏）Streamlit 页脚，并控制汉堡菜单中的项目。你只需使用 `st.markdown` 将以下 CSS 注入到你的应用程序中，并允许“危险的”
    HTML 代码。
- en: The numbers mentioned above in `li:nth-of-type(n)` are referring to the item
    element in the hamburger menu and their order may change in the future updates
    of Streamlit.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述数字在 `li:nth-of-type(n)` 中指的是汉堡菜单中的项目元素，它们的顺序可能在未来的 Streamlit 更新中发生变化。
- en: '![](../Images/c35a47b119a8f4d241d9c3743b069d88.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c35a47b119a8f4d241d9c3743b069d88.png)'
- en: Also, currently, there is an option in the hamburger menu (3rd item) called
    “**Deploy this app**”. This item is shown only if the app is accessed via a loopback
    local IP address (either `localhost` or `127.0.0.1`). If you access your app through
    your LAN/WAN IP address, this item will not be shown.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，目前在汉堡菜单中（第3项）有一个名为“**部署此应用**”的选项。只有当应用程序通过回环本地 IP 地址（`localhost` 或 `127.0.0.1`）访问时，此项目才会显示。如果你通过
    LAN/WAN IP 地址访问你的应用程序，则不会显示此项目。
- en: Record a Screencast
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 录制屏幕视频
- en: This feature was introduced in `version 0.55.0`, and I was personally thrilled
    by this feature which would allow us to record our apps for training and presentation
    purposes. Soon, we realized that this feature is not working for the other users
    accessing our Streamlit apps, and they get the following message upon clicking
    on that option.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在 `version 0.55.0` 中引入，我个人对这个功能感到兴奋，因为它允许我们录制我们的应用程序用于培训和演示目的。很快，我们意识到这个功能在其他访问我们
    Streamlit 应用程序的用户中不起作用，他们点击该选项时会收到以下消息。
- en: '![](../Images/27829e1ad85ecfa596f5ebb6bb347d4b.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/27829e1ad85ecfa596f5ebb6bb347d4b.png)'
- en: 'Because of the privacy restrictions implemented and imposed by the browsers,
    this feature works on the following conditions only:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器实施和强加的隐私限制，这个功能仅在以下条件下有效：
- en: Only on recent versions of Chrome, Firefox, and Edge
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在最新版本的Chrome、Firefox和Edge上
- en: Accessing either on `localhost` or `127.0.0.1`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问`localhost`或`127.0.0.1`
- en: If it is not being accessed locally, it must be behind an SSL certificate (https)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是本地访问，必须使用SSL证书（https）
- en: If you are serving your apps behind a proxy — such as `Nginx `— and you are
    aiming to use this feature, make sure that it is secured with an SSL certificate.
    Currently, Streamlit does not natively support SSL, but it can be deployed behind
    a proxy with an SSL certificate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用在代理后运行，例如`Nginx`，并且你打算使用此功能，请确保它通过SSL证书进行安全保护。目前，Streamlit本身不支持SSL，但可以在带有SSL证书的代理后部署。
- en: Components
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: Since the introduction of Streamlit components, developers have started building
    amazing components which can be served on Streamlit apps. If you would like, you
    can build your own components using Streamlit Component API. Streamlit has also
    a component gallery that presents some of the useful and interesting components
    which are publicly available. Among them, I have selected a few of them that I
    use to build amazing apps in SSENSE.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Streamlit组件的引入以来，开发者们开始构建出令人惊叹的组件，可以在Streamlit应用中使用。如果你愿意，你可以使用Streamlit组件API构建自己的组件。Streamlit还有一个组件库，展示了一些有用且有趣的公开组件。在这些组件中，我挑选了几个我在SSENSE中构建出色应用所使用的组件。
- en: ACE Editor
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ACE编辑器
- en: This editor is providing a color-coded editor for different programming languages.
    I personally use a lot of JSON data in my apps, and I use this editor to view
    and edit my JSON content. It is amazing since it can also capture my formatting
    structures and errors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编辑器提供了针对不同编程语言的颜色编码编辑器。我个人在我的应用中使用了很多JSON数据，我使用这个编辑器查看和编辑我的JSON内容。它非常出色，因为它还可以捕捉我的格式结构和错误。
- en: '![](../Images/deb2a35760340ac9539096b2e17e341d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/deb2a35760340ac9539096b2e17e341d.png)'
- en: '[https://github.com/okld/streamlit-ace](https://github.com/okld/streamlit-ace)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/okld/streamlit-ace](https://github.com/okld/streamlit-ace)'
- en: If you are tired of Streamlit standard multi-line text box, this component can
    be a very good alternative.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Streamlit标准的多行文本框感到厌倦，这个组件可能是一个很好的替代方案。
- en: Ag-Grid
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ag-Grid
- en: Streamlit can handle data frames, and it can show them in a table-based format
    either using `st.write` or `st.dataframe`. However, by default, Streamlit does
    not provide customized controllers on the presentation of your data frame except
    sorting by clicking on the column names.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit可以处理数据框，并可以使用`st.write`或`st.dataframe`以表格格式显示它们。然而，默认情况下，Streamlit不提供数据框呈现的自定义控制，除非点击列名进行排序。
- en: Ag-Grid is a grid component that can be imported into Streamlit. Using this
    component, not only can you present your data frame, but also include links, images,
    checkboxes, etc into your grid cells as well as filtering the data, searching,
    aggregate, and grouping them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ag-Grid是一个可以导入到Streamlit中的网格组件。使用这个组件，你不仅可以呈现你的数据框，还可以在网格单元格中包含链接、图片、复选框等，并进行数据过滤、搜索、汇总和分组。
- en: '![](../Images/edde0c61084ba5c10a4ee097cde34e79.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/edde0c61084ba5c10a4ee097cde34e79.png)'
- en: '[https://github.com/PablocFonseca/streamlit-aggrid](https://github.com/PablocFonseca/streamlit-aggrid)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PablocFonseca/streamlit-aggrid](https://github.com/PablocFonseca/streamlit-aggrid)'
- en: If you are dealing with showing data frames a lot, maybe it is time to give
    Ag-Grid a try to see its huge potential in your applications.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常需要展示数据框，也许是时候尝试Ag-Grid，看看它在你的应用中的巨大潜力。
- en: Lottie Animations
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lottie动画
- en: Last, but not least, in my list of components is Lottie Animations. If you check [lottiefiles.com](https://lottiefiles.com/),
    you will see thousands of vector-based animations in multiple formats such as
    JSON, which can be placed in your apps. This component would allow you to serve
    those Lottie animations by simply giving its JSON file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我列表中的组件是Lottie动画。如果你查看[lottiefiles.com](https://lottiefiles.com/)，你会看到成千上万的基于矢量的动画，格式多样，如JSON，可以放置在你的应用中。这个组件可以让你通过简单地提供JSON文件来展示这些Lottie动画。
- en: '![](../Images/589689f3e508e76664bcff4d79271868.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/589689f3e508e76664bcff4d79271868.png)'
- en: '[https://lottiefiles.com/968-loading](https://lottiefiles.com/968-loading)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://lottiefiles.com/968-loading](https://lottiefiles.com/968-loading)'
- en: I personally use these animations to show beautifully designed spinners while
    I am loading or calculating stuff. These animations will give a more vibrant and
    dynamic look to your next data science project.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人使用这些动画来展示在加载或计算时设计精美的旋转器。这些动画将为你下一个数据科学项目带来更生动和动态的效果。
- en: Final Words
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最后的话
- en: Here, I presented some tips and tricks on how to develop Streamlit applications.
    Some of these tricks may become natively available in the future versions of Streamlit,
    so that we may not need to do the hacks, or on the other hand, they may come with
    some updates to prevent our hacks. Who knows, but we can enjoy them for now, and
    hope for new amazing features in Streamlit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我展示了一些开发Streamlit应用的提示和技巧。这些技巧中的一些可能会在未来版本的Streamlit中原生提供，从而不再需要我们进行这些破解，另一方面，它们可能会带来一些更新以防止这些破解。谁知道呢，但我们现在可以享受这些技巧，并期待Streamlit的新功能。
- en: I would also like to thank the Streamlit community for building such an amazing
    tool.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要感谢Streamlit社区开发了如此出色的工具。
- en: '**Bio: [Kaveh Bakhtiyari](https://kaveh.bakhtiyari.com/)** is a PhD Candidate
    in Artificial Intelligence and a Data Scientist at SSENSE.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**个人简介：[Kaveh Bakhtiyari](https://kaveh.bakhtiyari.com/)** 是人工智能博士生，并且是SSENSE的数据科学家。'
- en: '[Original](https://medium.com/ssense-tech/streamlit-tips-tricks-and-hacks-for-data-scientists-d928414e0c16).
    Reposted with permission.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[原文](https://medium.com/ssense-tech/streamlit-tips-tricks-and-hacks-for-data-scientists-d928414e0c16)。已获许可转载。'
- en: '**Related:**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关内容：**'
- en: '[Deploying Streamlit Apps Using Streamlit Sharing](/2020/10/deploying-streamlit-apps-streamlit-sharing.html)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Streamlit Sharing部署Streamlit应用](/2020/10/deploying-streamlit-apps-streamlit-sharing.html)'
- en: '[Topic Modeling with Streamlit](/2021/05/topic-modeling-streamlit.html)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Streamlit进行主题建模](/2021/05/topic-modeling-streamlit.html)'
- en: '[Deploying Secure and Scalable Streamlit Apps on AWS with Docker Swarm, Traefik
    and Keycloak](/2020/10/deploying-secure-scalable-streamlit-apps-aws-docker-swarm-traefik-keycloak.html)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在AWS上使用Docker Swarm、Traefik和Keycloak部署安全且可扩展的Streamlit应用](/2020/10/deploying-secure-scalable-streamlit-apps-aws-docker-swarm-traefik-keycloak.html)'
- en: More On This Topic
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多相关内容
- en: '[10 Jupyter Notebook Tips and Tricks for Data Scientists](https://www.kdnuggets.com/2023/06/10-jupyter-notebook-tips-tricks-data-scientists.html)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学家的10个Jupyter Notebook提示与技巧](https://www.kdnuggets.com/2023/06/10-jupyter-notebook-tips-tricks-data-scientists.html)'
- en: '[Quick Data Science Tips and Tricks to Learn SAS](https://www.kdnuggets.com/2022/05/sas-quick-data-science-tips-tricks-learn.html)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[快速数据科学提示与技巧学习SAS](https://www.kdnuggets.com/2022/05/sas-quick-data-science-tips-tricks-learn.html)'
- en: '[12 VSCode Tips and Tricks for Python Development](https://www.kdnuggets.com/2023/05/12-vscode-tips-tricks-python-development.html)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12个Python开发的VSCode提示与技巧](https://www.kdnuggets.com/2023/05/12-vscode-tips-tricks-python-development.html)'
- en: '[Tips & Tricks of Deploying Deep Learning Webapp on Heroku Cloud](https://www.kdnuggets.com/2021/12/tips-tricks-deploying-dl-webapps-heroku.html)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在Heroku云上部署深度学习Web应用的提示与技巧](https://www.kdnuggets.com/2021/12/tips-tricks-deploying-dl-webapps-heroku.html)'
- en: '[Answering Questions with HuggingFace Pipelines and Streamlit](https://www.kdnuggets.com/2021/10/simple-question-answering-web-app-hugging-face-pipelines.html)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用HuggingFace管道和Streamlit回答问题](https://www.kdnuggets.com/2021/10/simple-question-answering-web-app-hugging-face-pipelines.html)'
- en: '[Streamlit for Machine Learning Cheat Sheet](https://www.kdnuggets.com/2023/01/streamlit-machine-learning-cheat-sheet.html)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Streamlit机器学习备忘单](https://www.kdnuggets.com/2023/01/streamlit-machine-learning-cheat-sheet.html)'
