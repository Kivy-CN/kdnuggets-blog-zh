- en: 'Mastering Python: 7 Strategies for Writing Clear, Organized, and Efficient
    Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/mastering-python-7-strategies-for-writing-clear-organized-and-efficient-code](https://www.kdnuggets.com/mastering-python-7-strategies-for-writing-clear-organized-and-efficient-code)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Mastering Python: 7 Strategies for Writing Clear, Organized, and Efficient
    Code](../Images/3e0d360397d3de2ed95cd5185703e278.png)Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever compared your Python code to that of experienced developers and
    felt a stark difference? Despite learning Python from online resources, there's
    often a gap between beginner and expert-level code. That's because experienced
    developers adhere to best practices established by the community. These practices
    are often overlooked in online tutorials but are crucial for large-scale applications.
    In this article, I will be sharing 7 tips that I use in my production code for
    clearer and more organized code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Type Hinting and Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a dynamically typed programming language, where the variable types
    are inferred at runtime. While it allows for flexibility, it significantly reduces
    code readability and understanding in a collaborative setting.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides support for type hinting in function declarations that serve
    as an annotation of the function argument types and the return types. Even though
    *Python doesn't enforce these types during runtime*, it's still helpful because
    it makes your code easier to understand for other people (and yourself!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a basic example, here is a simple function declaration with type
    hinting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, even though the function is fairly self-explanatory, we see that the function
    parameters and return values are denoted as int type. The function body could
    be a single line, as here, or several hundred lines. Yet, we can understand the
    pre-conditions and return types just by looking at the function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '*It''s important to know that these annotations are just for clarity and guidance;
    they don''t enforce the types during execution.* So, even if you pass in values
    of different types, like strings instead of integers, the function will still
    run. But be cautious: if you don''t provide the expected types, it might lead
    to unexpected behavior or errors during runtime. For instance, in the provided
    example, the function **sum()** expects two integers as arguments. But if you
    try to add a string and an integer, Python will throw a runtime error. Why? Because
    it doesn''t know how to add a string and an integer together! It''s like trying
    to add apples and oranges – it just doesn''t make sense. However, if both arguments
    are strings, it will concatenate them without any issue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the clarified version with test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Typing Library for Advanced Type Hinting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For advanced annotations, Python includes the typing standard library. Let us
    see its use in a more interesting approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we alter the same summation function that now accepts a numpy array or
    list iterable. It computes and returns their sum as a floating-point value. We
    utilize the Union annotation from the typing library to specify the possible types
    that the variable parameter can accept.
  prefs: []
  type: TYPE_NORMAL
- en: Let us further change the function declaration to show that the list members
    should also be of type float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These are just some beginner examples to help understand type hinting in Python.
    As projects grow, and codebases become more modular, type annotations significantly
    enhance readability and maintainability. The typing library offers a rich set
    of features including Optional, various iterables, Generics, and support for custom-defined
    types, empowering developers to express complex data structures and relationships
    with precision and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Writing Defensive Functions and Input Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though type-hinting seems helpful, it is still error-prone as the annotations
    are not enforced. These are just extra documentation for the developers but the
    function will still be executed if different argument types are used. Therefore,
    there is a need to enforce the pre-conditions for a function and code in a defensive
    manner. Hence, we manually check these types and raise appropriate errors if the
    conditions are violated.
  prefs: []
  type: TYPE_NORMAL
- en: The below function shows how interest is calculated using the input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is a simple operation, yet will this function work for every possible solution?
    No, not for the edge cases where the invalid values are passed as input. We need
    to ensure that the input values are bound within a valid range for the function
    to execute correctly. In essence, some pre-conditions must be satisfied for the
    function implementation to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note, that we use conditional statements for input validation. Python also has
    assertion statements that are sometimes used for this purpose. However, *assertions
    for input validation are not a best practice* as they can disabled easily and
    will lead to unexpected behaviour in production. The use of explicit Python conditional
    expressions is preferable for input validation and enforcing pre-conditions, post-conditions,
    and code invariants.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Lazy Loading with Generators and Yield Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider a scenario, where you are provided with a large dataset of documents.
    You need to process the documents and perform certain operations on each document.
    However, due to the large size, you can not load all the documents in memory and
    pre-process them simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution is to only load a document in memory when required and process
    only a single document at a time, also called lazy loading. Even though we know
    what documents we will need, we do not load a resource until it is required. There
    is no need to retain the bulk of documents in memory when they are not in active
    use in our code. This is exactly how generators and yield statements approach
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Generators allow lazy-loading that improves the memory efficiency of Python
    code execution. Values are generated on the fly as needed, reducing memory footprint
    and increasing execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the above function, the load_documents function uses the yield keyword. The
    method returns an object of type <class generator>. When we iterate over this
    object, it continues execution from where the last yield statement is. Therefore,
    a single document is loaded and processed, improving Python code efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Preventing Memory Leaks using Context Managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any language, efficient use of resources is of primary importance. We only
    load something in memory when required as explained above through the use of generators.
    However, it is equally important to close a resource when it is no longer needed
    by our program. We need to prevent memory leaks and perform proper resource teardown
    to save memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Context managers simplify the common use case of resource setup and teardown*.
    It is important to release resources when they are not required anymore, even
    in case of exceptions and failures. Context managers reduce the risk of memory
    leaks using automatic cleanup while keeping the code concise and readable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resources can have multiple variants such as database connections, locks, threads,
    network connections, memory access, and file handles. Let''s focus on the simplest
    case: file handles. The challenge here is ensuring that each file opened is closed
    exactly once. Failure to close a file can lead to memory leaks, while attempting
    to close a file handle twice results in runtime errors. To address this, file
    handles should be wrapped inside a **try-except-finally** block. This ensures
    that the file is closed properly, regardless of whether an error occurs during
    execution. Here''s how the implementation might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Python provides a more elegant solution using context managers, which
    handle resource management automatically. Here''s how we can simplify the above
    code using the file context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this version, we don't need to explicitly close the file. The context manager
    takes care of it, preventing potential memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: '​​While Python offers built-in context managers for file handling, we can also
    create our own for custom classes and functions. For class-based implementation,
    we define **__enter__** and **__exit__** dunder methods. Here''s a basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this custom context manager within **‘with’** blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This approach maintains the clean and concise syntax of context managers while
    allowing us to handle resources as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Separation of Concern with Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often see multiple functions with the same logic implemented explicitly.
    This is a prevalent code smell, and excessive code duplication makes the code
    difficult to maintain and unscalable. Decorators are used to encapsulate similar
    functionality in a single place. When a similar functionality is to be used by
    multiple other functions, we can reduce code duplication by implementing common
    functionality within a decorator. It follows Aspect-Oriented Programming (AOP)
    and the Single Responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are heavily used in the Python web frameworks such as Django, Flask
    and FastAPI. Let me explain the effectiveness of decorators by using it as a middleware
    in Python for logging. In a production setting, we need to know how long it takes
    to service a request. It is a common use case and will be shared across all endpoints.
    So, let us implement a simple decorator-based middleware that will log the time
    taken to service a request.
  prefs: []
  type: TYPE_NORMAL
- en: The dummy function below is used to service a user request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to log the time it takes for this function to execute. One way
    is to add logging within this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While this approach works, it leads to code duplication. If we add more routes,
    we'd have to repeat the logging code in each function. This increases code duplication
    as this shared logging functionality needs to be added to each implementation.
    We remove this with the use of decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logging middleware will be implemented as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, the outer function is the decorator, which accepts a
    function as input. The inner function implements the logging functionality, and
    the input function is called within the wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we simply decorate the original **service_request** function with our
    **request_logger decorator**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the @ symbol passes the service_request function to the request_logger
    decorator. It logs the time taken and calls the original function without modifying
    its code. This separation of concerns allows us to easily add logging to other
    service methods in a similar manner like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 6\. Match Case Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Match statements were introduced in Python3.10 so it is a fairly new addition
    to the Python syntax. It allows for simpler and more readable pattern matching,
    preventing excessive boilerplate and branching in the typical if-elif-else statements.
  prefs: []
  type: TYPE_NORMAL
- en: For pattern-matching, match case statements are the more natural way of writing
    it as they do not necessarily need to return boolean values as in conditional
    statements. The following example from the Python documentation shows how match
    case statements offer flexibility over conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As per the documentation, without pattern matching, this function’s implementation
    would require several *isinstance()* checks, one or two *len()* calls, and a more
    convoluted control flow. Under the hood, the match example and the traditional
    Python version translate into similar code. However, with familiarity with pattern
    matching, the match case approach is likely to be preferred as it provides a clearer
    and more natural syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, match case statements offer an improved alternative for pattern matching,
    which will likely become more prevalent in newer codebases.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. External Configuration Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In production, the majority of our code relies on external configuration parameters
    like API keys, passwords, and various settings. Hardcoding these values directly
    into the code is considered poor practice for scalability and security reasons.
    Instead, it's crucial to keep configurations separate from the code itself. We
    commonly achieve this using configuration files such as JSON or YAML to store
    these parameters, ensuring they're easily accessible to the code without being
    directly embedded within it.
  prefs: []
  type: TYPE_NORMAL
- en: An everyday use case is database connections that have multiple connection parameters.
    We can keep these parameters in a separate YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle this configuration, we define a class called **DatabaseConfig**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the **from_dict** class method serves as a builder method for the DatabaseConfig
    class, allowing us to create a database configuration instance from a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our main code, we can employ parameter hydration and the builder method
    to create a database configuration. By reading the external YAML file, we extract
    the database dictionary and use it to instantiate the config class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This approach eliminates the need for hardcoding database configuration parameters
    directly into the code. It also offers an improvement over using argument parsers,
    as we no longer need to pass multiple parameters every time we run our code. Moreover,
    by accessing the config file path through an argument parser, we can ensure that
    the code remains flexible and doesn't rely on hardcoded paths. This method facilitates
    easier management of configuration parameters, which can be modified at any time
    without requiring changes to the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Ending Notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this article, we discussed some of the best practices used in the industry
    for production-ready code. These are common industry practices that alleviate
    multiple problems one can face in real-life situations.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, it is worth noting that despite all such best practices, documentation,
    docstrings, and test-driven development are by far the most essential practices.
    It is important to think about what a function is supposed to do and then document
    all design decisions and implementations for the future as people working on a
    codebase change over time. If you have any insights or practices you swear by,
    please do not hesitate to let us know in the comment section below.
  prefs: []
  type: TYPE_NORMAL
- en: '**[](https://www.linkedin.com/in/kanwal-mehreen1/)**[Kanwal Mehreen](https://www.linkedin.com/in/kanwal-mehreen1/)****
    Kanwal is a machine learning engineer and a technical writer with a profound passion
    for data science and the intersection of AI with medicine. She co-authored the
    ebook "Maximizing Productivity with ChatGPT". As a Google Generation Scholar 2022
    for APAC, she champions diversity and academic excellence. She''s also recognized
    as a Teradata Diversity in Tech Scholar, Mitacs Globalink Research Scholar, and
    Harvard WeCode Scholar. Kanwal is an ardent advocate for change, having founded
    FEMCodes to empower women in STEM fields.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[How To Write Efficient Python Code: A Tutorial for Beginners](https://www.kdnuggets.com/how-to-write-efficient-python-code-a-tutorial-for-beginners)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Tips for Writing Better Python Functions](https://www.kdnuggets.com/5-tips-for-writing-better-python-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Announcing a Blog Writing Contest, Winner Gets an NVIDIA GPU!](https://www.kdnuggets.com/2022/11/blog-writing-contest-nvidia-gpu.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Free MIT Course: TinyML and Efficient Deep Learning Computing](https://www.kdnuggets.com/free-mit-course-tinyml-and-efficient-deep-learning-computing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Data Masking: The Core of Ensuring GDPR and other Regulatory…](https://www.kdnuggets.com/2023/05/data-masking-core-ensuring-gdpr-regulatory-compliance-strategies.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LLM Handbook: Strategies and Techniques for Practitioners](https://www.kdnuggets.com/llm-handbook-strategies-and-techniques-for-practitioners)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
