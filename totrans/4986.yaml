- en: What is a Support Vector Machine, and Why Would I Use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2017/02/yhat-support-vector-machine.html](https://www.kdnuggets.com/2017/02/yhat-support-vector-machine.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This post originally appeared on the [Yhat blog](http://blog.yhat.com/). [**Yhat**](https://www.yhat.com/)
    is a Brooklyn based company whose goal is to make data science applicable for
    developers, data scientists, and businesses alike. Yhat provides a software platform
    for deploying and managing predictive algorithms as REST APIs, while eliminating
    the painful engineering obstacles associated with production environments like
    testing, versioning, scaling and security.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: What is SVM?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SVM is a supervised machine learning algorithm which can be used for classification
    or regression problems. It uses a technique called the kernel trick to transform
    your data and then based on these transformations it finds an optimal boundary
    between the possible outputs. Simply put, it does some extremely complex data
    transformations, then figures out how to seperate your data based on the labels
    or outputs you've defined.
  prefs: []
  type: TYPE_NORMAL
- en: So what makes it so great?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Well SVM it capable of doing both classification and regression. In this post
    I'll focus on using SVM for classification. In particular I'll be focusing on
    non-linear SVM, or SVM using a non-linear kernel. Non-linear SVM means that the
    boundary that the algorithm calculates doesn't have to be a straight line. The
    benefit is that you can capture much more complex relationships between your datapoints
    without having to perform difficult transformations on your own. The downside
    is that the training time is much longer as it's much more computationally intensive.
  prefs: []
  type: TYPE_NORMAL
- en: Cows and Wolves
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what is the kernel trick?
  prefs: []
  type: TYPE_NORMAL
- en: The kernel trick takes the data you give it and transforms it. In goes some
    great features which you think are going to make a great classifier, and out comes
    some data that you don't recognize anymore. It is sort of like unraveling a strand
    of DNA. You start with this harmelss looking vector of data and after putting
    it through the kernel trick, it's unraveled and compounded itself until it's now
    a much larger set of data that can't be understood by looking at a spreadsheet.
    But here lies the magic, in expanding the dataset there are now more obvious boundaries
    between your classes and the SVM algorithm is able to compute a much more optimal
    hyperplane.
  prefs: []
  type: TYPE_NORMAL
- en: For a second, pretend you're a farmer and you have a problem--you need to setup
    a fence to protect your cows from packs of wovles. But where do you build your
    fence? Well if you're a **really** data driven farmer one way you could do it
    would be to build a classifier based on the position of the cows and wolves in
    your pasture. Racehorsing a few different types of classifiers, we see that SVM
    does a great job at seperating your cows from the packs of wolves. I thought these
    plots also do a nice job of illustrating the benefits of using a non-linear classifiers.
    You can see the the logistic and decision tree models both only make use of straight
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](../Images/fa3cca38f9e009f727c5587ad0f938fc.png)](http://blog.yhat.com/static/img/cows_and_wolves.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Want to recreate the analysis?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Want to create these plots for yourself? You can run the code in your terminal
    or in an IDE of your choice, but, big surprise, I'd recommend [Rodeo](https://www.yhat.com/products/rodeo).
    It has a great pop-out plot feature that comes in handy for this type of analysis.
    It also ships with Python already included for Windows machines. Besides that,
    it's now lightning fast thanks to the hard work of [TakenPilot](https://github.com/TakenPilot).
  prefs: []
  type: TYPE_NORMAL
- en: Once you've [downloaded Rodeo](https://www.yhat.com/products/rodeo), you'll
    need to save the raw [cows_and_wolves.txt](https://gist.githubusercontent.com/glamp/4365660/raw/474658c2c5a8bb763c50278c810d45a27bd21c7e/cows_and_wolves.txt)
    file from my github. Make sure you've set your working directory to where you
    saved the file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Rodeo](../Images/7e3d6ff60c708c9efbbce4383671e3d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Alright, now just copy and paste the code below into Rodeo, and run it, either
    by line or the entire script. Don't forget, you can pop out your plots tab, move
    around your windows, or resize them.
  prefs: []
  type: TYPE_NORMAL
- en: Let SVM do the hard work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the event that the relationship between a dependent variable and independent
    variable is non-linear, it's not going to be nearly as accurate as SVM. Taking
    transformations between variables (log(x), (x^2)) becomes much less important
    since it's going to be accounted for in the algorithm. If you're still having
    troubles picturing this, see if you can follow along with this example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we have a dataset that consists of green and red points. When plotted
    with their coordinates, the points make the shape of a red circle with a green
    outline (and look an awful lot like Bangladesh's flag).
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if somehow we lost 1/3 of our data. What if we couldn't recover
    it and we wanted to find a way to approximate what that missing 1/3 looked like.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we figure out what the missing 1/3 looks like? One approach might
    be to build a model using the 80% of the data we do have as a training set. But
    what type of model do we use? Let''s try out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Logistic model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I trained each model and then used each to make predictions on the missing 1/3
    of our data. Let's take a look at what our predicted shapes look like...
  prefs: []
  type: TYPE_NORMAL
- en: '[![](../Images/696b6daaaa488d77a7dd36895b576f32.png)](http://blog.yhat.com/static/img/flag.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Follow along
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's the code to compare your logistic model, decision tree and SVM.
  prefs: []
  type: TYPE_NORMAL
- en: '![Rodeo](../Images/85682926351dd57b4d477d4bd6a497de.png)'
  prefs: []
  type: TYPE_IMG
- en: Follow along in [Rodeo](https://github.com/yhat/rodeo) by copying and running
    the code above!
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the plots, it's pretty clear that SVM is the winner. But why? Well if you
    look at the predicted shapes of the decision tree and GLM models, what do you
    notice? Straight boundaries. Our input model did not include any transformations
    to account for the non-linear relationship between x, y, and the color. Given
    a specific set of transformations we definitely could have made GLM and the DT
    perform better, but why waste time? With no complex transformations or scaling,
    SVM only misclassified 117/5000 points (98% accuracy as opposed to DT-51% and
    GLM-12%! Of those all misclassified points were red--hence the slight bulge.
  prefs: []
  type: TYPE_NORMAL
- en: When not to use it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So why not use SVM for everything? Well unfortunately the magic of SVM is also
    the biggest drawback. The complex data transformations and resulting boundary
    plane are very difficult to interpret. This is why it's often called a black box.
    GLM and decision trees on the contrary are exactly the opposite. It's very easy
    to understand exactly what and why DT and GLM are doing at the expense of performance.
  prefs: []
  type: TYPE_NORMAL
- en: More Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Want to know more about SVM? Here''s a few good resources I''ve come across:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginner [SVM Tutorial](http://web.mit.edu/zoya/www/SVM.pdf): Just the basics
    with a little bit of spoon feeding from Zoya Gavrilov at MIT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beginner How SVM algorithm works: [Video](https://youtu.be/1NxnPkZM9bc) by
    Thales Sehn Körting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediate [A Gentle Introduction to Support Vector Machiens in Biomedicine](https://www.med.nyu.edu/chibi/sites/default/files/chibi/Final.pdf)
    Slides from NYU & Vanderbilt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced [Tutorial on Support Vector Machines for Pattern Recognition](http://research.microsoft.com/en-us/um/people/cburges/papers/SVMTutorial.pdf)
    from Christopher Burges at Bell Labs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Original](http://blog.yhat.com/posts/why-support-vector-machine.html). Reposted
    with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Support Vector Machines: A Concise Technical Overview](/2016/09/support-vector-machines-concise-technical-overview.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Support Vector Machines: A Simple Explanation](/2016/07/support-vector-machines-simple-explanation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Random Forests in Python](/2016/12/random-forests-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Support Vector Machines: An Intuitive Approach](https://www.kdnuggets.com/2022/08/support-vector-machines-intuitive-approach.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Gentle Introduction to Support Vector Machines](https://www.kdnuggets.com/2023/07/gentle-introduction-support-vector-machines.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Semantic Vector Search Transforms Customer Support Interactions](https://www.kdnuggets.com/how-semantic-vector-search-transforms-customer-support-interactions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python Vector Databases and Vector Indexes: Architecting LLM Apps](https://www.kdnuggets.com/2023/08/python-vector-databases-vector-indexes-architecting-llm-apps.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[If I Had To Start Learning Data Science Again, How Would I Do It?](https://www.kdnuggets.com/2020/08/start-learning-data-science-again.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[When Would Ensemble Techniques be a Good Choice?](https://www.kdnuggets.com/2022/07/would-ensemble-techniques-good-choice.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
