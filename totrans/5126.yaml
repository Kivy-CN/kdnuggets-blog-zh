- en: 'Optimizing Data Storage: Exploring Data Types and Normalization in SQL'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/optimizing-data-storage-exploring-data-types-and-normalization-in-sql](https://www.kdnuggets.com/optimizing-data-storage-exploring-data-types-and-normalization-in-sql)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Optimizing Data Storage: Exploring Data Types and Normalization in SQL](../Images/08d332ab1a0acff45d43157373a84d57.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In the present century, data is the new oil. Optimizing this data storage is
    always critical for getting a good performance from it. Opting for suitable data
    types and applying the correct normalization process is essential in deciding
    its performance.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This article will study the most important and commonly used datatypes and understand
    the normalization process.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types in SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are mainly two data types in SQL: String and Numeric. Other than this,
    there are additional data types like Boolean, Date and Time, Array, Interval,
    XML, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: String Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These data types are used to store character strings. The string is often implemented
    as an array data type and contains a sequence of elements, typically characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAR(n): **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a fixed-length string that can contain characters, numbers, and special
    characters. `n` denotes the maximum length of the string in characters it can
    hold.
  prefs: []
  type: TYPE_NORMAL
- en: Its maximum range is from 0 to 255 characters, and the problem with this data
    type is that it takes the full space specified, even if the actual length of the
    string is less than then. The extra string length is padded with extra memory
    space.
  prefs: []
  type: TYPE_NORMAL
- en: '**VARCHAR(n):**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Varchar is similar to Char but can support strings of variable size, and there
    is no padding. The storage size of this data type is equal to the actual length
    of the string.
  prefs: []
  type: TYPE_NORMAL
- en: It can store up to a maximum of 65535 characters. Due to its variable size nature,
    its performance is not as good as the CHAR data type.
  prefs: []
  type: TYPE_NORMAL
- en: '**BINARY(n): **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is similar to the CHAR data type but only accepts binary strings or binary
    data. It can be used to store images, files, or any serialized objects. There
    is another data type `VARBINARY(n)` which is similar to the VARCHAR data type
    but also accepts only binary strings or binary data.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEXT(n):**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This data type is also used to store the strings but has a maximum size of 65535
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**BLOB(n):** Stands for Binary Large Object and hold data up to 65535 bytes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other than these are other data types, like LONGTEXT and LONGBLOB, which can
    store even more characters.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**INT():**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can store a numeric integer, which is 4 bytes (32bit). Here `n` denotes the
    display width, which can be a maximum of up to 255\. It specifies the minimum
    number of characters used to display the integer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Range:'
  prefs: []
  type: TYPE_NORMAL
- en: a)  -2147483648 <= Signed INT <= 2147483647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b)  0 <= Unsigned INT <= 4294967295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BIGINT():**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can store a large integer of size up to 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Range:'
  prefs: []
  type: TYPE_NORMAL
- en: a)  -9223372036854775808 <= Signed BIGINT <= 9223372036854775807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b)  0 <= Unsigned BIGINT <= 18446744073709551615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FLOAT():**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can store floating point numbers with decimal places approximated with a
    certain precision. It has some small rounding errors, so because of this, it is
    not suitable where exact precision is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**DOUBLE():**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This data type represents double-precision floating-point numbers. It can store
    decimal values with a higher precision as compared to the FLOAT data type.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIMAL(n, d):**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This data type represents exact decimal numbers with a fixed precision denoted
    by d. The parameter `d` specifies the number of digits after the decimal point,
    and the parameter `n` denotes the size of the number. The maximum value for `d`
    is 30, and its default value is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Some other Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BOOLEAN:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This data type stores only two states which are True or False. It is used to
    perform logical operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENUM:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It stands for Enumeration. It allows you to choose one value from the list of
    predefined options. It also ensures that the stored value is only from the specified
    options.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider an attribute `color` that can only be `'Red,' 'Green,'
    or 'Blue'`. When we put these values in ENUM, then the value of the `color` can
    only be from these specified colors only.
  prefs: []
  type: TYPE_NORMAL
- en: '**XML:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: XML stands for eXtensible Markup Language. This data type is used to store XML
    data which is used for structured data representation.
  prefs: []
  type: TYPE_NORMAL
- en: '**AutoNumber:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is an integer that automatically increments its value when each record is
    added. It is used in generating unique or sequential numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hyperlink:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can store the hyperlinks of files and web pages.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our discussion on SQL Data Types. There are many more data types,
    but the data types that we have discussed are the most commonly used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Normalization In SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normalization is the process of removing redundancies, inconsistencies, and
    anomalies from the database. Redundancy means the presence of duplicate values
    of the same piece of data, whereas inconsistencies in the database represent the
    same data exists in multiple formats in multiple tables.
  prefs: []
  type: TYPE_NORMAL
- en: Database anomalies can be defined as any sudden change or discrepancies in the
    database that are not supposed to exist. These changes can be due to various reasons,
    such as data corruption, hardware failure, software bugs, etc. Anomalies can lead
    to severe consequences, such as data loss or inconsistency, so detecting and fixing
    them as soon as possible is essential. There are mainly three types of anomalies.
    We will briefly discuss each but refer to this [article](https://www.geeksforgeeks.org/anomalies-in-relational-model/)
    if you want to read more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion Anomaly:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the newly inserted row creates, inconsistency in the table leads to an
    insertion anomaly. For example, we want to add an employee to an organization,
    but his department is not allocated to him. Then we cannot add that employee to
    the table, which creates an insertion anomaly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deletion Anomaly:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deletion anomaly occurs when we want to delete some rows from the table, and
    some other data is required to be deleted from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Update Anomaly:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This anomaly occurs when we want to update some rows and which leads to inconsistency
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The normalization process contains a series of guidelines that make the design
    of the database efficient, optimized, and free from redundancies and anomalies.
    There are several types of normal forms like 1NF, 2NF, 3NF, BCNF, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First Normal Form (1NF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first normal form ensures that the table contains no composite or multi-valued
    attributes. It means that only one value is present in a single attribute. A relation
    is in first normal form if every attribute is only single-valued.
  prefs: []
  type: TYPE_NORMAL
- en: For Ex-
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing Data Storage: Exploring Data Types and Normalization in SQL](../Images/45bb998a8b9b422745c44f5b8e3f6fba.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [GeeksForGeeks](https://geeksforgeeks.org/normal-forms-in-dbms/)
  prefs: []
  type: TYPE_NORMAL
- en: In Table 1, the attribute `STUD_PHONE` contains more than one phone number.
    But in Table 2, this attribute is decomposed into 1st normal form.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Second Normal Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table must be in the first normal form, and there must not be any partial
    dependencies in the relations. Partial dependency means that the non-prime attribute
    (attributes which are not part of the candidate key) is partially dependent or
    depends on any proper subset of the candidate key. For the relations to be in
    the second normal form, the non-prime attributes must be fully functional and
    dependent on the entire candidate key.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a table named `Employees` having the following attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here the EmployeeID and the ProjectID together form the primary key. However,
    you can notice a partial dependency between EmployeeName and EmployeeID. It means
    that the EmployeeName is dependent only on the part of the primary key (i.e.,
    EmployeeID). For complete dependency, the EmployeeName must depend on both EmployeeID
    and the ProjectID. So, this violates the principle of the second normal form.
  prefs: []
  type: TYPE_NORMAL
- en: To make this relation in the second normal form, we must split the tables into
    two separate tables. The first table contains all the employee details, and the
    second contains all the project details.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the `Employee` table has the following attributes,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And the `Project` table has the following attributes,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now you can see that the partial dependency is removed by creating two independent
    tables. And the non-prime attributes of both tables depend on the complete set
    of the primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Third Normal Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After 2NF, still, the relations can have update anomalies. It may happen if
    we update only one tuple and not the other. That would lead to inconsistency in
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: The condition for the third normal form is that the table should be in the 2NF,
    and there is no transitive dependency for the non-prime attributes. Transitive
    dependency happens when a non-prime attribute depends on another non-prime attribute
    instead of directly depending on the primary attribute. Prime attributes are the
    attributes that are part of the candidate key.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a relation R(A, B, C), where A is the primary key and B & C are the
    non-prime attributes. Let A→B and B→C be two **Functional Dependencies**, then
    A→C will be the transitive dependency. It means that attribute C is not directly
    determined by A. B acts as a middleman between them.
  prefs: []
  type: TYPE_NORMAL
- en: If a table consists of a transitive dependency, then we can bring the table
    into 3NF by splitting the table into separate independent relations.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Boyce-Codd Normal Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although 2NF and 3NF remove most of the redundancies, still the redundancies
    are not 100% removed. Redundancy can occur if the LHS of the functional dependency
    is not a candidate or super key. A **Candidate Key** forms from the prime attributes,
    and the **Super Key** is a superset of the candidate key. To overcome this issue,
    another type of functional dependency is available named Boyce Codd Normal Form
    (BCNF).
  prefs: []
  type: TYPE_NORMAL
- en: For a table to be in BCNF, the left-hand side of a functional dependency must
    be a candidate key or a super key. A. For example, for a functional dependency
    X→Y, X must be a candidate or super key.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an Employee Table that contains the following attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Employee ID (primary key)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Employee Name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Department
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Department Head
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Optimizing Data Storage: Exploring Data Types and Normalization in SQL](../Images/926dacca3258d85bb4d6ba9c37b626ad.png)'
  prefs: []
  type: TYPE_IMG
- en: The EmployeeID is the primary key that uniquely identifies each row. The Department
    attribute represents the department of a particular employee, and the Department
    Head attribute represents the Employee ID of the employee who is the head of that
    specific department.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will check if this table is in the BCNF. The condition is that the LHS
    of the functional dependency must be a super key. Below are the two functional
    dependencies of that table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional Dependency 1: Employee ID → Employee Name, Department, Department
    Head'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional Dependency 2: Department → Department Head'
  prefs: []
  type: TYPE_NORMAL
- en: For the FD1, the EmployeeID is the primary key, which is also a super key. But
    for FD2, `Department` is not the super key because multiple employees can be in
    the same department.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore this table violates the condition of BCNF. To satisfy the property
    of BCNF, we need to split that table into two separate tables: `Employees` and
    `Departments`. The Employees table contains the EmployeeID, EmployeeName, and
    Department, and the Department table will have the Department and the Department
    Head.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing Data Storage: Exploring Data Types and Normalization in SQL](../Images/3bde6b5cb3aae4fd63f49059c4c82943.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Optimizing Data Storage: Exploring Data Types and Normalization in SQL](../Images/d4b437505fec1f31f07be3aa099329f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we can see in both tables that all the functional dependencies are dependent
    on the primary keys, i.e., there are no non-trivial dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered all the famous normalization techniques, but other than these,
    there are two more normal forms, namely 4NF and 5NF. If you want to read more
    about them, refer to this [article](https://www.geeksforgeeks.org/difference-between-4nf-and-5nf/)
    from GeeksForGeeks.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping it Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed the most commonly used data types in SQL and the significant
    Normalization techniques in database management systems. While designing a database
    system, we aim to make it scalable, minimizing redundancy and ensuring data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a delicate balance between storage, precision, and memory consumption
    by selecting appropriate data types. Also, the normalization process helps eliminate
    data anomalies and make the schema more organized.
  prefs: []
  type: TYPE_NORMAL
- en: It is all for today. Until then, keep reading and keep learning.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Aryan Garg](https://www.linkedin.com/in/aryan-garg-1bbb791a3/)** is a B.Tech.
    Electrical Engineering student, currently in the final year of his undergrad.
    His interest lies in the field of Web Development and Machine Learning. He have
    pursued this interest and am eager to work more in these directions.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Data Transformation: Standardization vs Normalization](https://www.kdnuggets.com/2020/04/data-transformation-standardization-normalization.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Does the Random Forest Algorithm Need Normalization?](https://www.kdnuggets.com/2022/07/random-forest-algorithm-need-normalization.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python Basics: Syntax, Data Types, and Control Structures](https://www.kdnuggets.com/python-basics-syntax-data-types-and-control-structures)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Database Optimization: Exploring Indexes in SQL](https://www.kdnuggets.com/2023/07/database-optimization-exploring-indexes-sql.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Types of Visualization Frameworks](https://www.kdnuggets.com/types-of-visualization-frameworks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimizing Your LLM for Performance and Scalability](https://www.kdnuggets.com/optimizing-your-llm-for-performance-and-scalability)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
