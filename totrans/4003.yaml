- en: 5 Tips for Writing Better Python Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/5-tips-for-writing-better-python-functions](https://www.kdnuggets.com/5-tips-for-writing-better-python-functions)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![py-func](../Images/4c82c40e504bc6f9c18898c93ff31efd.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We all write functions when coding in Python. But do we necessarily write *good*
    functions? Well, let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Functions in Python let you write modular code. When you have a task you need
    to perform at multiple places, you can wrap the logic of the task into a Python
    function. And you can call the function every time you need to perform that specific
    task. As simple as it seems to get started with Python functions, writing maintainable
    and performant functions is not so straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s why we’ll explore a few practices that’ll help you write cleaner
    and easy-to-maintain Python functions. Let's get started…
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Write Functions That Do Only One Thing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing functions in Python, it's often tempting to put all related tasks
    into a single function. While this can help you code things up quickly, it’ll
    only make your code a pain to maintain in the near future. Not only will this
    make understanding what a function does more difficult but also leads to other
    issues such as too many parameters (more on that later!).
  prefs: []
  type: TYPE_NORMAL
- en: As a good practice, you should always try to make your function do only one
    thing—one task—and do that well. But sometimes, for a single task, you may need
    to work through a series of subtasks. So how do you decide if and how the function
    should be refactored?
  prefs: []
  type: TYPE_NORMAL
- en: Depending on *what* the function is trying to do and how complex the task is,
    you can work out the separation of concerns between subtasks. And then identify
    a suitable level at which you can refactor the function into multiple functions—each
    focusing on a specific subtask.
  prefs: []
  type: TYPE_NORMAL
- en: '![refactor-func](../Images/c879e94509178e1df554d2b8d1ea3fbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Refactor functions | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. Look at the function `analyze_and_report_sales`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite easy to see that it can be refactored into two functions: one calculating
    the sales metrics and another on writing the sales metrics to a file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s easier to debug any concerns with the calculation of sales metrics
    and file operations separately. And here’s a sample function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to see the ‘sales_report.txt’ file in your working directory
    with the sales metrics. This is a simple example to get started, but this is helpful
    especially when you're working on more complex functions.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Add Type Hints to Improve Maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a dynamically typed language. So you do not need to declare types
    for the variables you create. But you can add type hints to specify the expected
    data type for variables. When you define the function, you can add the expected
    data types for the parameters and the return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Python does not enforce types at runtime, adding type hints has no
    effect at runtime. But there still are benefits to using type hints, especially
    on the maintainability front:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding type hints to Python functions serves as inline documentation and gives
    a better idea of what the function does and what values it consumes and returns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you add type hints to your functions, you can configure your IDE to leverage
    these type hints. So you’ll get helpful warnings if you try to pass an argument
    of invalid type in one or more function calls, implement functions whose return
    values do not match the expected type, and the like. So you can minimize errors
    upfront.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can optionally use static type checkers like [mypy](https://mypy.readthedocs.io/en/stable/)
    to catch errors earlier rather than letting type mismatches introduce subtle bugs
    that are difficult to debug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a function that processes order details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add type hints to the function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With the modified version, you get to know that the function takes in a list
    of dictionaries. The keys of the dictionary should all be strings and the values
    can either be integers or floating point values. The function also returns a dictionary.
    Let’s take a sample function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, type hints help us get a better idea of how the function works.
    Going forward, we'll add type hints for all the better versions of Python functions
    we write.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Accept Only the Arguments You Actually Need
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are a beginner or have just started your first dev role, it’s important
    to think about the different parameters when defining the function signature.
    It's quite common to introduce additional parameters in the function signature
    that the function never actually processes.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that the function takes in only the arguments that are actually necessary
    keeps function calls cleaner and more maintainable in general. On a related note,
    too many parameters in the function signature also make it a pain to maintain.
    **So how do you go about defining easy-to-maintain functions with the right number
    of parameters?**
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find yourself writing a function signature with a growing number of
    parameters, the first step is to remove all unused parameters from the signature.
    If there are too many parameters even after this step, go back to tip #1: break
    down the task into multiple subtasks and refactor the function into multiple smaller
    functions. This will help keep the number of parameters in check.'
  prefs: []
  type: TYPE_NORMAL
- en: '![num-params](../Images/65cd0ac3b46ca1f757cb75818a81e063.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep num_params in check | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time for a simple example. Here the function definition to calculate student
    grades contains the `instructor` parameter that’s never used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can rewrite the function without the `instructor` parameter like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Enforce Keyword-Only Arguments to Minimize Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In practice, most Python functions take in multiple arguments. You can pass
    in arguments to Python functions as positional arguments, keyword arguments, or
    a mix of both. Read [Python Function Arguments: A Definitive Guide](https://www.kdnuggets.com/2023/02/python-function-arguments-definitive-guide.html)
    for a quick review of function arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Some arguments are naturally positional. But sometimes having function calls
    containing only positional arguments can be confusing. This is especially true
    when the function takes in multiple arguments of the same data type, some required
    and some optional.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, with positional arguments, the arguments are passed to the parameters
    in the function signature in the *same* order in which they appear in the function
    call. So change in order of arguments can introduce subtle bugs and type errors.
  prefs: []
  type: TYPE_NORMAL
- en: It’s often helpful to make *optional* arguments *keyword-only*. This also makes
    adding optional parameters much easier—without breaking existing calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. The `process_payment` function takes in an optional `description`
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you want to make the optional `description` a keyword-only argument. Here’s
    how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a sample function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try passing in all arguments as positional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get an error as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 5\. Don’t Return Lists From Functions; Use Generators Instead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's quite common to write Python functions that generate sequences such as
    a list of values. But as much as possible, you should avoid returning lists from
    Python functions. Instead you can rewrite them as generator functions. Generators
    use lazy evaluation; so they yield elements of the sequence on demand rather than
    computing all the values ahead of time. Read [Getting Started with Python Generators](https://www.kdnuggets.com/2023/02/getting-started-python-generators.html)
    for an introduction to how generators work in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, take the following function that generates the Fibonacci sequence
    up to a certain upper limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a recursive implementation that’s computationally expensive and populating
    the list and returning it seems more verbose than necessary. Here’s an improved
    version of the function that uses generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the function returns a generator object which you can then loop
    through to get the elements of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using generators can be much more efficient especially for large
    input sizes. Also, you can chain multiple generators together, so you can create
    efficient data processing pipelines with generators.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And that’s a wrap. You can find all the code [on GitHub](https://github.com/balapriyac/python-basics/tree/main/write-better-funcs).
    Here’s a review of the different tips we went over:'
  prefs: []
  type: TYPE_NORMAL
- en: Write functions that do only one thing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add type hints to improve maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept only the arguments you actually need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforce keyword-only arguments to minimize errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't return lists from functions; use generators instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you found them helpful! If you aren’t already, try out these practices
    when writing Python functions. Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: '**[](https://twitter.com/balawc27)**[Bala Priya C](https://www.kdnuggets.com/wp-content/uploads/bala-priya-author-image-update-230821.jpg)****
    is a developer and technical writer from India. She likes working at the intersection
    of math, programming, data science, and content creation. Her areas of interest
    and expertise include DevOps, data science, and natural language processing. She
    enjoys reading, writing, coding, and coffee! Currently, she''s working on learning
    and sharing her knowledge with the developer community by authoring tutorials,
    how-to guides, opinion pieces, and more. Bala also creates engaging resource overviews
    and coding tutorials.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Mastering Python: 7 Strategies for Writing Clear, Organized, and…](https://www.kdnuggets.com/mastering-python-7-strategies-for-writing-clear-organized-and-efficient-code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Announcing a Blog Writing Contest, Winner Gets an NVIDIA GPU!](https://www.kdnuggets.com/2022/11/blog-writing-contest-nvidia-gpu.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Statistical Functions in Python](https://www.kdnuggets.com/2022/10/statistical-functions-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python Lambda Functions, Explained](https://www.kdnuggets.com/2023/01/python-lambda-functions-explained.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4 Python Itertools Filter Functions You Probably Didn''t Know](https://www.kdnuggets.com/2023/08/4-python-itertools-filter-functions-probably-didnt-know.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10 Python Statistical Functions](https://www.kdnuggets.com/10-python-statistical-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
