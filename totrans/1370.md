# 数据科学家的软件工程基础

> 原文：[https://www.kdnuggets.com/2020/06/software-engineering-fundamentals-data-scientists.html](https://www.kdnuggets.com/2020/06/software-engineering-fundamentals-data-scientists.html)

[评论](#comments)

![](../Images/b7d920f619a83d06ea12e871e38b632c.png)

*来源: [Chris Ried](https://unsplash.com/photos/ieic5Tq8YMk) @ unsplash。*

* * *

## 我们的前三个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌IT支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织的IT需求

* * *

数据科学作为一个领域，自从其开始流行以来，就与其他学科产生了争论。统计学家抱怨实践者通常缺乏基础统计知识，数学家则反对在没有扎实理解所应用原理的情况下使用工具，而软件工程师则指出数据科学家在编程时对基本原理的无知。说实话，他们都有一定的道理。在统计学和数学方面，确实需要对概率、代数和微积分等概念有扎实的理解。知识需要有多深入？这在很大程度上取决于你的角色，但基础是不可妥协的。编程方面也发生了类似的情况；如果你的角色涉及编写生产代码，那么你至少需要了解软件工程的基础知识。为什么？原因有很多，但我认为可以根据五个原则简要概括：

+   **代码的完整性**，即代码的编写质量，错误的抵御能力，异常处理，测试以及被他人审查的情况。

+   **代码的可解释性**，包括适当的文档。

+   **代码的速度**，以便在实际环境中运行。

+   **脚本和对象的模块化**，以便于重用，避免重复，并提高代码类之间的效率。

+   **对团队的慷慨**，让他们尽快审查你的代码，并在将来理解你编写的任何代码的原因。

根据这些要点，在这个故事中我们将看到一些我发现最有用的基础知识，虽然我本质上不是程序员，而是从完全不同的背景进入这个领域的。它们帮助我编写更好的生产代码，为我节省了时间，并且在实施我的脚本时让我的同事们更轻松。

### 编写清洁代码的重要性

![](../Images/fe1216b521d448a294432b1746174096.png)

*来源： [Oliver Hale](https://unsplash.com/photos/oTvU7Zmteic) @ unsplash.*

理论上，我们在这个故事中讨论的几乎所有内容都可以被视为编写更清晰代码的工具或技巧。然而，在这一特定部分，我们将重点关注“干净”一词的严格定义。正如罗伯特·马丁在他的书《[代码大全](https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)》中所说，即使是糟糕的代码也能运行，但如果代码不干净，它可以使一个开发组织陷入困境。怎么做到的？老实说，可能性有很多，但只需想象一下审查糟糕编写的代码所浪费的时间，或者在新角色中发现自己要处理一些多年以前编写的难以阅读的代码，甚至更糟的是，想象一下某个功能因代码错误而停止工作，而在你之前编写这种脏代码的人已经不再公司了。

这些都是相对常见的情况，但让我们少一些戏剧性；谁没有写过一些代码，暂时搁置去处理更紧急的事务，然后当再次回到这些代码时却不记得它们的实际工作方式？我知道这种情况发生在我身上过。

这些都是写出更好代码的有效理由。所以，让我们从基础开始，看看一些编写更清晰脚本的技巧：

+   **在你的代码中使用描述性强的名称**。我从大学学习Java时就记住了一个概念：力求让你的代码具有*助记性*。助记性指的是一种系统，例如字母、想法或联想的模式，有助于记住某些东西。也就是说，它意味着编写自解释的名称。

+   尽可能**尝试隐含类型**。例如，对于返回布尔对象的函数，你可以使用`is_`或`has`作为前缀。

+   **避免缩写，尤其是单个字母。**

+   另一方面，**避免长名称和长行**。编写长名称并不意味着更具描述性，就行长度而言，[PEP 8风格指南](https://www.python.org/dev/peps/pep-0008/)建议行长度大约为79个字符。

+   **不要为了保持一致性而牺牲清晰度**。例如，如果你有表示员工的对象和包含所有员工的列表，`employee_list`和`employee_1`比`employees`和`employee_1`更清晰。

+   关于空白行和缩进，**使你的代码更易读**，通过使用空白行分隔部分并使用一致的缩进。

### 编写模块化代码的重要性

![](../Images/13e65db455b071d50666ec8f4d63901a.png)

*来源： [Sharon McCutcheon](https://www.pexels.com/photo/art-materials-art-supplies-blocks-blur-1148496/) @ pexels.*

我认为这一点对于数据科学家和数据分析师来说是最重要的，并且是与软件工程师讨论的一个非常常见的话题，因为我们非常习惯使用像 Jupyter Notebooks 这样的工具。这些工具非常适合探索性数据分析，但并不适合编写生产代码。实际上，Python 本质上是一种面向对象的编程语言，在这里不打算深入讨论这意味着什么。但简而言之，与过程式编程不同，面向对象编程是关于构建具有自己特征和操作的模块。以下是一个示例：

![](../Images/a8ede08cba7ff915b06d51bb1e8a7d6e.png)

*来源：由作者创建的图像。*

实际上，这些特征被称为属性，而操作将是方法。在上述示例中，Computer 和 Printer 将是独立的类。一个类是包含所有该特定类型对象的属性和方法的蓝图。也就是说，我们创建的所有 Computers 和 Printers 将共享相同的属性和方法。这个理念背后的概念被称为封装。封装意味着你可以将函数和数据组合到一个单一的实体或模块中。当你将程序拆分成多个模块时，不同的模块不需要知道如何完成某项任务，只要它们不负责执行这项任务。这为什么有用？嗯，这不仅使代码可以重用，避免重复，并提高了代码类的效率，还使调试变得更容易（如果需要的话）。

再次强调，如果你只是使用 Jupyter Notebook 进行探索性数据分析，这可能不太相关，但如果你正在编写一个将成为实时环境一部分的脚本，尤其是当应用程序随着规模的增长，分割代码为不同的模块就显得非常有意义。通过在将所有部分合并在一起之前完善每个程序部分，你不仅使得在其他程序中重用单独的模块变得更容易，还能通过能够准确定位错误源来更轻松地修复问题。

编写模块化代码的一些进一步提示：

+   DRY：不要重复自己

+   使用函数不仅减少了重复性，还通过描述性名称提高了可读性，使人们能够理解每个模块的功能。

+   最小化实体的数量（函数、类、模块等）

+   单一职责原则：即一个类应该只有一个且唯一的责任。比人们预期的要难。

+   遵循开放/封闭原则，即对象应该对扩展开放，对修改封闭。这个理念是编写代码时能够添加新功能而无需更改现有代码，从而避免修改一个类时需要调整所有依赖类的情况。[应对这一挑战的方法有很多种](https://stackify.com/solid-design-open-closed-principle/)，不过在 Python 中，使用继承是很常见的做法。

+   尽量减少每个函数的参数数量，不超过三个。如果参数太多，可以考虑拆分函数。类似的准则适用于函数的长度；理想情况下，函数应包含20到50行代码。如果超出此范围，可能需要将其拆分为多个函数。

+   还要注意类的长度。如果一个类有超过300行代码，那么可能需要将其拆分成更小的类。

如果你已经在使用 Python，但对面向对象编程知之甚少或没有了解，我强烈推荐这两个免费的课程：

+   [Python 中的面向对象编程](https://www.datacamp.com/courses/object-oriented-programming-in-python) 在 Datacamp

+   [Python 中面向对象编程 (OOP) 简介](https://realpython.com/courses/intro-object-oriented-programming-oop-python/) 在 [https://realpython.com/](https://realpython.com/)

### 重构的重要性

![](../Images/bae4178d7b038c4cc46b8108bbaf8fcc.png)

*来源: [RyanMcGuire](https://pixabay.com/photos/car-repair-car-workshop-repair-shop-362150/) @ pixabay。*

维基百科对重构的定义如下：

> *在计算机编程和软件设计中，代码重构是重组现有计算机代码的过程，而不改变其外部行为。重构旨在改善软件的设计、结构和/或实现，同时保持其功能。重构的潜在优势包括提高代码的可读性和减少复杂性；这些可以改善源代码的可维护性，并创建更简单、更清晰或更具表达力的内部架构或对象模型，从而提高可扩展性。*

我认为定义本身已经说明了问题，但除此之外，我们还可以补充说，重构为我们提供了在代码正常工作的情况下清理和模块化代码的机会。它还让我们有机会提高代码的效率。根据我到目前为止的经验，当软件工程师谈到高效代码时，他们通常指的是以下两种情况：

1.  减少运行时间

1.  减少内存占用

简要讨论一下这两个点……

在我的经验中，**减少代码运行时间**是你随着编写越来越多的生产代码而逐渐学会的。当你在 Jupyter Notebook 中进行一些分析时，计算这些成对距离需要你两分钟、五分钟还是十分钟并不重要。你可以让它继续运行，回复一些 Slack 消息，去洗手间，倒杯咖啡，然后回来查看代码是否完成。然而，当有用户在另一端等待时会发生什么呢？你不能让他们在你的代码编译时无所事事，对吧？

在 Python 中，有几种方法可以提高性能。让我们快速介绍其中的一些：

**使用向量运算使计算更快**。例如，当检查一个数组的元素是否在另一个数组中时，不必编写循环，你可以使用 NumPy 的 *intersect1d*。你也可以使用向量根据条件搜索元素以执行加法或类似操作。让我们看一个快速的例子，当我们需要**迭代数字列表并根据条件执行操作**时：

而不是使用这样的东西：

```py
# random array with 10 million points
a = np.random.normal(500, 30, 10000000)

# iterating and checking for values < 500
t0 = time.time()
total = 0
for each in a:
    if each < 500:
    total += each
t1 = time.time()
print(t1-t0) 

```

时间：3.6942789554595947秒

```py
# same operation only using numpy
t0 = time.time()
total = a[a<500].sum()
t1 = time.time()
print(t1-t0) 

```

时间：0.06348109245300293秒

快速超过 58 倍！

我知道 Pandas Dataframes 非常易于使用，我们所有的 Python 爱好者都喜欢它们。然而，在编写生产代码时，最好还是避免使用它们。我们用 Pandas 执行的许多操作也可以使用 Numpy 完成。让我们看一些其他的例子：

+   **根据条件对矩阵进行行求和**

```py
# random 2d array with 1m rows and 20 columnn
# we’ll use the same in following examples
a = np.random.random(size=(1000000,20))

# sum all values greater than 0.30
(a * (a>0.30)).sum(axis=1)

```

在上面的代码中，乘以布尔数组有效，因为 True 对应 1，而 False 对应 0。

+   **根据某些条件添加列**

```py
# obtain the number of columns in the matrix to be used as index of the new one to be placed at the end
new_index = a.shape[1]

# set the new column using the array created in the previous example
a = np.insert(a, new_index, (a * (a>0.30)).sum(axis=1), axis=1)

# check new shape of a
a.shape

```

打印： (1000000, 21) | 新列已添加。

+   **根据多个条件过滤表格**

```py
# filter if the new last column is greater than 10 and first column is less than 0.30
b = a[(a[:,0]<0.30)&(a[:,-1]>10)]

b.shape

```

打印： (55183, 21) | 55183 行符合条件。

+   **如果满足条件，则替换元素**

```py
# change to 100 all values less than 0.30
a[a<0.3] = 100

```

除了上面的代码，减少运行时间的另一个好选择是**并行化**。并行化意味着编写脚本以并行处理数据，使用机器中所有可用的处理器。这为什么能显著提高速度呢？因为大多数时候，我们的脚本是串行计算数据的：它们解决一个问题，然后是下一个，接着是下一个，依此类推。当我们在 Python 中编写代码时，通常是这样发生的，如果我们想利用并行化，就必须明确地实现这一点。我会很快写一篇独立的文章来讨论这个问题，然而，如果你急于了解更多，在所有可用的并行化库中，我目前最喜欢的有：

+   [Multiprocessing](https://docs.python.org/3/library/multiprocessing.html)

+   [Numba](https://numba.pydata.org/numba-doc/latest/user/5minguide.html)

关于**减少内存占用**，在 Python 中减少内存使用是困难的，因为[Python 实际上不会将内存释放回操作系统](http://effbot.org/pyfaq/why-doesnt-python-release-the-memory-when-i-delete-a-large-object.htm)。如果你删除对象，那么内存会对新的 Python 对象可用，但不会释放回系统。此外，如前所述，Pandas 是一个很好的探索性数据分析工具，但除了在生产代码中较慢外，它在内存方面也相当昂贵。然而，我们可以采取一些措施来控制内存使用：

+   首先：如果可能的话，**使用 NumPy 数组而不是 Pandas**。即使是字典，如果可能的话，也会比数据框占用更少的内存。

+   **减少 Pandas 数据框的数量**：当我们修改数据框时，尽量使用参数`inplace=True`直接修改数据框，而不是创建新的对象，这样就不会产生副本。

+   **清除你的历史记录**：每次对数据框进行更改（例如，df + 2）时，Python 会在内存中保留该对象的副本。你可以通过使用`%reset Out`来清除这些历史记录。

+   **注意你的数据类型**：对象和字符串的数据类型在内存消耗上比数字类型要昂贵得多。这就是为什么使用`df.info()`检查数据框的数据类型并在可能的情况下使用`df[‘column’] = df[‘columns’].astype(type)`进行转换总是很有用的原因。

+   **使用稀疏矩阵**：如果你有一个包含大量空值或空单元格的矩阵，使用稀疏矩阵会更方便，它通常在内存中占用的空间要少得多。

你可以使用*scipy.sparse.csr_matrix(df.values)*来做到这一点。

+   **使用生成器而不是对象**：生成器允许你声明一个像迭代器一样的函数，但使用`*yield*`而不是`*return*`。生成器不会创建一个包含所有计算的新对象（即列表或 NumPy 数组），而是生成一个保存在内存中的单个值，仅在你请求时才更新。这被称为惰性求值。更多关于生成器的信息，可以在[Abhinav Sagar](https://towardsdatascience.com/@abhinav.sagar) 在 Towards Data Science 的精彩故事中找到。

### 测试的重要性

![](../Images/b0fac3f71716a374de4c187c387c41f9.png)

*来源：[Pixabay](https://www.pexels.com/photo/red-and-yellow-hatchback-axa-crash-tests-163016/) 在 @ pexels。*

数据科学中的测试是必要的。其他软件相关领域通常抱怨数据科学家的代码缺乏测试。而在其他类型的算法或脚本中，如果出现错误，程序可能会停止工作；但在数据科学中这更为危险，因为程序可能会运行，但由于值编码错误、特征使用不当或数据破坏了模型的假设，最终得出错误的见解和建议。

当我们谈到测试时，有两个主要概念值得讨论：

+   单元测试

+   测试驱动开发

让我们从前者开始。**单元测试**之所以被称为“单元测试”，是因为它们覆盖了代码的小单元。目标是验证代码的每个独立部分是否按设计执行。在面向对象编程语言（如Python）中，一个单元也可以设计用来评估整个类，但也可以是单个方法或函数。

单元测试可以从头开始编写。实际上，让我们这样做，以便更好地理解单元测试的实际工作原理：

假设我有以下函数：

```py
def my_func(a,b):

   c=(a+b)/2*1.5

   return c

```

我想测试以下输入是否返回预期的输出：

+   4 和 2 返回 4.5

+   5 和 5 返回 5.5

+   4 和 8 返回 9.0

我们可以完全写出这样的代码：

```py
def test_func(function, output):
    out = function
    if output == out:
        print(‘Worked as expected!’)
    else:
        print(‘Error! Expected {} output was {}’.format(output,out))

```

然后简单地测试我们的函数：

```py
test_func(my_func(4,2),4.5)

```

打印：*按预期工作！*

然而，当涉及到更复杂的函数，或者我们希望同时测试多个函数甚至一个类时，这可能会变得更棘手。一个不那么麻烦的单元测试工具是[pytest library](https://docs.pytest.org/en/latest/getting-started.html)。Pytest要求你创建一个包含待测函数的Python脚本，并包含另一组用于断言输出的函数。文件需要以‘test’为前缀保存，然后像运行其他Python脚本一样运行它。Pytest最初是为命令行开发的，但如果你还在项目的早期阶段，可以使用一些变通方法在Jupyter Notebook中使用它；你可以使用魔法命令*%%writefile*创建并保存一个.py文件，然后直接从笔记本中运行脚本。让我们看看一个例子：

```py
import pytest
%%writefile test_function.py

def my_func(a,b):
    c=(a+b)/2*1.5
    return c

def test_func_4_2():
    assert(my_func(4,2)==4.5)

def test_func_5_5():
    assert(my_func(5,5)==7.5)

def test_func_4_8():
    assert(my_func(4,8)==9.0)

```

然后直接运行脚本：

```py
!pytest test_function.py

```

如果一切按预期运行，你会看到这样的输出：

![](../Images/efa239201e3ca82744ad7f7d84db4362.png)

将来，我会写另一个故事来讨论更复杂的单元测试示例，以及如何测试整个类（如果这是你需要的）。但同时，这些足以让你入门并测试你的一些函数。注意，在上述示例中，我正在测试返回的确切数字，但你也可以测试数据框的形状、NumPy数组的长度、返回对象的类型等。

我们在本章开始时提到的另一个要点是**测试驱动开发或 TDD**。这种测试方法包括在开始开发之前先编写要执行的单元测试。接下来，你会想要编写尽可能简单和/或最快的代码，以通过你最初写下的测试，这将有助于确保质量，通过在编写代码之前专注于需求。此外，它还会强迫你将代码保持简单、干净和可测试，通过将其分解为小块代码来符合最初编写的测试。一旦你有一段实际通过这些测试的代码，你才会专注于重构，以提高代码的质量或进一步的功能。

![](../Images/d9994ecd4b3ba3238aa4cbe5f036c495.png)

*来源: [https://me.me/](https://me.me/)*

TDD 的一个主要好处是，如果将来需要对代码进行更改，而你不再继续这个项目，可能是因为你换了公司或者你只是度假，知道最初编写的测试将帮助任何接手代码的人确保在更改后不会破坏任何东西。

一些值得考虑的进一步要点：

+   笔记本：适合探索，不适合 TDD。

+   乒乓 TDD：一个人编写测试，另一个人编写代码。

+   为你的测试设置性能和输出指标。

### 代码审查的重要性

![](../Images/dd9c380898050c5dcffa3a5a687649f4.png)

*来源: [Charles Deluvio](https://unsplash.com/photos/Lks7vei-eAg) @ unsplash.*

代码审查对团队中的每个人都有益，促进最佳编程实践并为生产做好准备。代码审查的主要目标是发现错误。然而，它们也有助于提高可读性，并检查团队中是否符合标准，以免将脏代码或慢代码投入生产。除了这些点，代码审查也是分享知识的绝佳方式，因为团队成员可以阅读来自不同背景和风格的人的代码片段。

目前，非常适合代码审查的工具是具有拉取请求的 GitHub 平台。拉取请求是请求将代码的更改或全新的脚本集成到某个代码环境中的请求。它之所以叫做拉取请求，是因为它的提交意味着请求某人将你写的代码拉入仓库。

从[GitHub 的文档](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests)中，我们可以看到对拉取请求的定义：

> *拉取请求让你可以告诉其他人关于你推送到 GitHub 仓库中某个分支的更改。一旦打开拉取请求，你可以与协作者讨论和审查潜在的更改，并在你的更改合并到基础分支之前添加后续提交。*

拉取请求本身就是一种艺术，如果你有兴趣了解更多，可以参考[这篇文章](https://medium.com/@hugooodias/the-anatomy-of-a-perfect-pull-request-567382bb6067)，题为《完美拉取请求的解剖》作者为[Hugo Dias](https://medium.com/@hugooodias)。不过，在审查代码时，你可以问自己几个问题：

+   **代码是否干净且模块化？** 查找重复、空白、可读性和模块化。

+   **代码是否高效？** 查看循环、对象、函数结构，它是否可以使用多进程？

+   **文档是否有效？** 查找内联评论、[文档字符串](https://en.wikipedia.org/wiki/Docstring)和自述文件。

+   **代码是否经过测试？** 查找单元测试。

+   **[日志记录](https://www.quora.com/What-is-Logging-in-programming)是否足够好？** 查找日志消息的清晰度和适当频率。

[原始内容](https://towardsdatascience.com/software-engineering-fundamentals-for-data-scientists-6c95316d6cc4)。经许可转载。

**相关：**

+   [机器学习部署的软件接口](https://www.kdnuggets.com/2020/03/software-interfaces-machine-learning-deployment.html)

+   [如何对机器学习代码进行单元测试](https://www.kdnuggets.com/2017/11/unit-test-machine-learning-code.html)

+   [数据科学家的编码习惯](https://www.kdnuggets.com/2020/05/coding-habits-data-scientists.html)

### 更多相关话题

+   [5个免费在线课程学习数据工程基础](https://www.kdnuggets.com/5-free-online-courses-to-learn-data-engineering-fundamentals)

+   [数据科学家和分析师的统计学基础](https://www.kdnuggets.com/2023/08/fundamentals-statistics-data-scientists-analysts.html)

+   [软件开发人员与软件工程师](https://www.kdnuggets.com/2022/05/software-developer-software-engineer.html)

+   [KDnuggets新闻 2022年3月16日：学习数据科学基础及更多…](https://www.kdnuggets.com/2022/n11.html)

+   [学习数据科学基础需要多长时间？](https://www.kdnuggets.com/2022/03/long-take-learn-data-science-fundamentals.html)

+   [5个免费在线课程学习数据科学基础](https://www.kdnuggets.com/5-free-online-courses-to-learn-data-science-fundamentals)
