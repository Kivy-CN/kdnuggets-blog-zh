- en: A Comparison of Machine Learning Algorithms in Python and R
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《Python 和 R 中机器学习算法的比较》
- en: 原文：[https://www.kdnuggets.com/2023/06/machine-learning-algorithms-python-r.html](https://www.kdnuggets.com/2023/06/machine-learning-algorithms-python-r.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2023/06/machine-learning-algorithms-python-r.html](https://www.kdnuggets.com/2023/06/machine-learning-algorithms-python-r.html)
- en: '![A Comparison of Machine Learning Algorithms in Python and R](../Images/429e860c2b0f3530e614ebeeda14783a.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Python 和 R 中机器学习算法的比较](../Images/429e860c2b0f3530e614ebeeda14783a.png)'
- en: Image by Editor
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器提供的图像
- en: Python and R are two of the most used programming languages for machine learning.
    Both are open source and highly accessible, but where Python is a general-purpose
    language, R is a statistical programming language. This makes it ideal for various
    [data roles](/2023/06/programming-languages-specific-data-roles.html) and applications,
    such as data mining.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 和 R 是机器学习中最常用的两种编程语言。它们都是开源且高度可访问的，但 Python 是通用编程语言，而 R 是统计编程语言。这使得 R
    非常适合各种[数据角色](/2023/06/programming-languages-specific-data-roles.html)和应用，如数据挖掘。
- en: The two programming languages also encourage re-usability, meaning novice machine
    learning engineers and enthusiasts don’t have to write their code from scratch.
    Using them to build projects is about integrating the right modules and algorithms
    - all you have to know is where to look. To help you out, we’ve compiled a list
    of some of the most used machine learning algorithms for Python and R. Make sure
    to bookmark this guide and reference it whenever you get stuck.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种编程语言也鼓励代码的重用，这意味着新手机器学习工程师和爱好者不必从头编写代码。使用它们构建项目的关键在于集成合适的模块和算法——你只需要知道在哪里寻找。为了帮助你，我们整理了一些
    Python 和 R 中最常用的机器学习算法列表。确保收藏此指南，并在遇到困难时参考它。
- en: 1\. K-Means Clustering Algorithm
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. K-Means 聚类算法
- en: As the name implies, machine learning is ultimately about teaching computer
    systems so they can function autonomously. This can either be facilitated through
    supervised or unsupervised learning.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，机器学习的最终目的是教会计算机系统使其能够自主运行。这可以通过监督学习或无监督学习来实现。
- en: One way to perform the latter is using the [k-means clustering algorithm](https://www.javatpoint.com/k-means-clustering-algorithm-in-machine-learning),
    which seeks to find patterns in a data set by grouping (clustering) similar data
    points.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后者的一种方法是使用[k-means 聚类算法](https://www.javatpoint.com/k-means-clustering-algorithm-in-machine-learning)，该算法通过对相似数据点进行分组（聚类）来寻找数据集中的模式。
- en: In the R programming language, k-means clustering is generally performed using
    the *k-means* function. Unfortunately, Python doesn’t seem to offer an out-of-the-box
    solution that’s as straightforward. K-means clustering for Python is usually carried
    out using the sci-kit-learn library’s sklearn.cluster.KMeans class in conjunction
    with the [matplotlib.pyplot](https://matplotlib.org/3.5.3/api/_as_gen/matplotlib.pyplot.html)
    library.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 编程语言中，k-means 聚类通常使用 *k-means* 函数来执行。不幸的是，Python 似乎没有提供一个像样的现成解决方案。Python
    中的 K-means 聚类通常使用 sci-kit-learn 库的 sklearn.cluster.KMeans 类，并结合 [matplotlib.pyplot](https://matplotlib.org/3.5.3/api/_as_gen/matplotlib.pyplot.html)
    库来进行。
- en: The k-means clustering algorithm is one of the most widely used for unsupervised
    machine learning, and you’ll likely run into it or need to use it sooner or later.
    Thus, it’s one of the first ones you should learn and master.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: K-means 聚类算法是最广泛使用的无监督机器学习算法之一，你可能迟早会遇到它或需要使用它。因此，它是你应该首先学习和掌握的算法之一。
- en: 2\. Decision Tree
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 决策树
- en: The decision tree algorithm is favored because of its accessibility and usability.
    It’s a supervised machine learning algorithm that is mostly used for classification.
    For instance, companies can use it to determine how to handle difficult customers
    through chatbots.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树算法因其易用性和实用性而受到青睐。它是一种监督学习的机器学习算法，主要用于分类。例如，公司可以利用它通过聊天机器人来处理难缠的客户。
- en: The decision tree teaches machines how to make choices from prior experiences.
    One of the reasons it is so popular among new machine learning engineers is because
    it can be modeled and represented visually as a chart or diagram. This quality
    makes it appealing to those with traditional programming skills.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树教会机器如何根据之前的经验做出选择。它之所以在新手机器学习工程师中如此受欢迎，是因为它可以被建模并以图表或图解的形式可视化。这一特点使它对具有传统编程技能的人具有吸引力。
- en: 'There are two main types of decision trees:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树主要有两种类型：
- en: 'Continuous Variable Decision Tree: Refers to [decision trees](/2020/01/decision-tree-algorithm-explained.html)
    with unlimited target variables.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续变量决策树：指的是具有无限目标变量的 [决策树](/2020/01/decision-tree-algorithm-explained.html)。
- en: 'Categorical Variable Decision Tree: Refers to decision trees with grouped limited
    target variables.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类变量决策树：指的是具有分组有限目标变量的决策树。
- en: 'The packages and classes that are most concerned with decision trees in R programming
    include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在R编程中，最关注决策树的包和类包括：
- en: Datasets
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集
- en: caTools
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: caTools
- en: party
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: party
- en: dplyr
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dplyr
- en: magrittr
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: magrittr
- en: Once again, you’ll have to look outward for Python modules to implement this
    algorithm. As with the k-means clustering algorithm, sci-kit-learn contains a
    host of modules for decision trees with sklearn.tree being the most relevant.
    You can also use the [Graphviz module](https://pypi.org/project/graphviz/) to
    render a graphical representation of your decision tree programmatically.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你将不得不寻找Python模块来实现这个算法。与k-means聚类算法一样，sci-kit-learn包含了许多决策树的模块，其中sklearn.tree最为相关。你还可以使用
    [Graphviz模块](https://pypi.org/project/graphviz/) 以编程方式呈现决策树的图形表示。
- en: 3\. Linear Regression Analysis
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 线性回归分析
- en: Linear regression is another well-used supervised machine learning algorithm.
    The goal of linear regression analysis is to deduce an outcome or value based
    on a variable or set of variables.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归是另一种广泛使用的监督机器学习算法。线性回归分析的目标是基于一个或一组变量推断结果或值。
- en: Like most algorithms, the best way to visualize this is using a graph with two
    axes. The Y axis represents the dependent variable, while the X holds the independent
    variable. Linear regression analysis’s goal is to [form or find a relationship](/2022/07/linear-regression-data-science.html)
    between these two variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数算法一样，最佳的可视化方式是使用具有两个坐标轴的图形。Y轴表示因变量，而X轴表示自变量。线性回归分析的目标是 [形成或找到一个关系](/2022/07/linear-regression-data-science.html)。
- en: If an increase in the independent variable causes an increase in the dependent
    variable (similar to exponential growth), this is known as a positive relationship.
    On the other hand, if the dependent variable’s value decreases as the independent
    variable’s value increases (similar to exponential decay), this is known as a
    negative relationship.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自变量的增加导致因变量的增加（类似于指数增长），这被称为正关系。另一方面，如果因变量的值在自变量的值增加时减少（类似于指数衰减），这被称为负关系。
- en: We use a [line of best fit](https://www.investopedia.com/terms/l/line-of-best-fit.asp)
    to determine the relationship, which can be represented using the slope-intercept
    linear equation *y=mx+b*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 [最佳拟合线](https://www.investopedia.com/terms/l/line-of-best-fit.asp) 来确定关系，这可以通过斜率-截距线性方程
    *y=mx+b* 表示。
- en: 'But how do we facilitate linear regression in R and Python? The packages most
    concerned with linear regression analysis in the R programming language are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何在R和Python中实现线性回归呢？R编程语言中最关注线性回归分析的包包括：
- en: ggplot2
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ggplot2
- en: dplyr
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dplyr
- en: broom
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: broom
- en: ggpubr
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ggpubr
- en: The *gg* packages are used for creating and plotting graphs, whereas *dplyr*
    and *broom* are used to manipulate and display data. *sklearn.linear_model* can
    be used to [build your linear regression model](/2020/10/guide-linear-regression-models.html)
    in Python. You can also add NumPY to process large matrices and arrays.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*gg* 包用于创建和绘制图形，而 *dplyr* 和 *broom* 用于操控和展示数据。*sklearn.linear_model* 可用于 [在Python中构建线性回归模型](/2020/10/guide-linear-regression-models.html)。你还可以添加NumPY来处理大矩阵和数组。'
- en: '![A Comparison of Machine Learning Algorithms in Python and R](../Images/1552351011e35887144ae4bbbcf23629.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Python和R中机器学习算法的比较](../Images/1552351011e35887144ae4bbbcf23629.png)'
- en: Photo by [Pexels](https://www.pexels.com/photo/math-equation-printed-on-paper-8482062/)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Pexels](https://www.pexels.com/photo/math-equation-printed-on-paper-8482062/)
    提供
- en: 4\. Logistic Regression
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 逻辑回归
- en: As with linear regression, logistic regression allows us to predict the value
    of a variable based on another (set of) variable(s). However, where linear regression
    uses metric values, logistic regression uses discrete variables. These are dichotomous
    variables that can only have one of two values (yes or no, 0 or 1, true or false,
    etc.).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与线性回归类似，逻辑回归允许我们基于其他（集合的）变量来预测一个变量的值。然而，线性回归使用度量值，而逻辑回归使用离散变量。这些是只能具有两个值之一（是或否，0或1，真或假等）的二分变量。
- en: In the real world, this can be [used to determine the likelihood](https://www.techtarget.com/searchbusinessanalytics/definition/logistic-regression)
    of a person purchasing a product (retail) or the likelihood of them carrying a
    disease (healthcare). For instance, we could use age, height, and weight as independent
    variables (x). And the binary outcome would be the dependent variable (y). Thus,
    x is the domain of real numbers, and y contains discrete values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，这可以[用于确定一个人购买产品（零售）或携带疾病（医疗保健）的可能性](https://www.techtarget.com/searchbusinessanalytics/definition/logistic-regression)。例如，我们可以使用年龄、身高和体重作为自变量（x）。二元结果将是因变量（y）。因此，x
    是实数域，而 y 包含离散值。
- en: The goal of logistic regression is to estimate (predict) the probability of
    an outcome or occurrence. Because the values of the y values are binary, we can’t
    use a linear equation and must use an [activation function](/2022/06/activation-functions-work-deep-learning.html)
    instead.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归的目标是估计（预测）一个结果或事件的概率。由于 y 值是二元的，我们不能使用线性方程，而必须使用[激活函数](/2022/06/activation-functions-work-deep-learning.html)。
- en: 'The Sigmoid Function is used to represent logistic regression:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Sigmoid 函数用于表示逻辑回归：
- en: '*f(x) = L / 1+e^(-x)*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*f(x) = L / 1+e^(-x)*'
- en: or
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '*y = 1/(1+e^-(a+b1x1+b2x2+b3x3+...))*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = 1/(1+e^-(a+b1x1+b2x2+b3x3+...))*'
- en: 'The Python packages and modules most concerned with logistic regression are:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与逻辑回归最相关的 Python 包和模块有：
- en: matplotlib.pyplot
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: matplotlib.pyplot
- en: sklearn.linear_model
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sklearn.linear_model
- en: sklearn.metrics
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sklearn.metrics
- en: The procedure for generating logistic regressions with R is much simpler and
    can be done using the glm() function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R 生成逻辑回归的过程要简单得多，可以使用 glm() 函数来完成。
- en: 5\. Support Vector Machines
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 支持向量机
- en: Support vector machine [(SVM) algorithms](/2022/08/support-vector-machines-intuitive-approach.html)
    are primarily used for classification but can also be used for regression-based
    tasks. SVMs are one of the simplest approaches to classification.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 支持向量机 [(SVM) 算法](/2022/08/support-vector-machines-intuitive-approach.html) 主要用于分类，但也可以用于基于回归的任务。SVM
    是分类问题中最简单的方法之一。
- en: In an SVM, the object that must be classified is represented as a point in an
    n-dimensional space. Each coordinate of this point is called its feature. SVMs
    attempt to classify an object by first drawing a hyperplane so that all points
    of each category are on either side.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SVM 中，必须分类的对象被表示为 n 维空间中的一个点。该点的每个坐标称为其特征。SVM 通过首先绘制一个超平面，使得每个类别的所有点都位于超平面的两侧，来尝试对对象进行分类。
- en: While there could potentially be multiple hyperplanes, SVM attempts to find
    the one that best separates the two categories. It mainly achieves this by finding
    the maximum distance between the categories, known as the margin. The points that
    touch or fall directly on the margin are called the supporting vectors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能存在多个超平面，但 SVM 尝试找到一个最能分离两个类别的超平面。它主要通过找到两个类别之间的最大距离，即边距，来实现。触及或直接落在边距上的点称为支持向量。
- en: Since SVM is a [supervised machine learning method](/2022/03/machine-learning-algorithms-classification.html),
    it requires training data. You can implement this machine learning algorithm in
    Python using sklearn’s dedicated SVM module. SVMs in R are typically handled using
    the contour and plot functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SVM 是一种[监督机器学习方法](/2022/03/machine-learning-algorithms-classification.html)，它需要训练数据。你可以使用
    sklearn 的专用 SVM 模块在 Python 中实现这个机器学习算法。在 R 中，SVM 通常通过轮廓和绘图函数来处理。
- en: Conclusion
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Many of these algorithms are a testament to how heavily reliant machine learning
    is on probability and statistics. Although R predates modern machine learning
    engineering, it’s relevant to it because it is a statistical programming language.
    As such, many of these algorithms can easily be built or implemented out of the
    box.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法中的许多都是机器学习在概率和统计上高度依赖的见证。尽管 R 在现代机器学习工程之前就存在，但它与机器学习相关，因为它是一种统计编程语言。因此，许多算法可以很容易地从头开始构建或实现。
- en: Python is a multi-paradigm general-purpose programming language, so it has a
    wider array of use cases. Sci-kit–learn is the most trusted library for Python
    machine learning modules. If you want to [learn more about the above algorithms](https://scikit-learn.org/stable/)
    and more, visit the library’s official website.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种多范式通用编程语言，因此它具有更广泛的应用场景。Sci-kit-learn 是最受信赖的 Python 机器学习模块库。如果你想要[了解更多关于上述算法](https://scikit-learn.org/stable/)及其他内容，请访问该库的官方网站。
- en: '**[Nahla Davies](http://nahlawrites.com/)** is a software developer and tech
    writer. Before devoting her work full time to technical writing, she managed —
    among other intriguing things — to serve as a lead programmer at an Inc. 5,000
    experiential branding organization whose clients include Samsung, Time Warner,
    Netflix, and Sony.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**[Nahla Davies](http://nahlawrites.com/)** 是一名软件开发人员和技术作家。在将她的工作全职转向技术写作之前，她曾担任
    Inc. 5,000 创意品牌组织的首席程序员，该组织的客户包括三星、时代华纳、Netflix 和索尼。'
- en: '* * *'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our Top 3 Course Recommendations
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的前三名课程推荐
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity)
    - 快速进入网络安全职业'
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics)
    - 提升你的数据分析能力'
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport)
    - 支持组织的 IT 需求'
- en: '* * *'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: More On This Topic
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多相关话题
- en: '[Automated Machine Learning with Python: A Comparison of Different…](https://www.kdnuggets.com/2023/03/automated-machine-learning-python-comparison-different-approaches.html)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 Python 的自动化机器学习：不同方法的比较](https://www.kdnuggets.com/2023/03/automated-machine-learning-python-comparison-different-approaches.html)'
- en: '[ChatGPT vs Google Bard: A Comparison of the Technical Differences](https://www.kdnuggets.com/2023/03/chatgpt-google-bard-comparison-technical-differences.html)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ChatGPT 与 Google Bard：技术差异比较](https://www.kdnuggets.com/2023/03/chatgpt-google-bard-comparison-technical-differences.html)'
- en: '[A Deep Dive into GPT Models: Evolution & Performance Comparison](https://www.kdnuggets.com/2023/05/deep-dive-gpt-models.html)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[深入了解 GPT 模型：演变与性能比较](https://www.kdnuggets.com/2023/05/deep-dive-gpt-models.html)'
- en: '[An Honest Comparison of Open Source Vector Databases](https://www.kdnuggets.com/an-honest-comparison-of-open-source-vector-databases)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[开源向量数据库的诚实比较](https://www.kdnuggets.com/an-honest-comparison-of-open-source-vector-databases)'
- en: '[KDnuggets News, July 20: Machine Learning Algorithms Explained in…](https://www.kdnuggets.com/2022/n29.html)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[KDnuggets 新闻，7月20日：机器学习算法解释](https://www.kdnuggets.com/2022/n29.html)'
- en: '[Machine Learning Algorithms - What, Why, and How?](https://www.kdnuggets.com/2022/09/machine-learning-algorithms.html)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[机器学习算法 - 什么、为什么和如何？](https://www.kdnuggets.com/2022/09/machine-learning-algorithms.html)'
