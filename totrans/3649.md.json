["```py\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\n{instruction}\n\n### Input:\n{input}\n\n### Response:\n{response}\n```", "```py\nimport pandas as pd\n\ndf = pd.read_csv('snli_1.0_train_matched.csv')\ndf['gold_label'].value_counts().plot(kind='barh')\n```", "```py\ndf[df['gold_label'] == 'contradiction'].sample(10)[['sentence1', 'sentence2']]\n```", "```py\ndef convert_to_format(row):\n    sentence1 = row['sentence1']\n    sentence2 = row['sentence2']ccccc\n    prompt = \"\"\"Below is an instruction that describes a task paired with input that provides further context. Write a response that appropriately completes the request.\"\"\"\n    instruction = \"\"\"Given the following sentence, your job is to generate the negation for it in the json format\"\"\"\n    input = str(sentence1)\n    response = f\"\"\"```", "```py\n\"\"\"\n    if len(input.strip()) == 0:  #  prompt + 2 new lines + ###instruction + new line + input + new line + ###response\n        text = prompt + \"\\n\\n### Instruction:\\n\" + instruction + \"\\n### Response:\\n\" + response\n    else:\n        text = prompt + \"\\n\\n### Instruction:\\n\" + instruction + \"\\n### Input:\\n\" + input + \"\\n\" + \"\\n### Response:\\n\" + response\n\n    # we need 4 columns for auto train, instruction, input, output, text\n    return pd.Series([instruction, input, response, text])\n\nnew_df = df[df['gold_label'] == 'contradiction'][['sentence1', 'sentence2']].apply(convert_to_format, axis=1)\nnew_df.columns = ['instruction', 'input', 'output', 'text']\n\nnew_df.to_csv('snli_instruct.csv', index=False)\n```", "```py\n\"Below is an instruction that describes a task paired with input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nGiven the following sentence, your job is to generate the negation for it in the json format\n### Input:\nA couple playing with a little boy on the beach.\n\n### Response:\n```", "```py\n```", "```py\n!pip install -q accelerate==0.21.0 peft==0.4.0 bitsandbytes==0.40.2 transformers==4.31.0 trl==0.4.7\n```", "```py\nimport os\nimport torch\nfrom datasets import load_dataset\nfrom transformers import (\n    AutoModelForCausalLM,\n    AutoTokenizer,\n    BitsAndBytesConfig,\n    HfArgumentParser,\n    TrainingArguments,\n    pipeline,\n    logging,\n)\nfrom peft import LoraConfig, PeftModel\nfrom trl import SFTTrainer\n```", "```py\nfrom google.colab import drive\nimport pandas as pd\n\ndrive.mount('/content/drive')\n\ndf = pd.read_csv('/content/drive/MyDrive/snli_instruct.csv')\n```", "```py\nfrom datasets import Dataset\n\ndataset = Dataset.from_pandas(df)\n```", "```py\n# The model that you want to train from the Hugging Face hub\nmodel_name = \"abhishek/llama-2-7b-hf-small-shards\"\n\n# Fine-tuned model name\nnew_model = \"llama-2-contradictor\"\n\n################################################################################\n# QLoRA parameters\n################################################################################\n\n# LoRA attention dimension\nlora_r = 64\n\n# Alpha parameter for LoRA scaling\nlora_alpha = 16\n\n# Dropout probability for LoRA layers\nlora_dropout = 0.1\n\n################################################################################\n# bitsandbytes parameters\n################################################################################\n\n# Activate 4-bit precision base model loading\nuse_4bit = True\n\n# Compute dtype for 4-bit base models\nbnb_4bit_compute_dtype = \"float16\"\n\n# Quantization type (fp4 or nf4)\nbnb_4bit_quant_type = \"nf4\"\n\n# Activate nested quantization for 4-bit base models (double quantization)\nuse_nested_quant = False\n\n################################################################################\n# TrainingArguments parameters\n################################################################################\n\n# Output directory where the model predictions and checkpoints will be stored\noutput_dir = \"./results\"\n\n# Number of training epochs\nnum_train_epochs = 1\n\n# Enable fp16/bf16 training (set bf16 to True with an A100)\nfp16 = False\nbf16 = False\n\n# Batch size per GPU for training\nper_device_train_batch_size = 4\n\n# Batch size per GPU for evaluation\nper_device_eval_batch_size = 4\n\n# Number of update steps to accumulate the gradients for\ngradient_accumulation_steps = 1\n\n# Enable gradient checkpointing\ngradient_checkpointing = True\n\n# Maximum gradient normal (gradient clipping)\nmax_grad_norm = 0.3\n\n# Initial learning rate (AdamW optimizer)\nlearning_rate = 1e-5\n\n# Weight decay to apply to all layers except bias/LayerNorm weights\nweight_decay = 0.001\n\n# Optimizer to use\noptim = \"paged_adamw_32bit\"\n\n# Learning rate schedule\nlr_scheduler_type = \"cosine\"\n\n# Number of training steps (overrides num_train_epochs)\nmax_steps = -1\n\n# Ratio of steps for a linear warmup (from 0 to learning rate)\nwarmup_ratio = 0.03\n\n# Group sequences into batches with same length\n# Saves memory and speeds up training considerably\ngroup_by_length = True\n\n# Save checkpoint every X updates steps\nsave_steps = 0\n\n# Log every X updates steps\nlogging_steps = 100\n\n################################################################################\n# SFT parameters\n################################################################################\n\n# Maximum sequence length to use\nmax_seq_length = None\n\n# Pack multiple short examples in the same input sequence to increase efficiency\npacking = False\n\n# Load the entire model on the GPU 0\ndevice_map = {\"\": 0}\n```", "```py\ncompute_dtype = getattr(torch, bnb_4bit_compute_dtype)\n\nbnb_config = BitsAndBytesConfig(\n    load_in_4bit=use_4bit,\n    bnb_4bit_quant_type=bnb_4bit_quant_type,\n    bnb_4bit_compute_dtype=compute_dtype,\n    bnb_4bit_use_double_quant=use_nested_quant,\n)\n```", "```py\ntokenizer = AutoTokenizer.from_pretrained(model_name, trust_remote_code=True)\ntokenizer.pad_token = tokenizer.eos_token\ntokenizer.padding_side = \"right\"\n\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    quantization_config=bnb_config,\n    device_map=device_map\n)\nmodel.config.use_cache = False\nmodel.config.pretraining_tp = 1\n```", "```py\n# Load LoRA configuration\npeft_config = LoraConfig(\n    lora_alpha=lora_alpha,\n    lora_dropout=lora_dropout,\n    r=lora_r,\n    bias=\"none\",\n    task_type=\"CAUSAL_LM\",\n)\n\n# Set training parameters\ntraining_arguments = TrainingArguments(\n    output_dir=output_dir,\n    num_train_epochs=num_train_epochs,\n    per_device_train_batch_size=per_device_train_batch_size,\n    gradient_accumulation_steps=gradient_accumulation_steps,\n    optim=optim,\n    save_steps=save_steps,\n    logging_steps=logging_steps,\n    learning_rate=learning_rate,\n    weight_decay=weight_decay,\n    fp16=fp16,\n    bf16=bf16,\n    max_grad_norm=max_grad_norm,\n    max_steps=max_steps,\n    warmup_ratio=warmup_ratio,\n    group_by_length=group_by_length,\n    lr_scheduler_type=lr_scheduler_type,\n    report_to=\"tensorboard\"\n)\n```", "```py\n# Set supervised fine-tuning parameters\ntrainer = SFTTrainer(\n    model=model,\n    train_dataset=dataset,\n    peft_config=peft_config,\n    dataset_text_field=\"text\",  # this is the text column in dataset \n    max_seq_length=max_seq_length,\n    tokenizer=tokenizer,\n    args=training_arguments,\n    packing=packing,\n)\n\n# Train model\ntrainer.train()\n\n# Save trained model\ntrainer.model.save_pretrained(new_model)\n```", "```py\n!zip -r llama-contradictor.zip results llama-contradictor\n!mv llama-contradictor.zip /content/drive/MyDrive\n```", "```py\n!unzip /content/drive/MyDrive/llama-contradictor.zip -d .\n```", "```py\ntokenizer = AutoTokenizer.from_pretrained(model_name, trust_remote_code=True)\ntokenizer.pad_token = tokenizer.eos_token\ntokenizer.padding_side = \"right\"\n\nbase_model = AutoModelForCausalLM.from_pretrained(\n    \"abhishek/llama-2-7b-hf-small-shards\",\n    low_cpu_mem_usage=True,\n    return_dict=True,\n    torch_dtype=torch.float16,\n    device_map={\"\": 0},\n)\n\nmodel = PeftModel.from_pretrained(base_model, '/content/llama-contradictor')\nmodel = model.merge_and_unload()\npipe = pipeline(task=\"text-generation\", model=model, tokenizer=tokenizer, max_length=200)\n```", "```py\nprompt_template = \"\"\"### Instruction:\nGiven the following sentence, your job is to generate the negation for it in the json format\n### Input:\n{}\n\n### Response:\n\"\"\"\n\nsentence = \"The weather forecast predicts a sunny day with a high temperature around 30 degrees Celsius, perfect for a day at the beach with friends and family.\"\n\ninput_sentence = prompt_template.format(sentence.strip())\n\nresult = pipe(input_sentence)\nprint(result)\n```", "```py\n### Instruction:\nGiven the following sentence, your job is to generate the negation for it in the json format\n### Input:\nThe weather forecast predicts a sunny day with a high temperature around 30 degrees Celsius, perfect for a day at the beach with friends and family.\n\n### Response:\n```", "```py\n```", "```py\nimport re\nimport json\n\ndef format_results(s):\n  pattern = r'```", "```py'\n\n  # Find all occurrences of JSON objects in the string\n  json_matches = re.findall(pattern, s, re.DOTALL)\n  if not json_matches:\n    # try to find 2nd pattern\n    pattern = r'\\{.*?\"sentence\":.*?\"negation\":.*?\\}'\n    json_matches = re.findall(pattern, s)\n\n  # Return the first JSON object found, or None if no match is found\n  return json.loads(json_matches[0]) if json_matches else None\n```"]