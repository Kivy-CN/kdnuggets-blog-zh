["```py\nimport autograd.numpy as np\nfrom autograd import elementwise_grad as egrad\n\nimport matplotlib.pyplot as plt\n\nx = np.linspace(-31.4,31.4, 256)\n\nsinc = lambda x: np.sin(x) / x\n\nplt.figure(figsize=(12,7))\n\nplt.title(“sinc function and derivatives”, fontsize=24)\n\nmy_fn = sinc\n\nfor ii in range(9):\n\n    plt.plot(x, my_fn(x), lw=3, label=”d{} sinc(x)/dx{}”.format(ii,ii))\n\n    plt.legend(fontsize=18)\n\n    plt.axis([-32, 32, -0.50, 1.2])\n\n    plt.savefig(“./sinc_grad{}.png”.format(ii))\n\n    my_fn = egrad(my_fn) \n```", "```py\nepoch 10, training loss 2.89e+02, train acc: 5.64e-01, val loss 3.94e+02, val accuracy 4.75e-01\ntotal time: 4.26, epoch time 0.38\n\nepoch 20, training loss 8.79e+01, train acc: 8.09e-01, val loss 9.96e+01, val accuracy 7.99e-01\n\ntotal time: 7.73, epoch time 0.33\n\nepoch 30, training loss 4.54e+01, train acc: 9.20e-01, val loss 4.55e+01, val accuracy 9.39e-01\n\ntotal time: 11.49, epoch time 0.35\n\n…\n\nepoch 280, training loss 1.77e+01, train acc: 9.99e-01, val loss 1.39e+01, val accuracy 9.83e-01\n\ntotal time: 110.70, epoch time 0.49\n\nepoch 290, training loss 1.76e+01, train acc: 9.99e-01, val loss 1.39e+01, val accuracy 9.83e-01\n\ntotal time: 115.41, epoch time 0.43\n```", "```py\nimport autograd.numpy as np\nfrom autograd import grad\n\nimport matplotlib.pyplot as plt \n\nimport time\n\nimport skimage\n\nimport skimage.io as sio \n```", "```py\ndef asm_prop(wavefront, length=32.e-3, \\\nwavelength=550.e-9, distance=10.e-3):\n\n    if len(wavefront.shape) == 2:\n\n        dim_x, dim_y = wavefront.shape\n\n    elif len(wavefront.shape) == 3:\n\n        number_samples, dim_x, dim_y = wavefront.shape\n\n    else:\n\n        print(“only 2D wavefronts or array of 2D wavefronts supported”)\n\n    assert dim_x == dim_y, “wavefront should be square”\n\n    px = length / dim_x\n\n    l2 = (1/wavelength)**2\n\n    fx = np.linspace(-1/(2*px), 1/(2*px) – 1/(dim_x*px), dim_x)\n\n    fxx, fyy = np.meshgrid(fx,fx)\n\n    q = l2 – fxx**2 – fyy**2\n\n    q[q<0] = 0.0\n\n    h = np.fft.fftshift(np.exp(1.j * 2 * np.pi * distance * np.sqrt(q)))\n\n    fd_wavefront = np.fft.fft2(np.fft.fftshift(wavefront))\n\n    if len(wavefront.shape) == 3:\n\n        fd_new_wavefront = h[np.newaxis,:,:] * fd_wavefront\n\n        New_wavefront = np.fft.ifftshift(np.fft.ifft2(\\\n\n                fd_new_wavefront))[:,:dim_x,:dim_x]\n\n    else:\n\n        fd_new_wavefront = h * fd_wavefront\n\n        new_wavefront = np.fft.ifftshift(np.fft.ifft2(\\\n\n                fd_new_wavefront))[:dim_x,:dim_x]\n\n    return new_wavefront\n```", "```py\ndef onn_layer(wavefront, phase_objects, d=100.e-3):\n    for ii in range(len(phase_objects)):\n\n        wavefront = asm_prop(wavefront * phase_objects[ii], distance=d)\n\n    return wavefront\n```", "```py\ndef get_loss(wavefront, y_tgt, phase_objects, d=100.e-3):\n    img = np.abs(onn_layer(wavefront, phase_objects, d=d))**2\n\n    mse_loss = np.mean( (img – y_tgt)**2 + np.abs(img-y_tgt) )\n\n    return mse_loss\n\nget_grad = grad(get_loss, argnum=2)\n```", "```py\n# target image\ntgt_img = sio.imread(“./smiley.png”)[:, :, 0]\n\ny_tgt = 1.0 * tgt_img / np.max(tgt_img)\n\n# set up input wavefront (a flat plane wave with an 16mm aperture)\n\ndim = 128\n\nside_length = 32.e-3\n\naperture = 8.e-3\n\nwavelength = 550.e-9\n\nk0 = 2*np.pi / wavelength\n\npx = side_length / dim\n\nx = np.linspace(-side_length/2, side_length/2-px, dim)\n\nxx, yy = np.meshgrid(x,x)\n\nrr = np.sqrt(xx**2 + yy**2)\n\nwavefront = np.zeros((dim,dim)) * np.exp(1.j*k0*0.0)\n\nwavefront[rr <= aperture] = 1.0 \n```", "```py\nlr = 1e-3\ndist = 50.e-3\n\nphase_objects = [np.exp(1.j * np.zeros((128,128))) \\\n\n        for aa in range(32)]\n\nlosses = []\n```", "```py\nfor step in range(128):\n    my_grad = get_grad(wavefront, y_tgt, phase_objects, d=dist)\n\n    for params, grads in zip(phase_objects, my_grad):\n\n        params -= lr * np.exp( -1.j * np.angle(grads))\n\n     loss = get_loss(wavefront, y_tgt, phase_objects,d=dist)\n\n     losses.append(loss)\n\n     img = np.abs(onn_layer(wavefront, phase_objects))**2\n\n     print(“loss at step {} = {:.2e}, lr={:.3e}”.format(step, loss, lr))\n\n     fig = plt.figure(figsize=(12,7))\n\n     plt.imshow(img / 2.0, cmap=”jet”)\n\n     plt.savefig(“./smiley_img{}.png”.format(step))\n\n     plt.close(fig)\n\nfig = plt.figure(figsize=(7,4))\n\nplt.plot(losses, lw=3)\n\nplt.savefig(“./smiley_losses.png”)\n```"]