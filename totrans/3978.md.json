["```py\n# Import NumPy package\nimport numpy as np\n\n# Create arrays\na1 = np.array([[0, 1, 0], [2, 3, 2]])\na2 = np.array([[3, 4, 3], [5, 6, 5]]) \n```", "```py\n# Print one of the arrays\nprint('Array 1:', '\\n', a1, '\\n Shape: \\nâ€™, a1.shape) \n```", "```py\nArray 1: \n[[0 1 0]\n[2 3 2]]\n\nShape: (2, 3) \n```", "```py\n# Using np.add\nfunc_add = np.add(a1, a2)\n\n# Using the + operator\nop_add = a1 + a2 \n```", "```py\n# Print results\nprint('Function: \\n', func_add, '\\n\\n', 'Operator: \\n', op_add) \n```", "```py\nFunction: \n[[3 5 3]\n[7 9 7]]\n\nOperator: \n[[3 5 3]\n[7 9 7]] \n```", "```py\nimport numpy as np\nimport timeit\n\ndef func():\n\na1 = np.array([[0, 1, 0], [2, 3, 2]])\na2 = np.array([[3, 4, 3], [5, 6, 5]])\nnp.add(a1, a2)\n\ndef op():\n\na1 = np.array([[0, 1, 0], [2, 3, 2]])\na2 = np.array([[3, 4, 3], [5, 6, 5]])\na1 + a2\n\n# Timing the functions over 100000 iterations\nfunc_time = timeit.timeit(func, number=100000)\nop_time = timeit.timeit(op, number=100000)\n\n# Print timing results\nprint('Function:', func_time, '\\n', 'Operator:', op_time) \n```", "```py\nFunction: 0.2588757239282131 \nOperator: 0.24321464297827333 \n```", "```py\n# Using np.transpose\nfunc_a1_T = np.transpose(a1)\n\n# Using the .T attribute\natt_a1_T = a1.T \n```", "```py\n# Using np.dot\nfunc_dot = np.dot(func_a1_T, a2)\n\n# Using the @ operator\nop_dot = func_a1_T @ a2 \n```"]