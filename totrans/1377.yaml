- en: 'Complex logic at breakneck speed: Try Julia for data science'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2020/05/complex-logic-breakneck-speed-julia-data-science.html](https://www.kdnuggets.com/2020/05/complex-logic-breakneck-speed-julia-data-science.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[comments](#comments)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5d6555e62b617548bbed3402d2839b51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'NOTE: I am building a Github repo with Julia fundamentals and data science
    examples. [**Check it out here**](https://github.com/tirthajyoti/Julia-data-science).'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Walks like Python, runs like C”* — this has been said about Julia, a modern
    programming language, **focused on scientific computing**,and having an ever-increasing
    base of followers and developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia, a general-purpose programming language, is made specifically for scientific
    computing. It is a [**flexible**](https://docs.julialang.org/en/v1/manual/types/)[**dynamically-typed**](https://android.jlelse.eu/magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b) language
    with **performance comparable to traditional statically-typed languages**.
  prefs: []
  type: TYPE_NORMAL
- en: Julia tries to provide a single environment productive enough for prototyping
    and efficient for industrial-grade applications. It is a multi-paradigm language
    encompassing both [functional](https://codeburst.io/a-beginner-friendly-intro-to-functional-programming-4f69aa109569) and
    object-oriented programming components, although the **majority of the users like
    its functional programming aspects**.
  prefs: []
  type: TYPE_NORMAL
- en: The inception of this programming language can be traced back to 2009\. The
    lead developers Alan Edelman, Jeff Bezanson, Stefan Karpinski, and Viral Shah
    started working on creating a language that can be used for better and faster
    numerical computing. The developers were able to launch a commercial release in
    February 2012.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it awesome for data science?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/10599c0ed770099e3221c65b266532a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia is an excellent choice for data science and machine learning work, for
    much of the same reason, that it is a great choice for fast numerical computing.
    The advantages include,
  prefs: []
  type: TYPE_NORMAL
- en: '**A smooth learning curve**, and the extensive underlying functionality. Especially,
    if you are already familiar with the more popular data science languages like
    Python and R, picking up Julia will be a walk in the park.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Originally, Julia is a compiled language, while Python and
    R are interpreted. This means that the Julia code is executed on the processor
    as a direct executable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPU Support**: It is directly related to performance. GPU support is transparently
    controlled by some packages such as `TensorFlow.jl` and `MXNet.jl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed and Parallel Computing Support**: Julia supports parallel and
    distributed computing transparently using many topologies. And there is also support
    for coroutines, like in Go programming language, which are helper functions that
    work in parallel on the Multicore architecture. Extensive support for threads
    and synchronization is primarily designed to maximize performance and reduce the
    risk of race conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rich data science and visualization libraries**: Julia community understands
    that it was conceived as a go-to language for data scientists and statisticians.
    Therefore, high-performance libraries focusing on data science and analytics are
    always in development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Teamwork (with other languages/frameworks)**: Julia plays really really well
    with other established languages and frameworks for data science and machine learning.
    Using `PyCall` or `RCall` one can use native Python or R code inside a Julia script.
    The `Plots` package works with various backend including `Matplotlib` and `Plotly`.
    Popular machine learning libraries like `Scikit-learn` or `TensorFlow` already
    have Julia equivalent or wrappers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia is an excellent choice for data science and machine learning work, for
    much of the same reason, that it is a great choice for fast numerical computing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some benchmarking with Python scripting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a lot of controversy with regard to the question: “**Is Julia faster
    than Python?**”'
  prefs: []
  type: TYPE_NORMAL
- en: Like almost anything else in life, the answer is: ***It depends.***
  prefs: []
  type: TYPE_NORMAL
- en: The official Julia language portal has some data about it, although the benchmark
    tests were done with respect to various languages other than Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[**The Julia Language**](https://julialang.org/benchmarks/)'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the question almost always assumes that one is talking about the comparison
    between Julia and some kind of optimized/vectorized Python code (like used by
    Numpy functions). Otherwise, native Julia is almost always faster than Python
    because of compiled code execution, and [native Python is way slower than Numpy-type
    execution](https://towardsdatascience.com/why-you-should-forget-for-loop-for-data-science-code-and-embrace-vectorization-696632622d5f).
  prefs: []
  type: TYPE_NORMAL
- en: Numpy is seriously fast. It is a library with super-optimized functions (many
    of them pre-compiled), with a dedicated focus of giving Python users (particularly
    useful for data scientists and ML engineers) near-C speed. Simple Numpy functions
    like sum or standard deviation [can match or beat equivalent Julia implementations
    closely (particularly for large input array size](https://github.com/kbarbary/website/blob/master/posts/julia-vs-numpy-arrays.rst)).
  prefs: []
  type: TYPE_NORMAL
- en: However, to take full advantage of Numpy functions, you have to think in terms
    of vectorizing your code. And it is not easy at all to write complex logic in
    a program in the form vectorized code all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the speed comparison with Julia should be done for situations where
    somewhat complex logic is applied to an array for some kind of processing.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we will show a couple of such examples to illustrate the point.
  prefs: []
  type: TYPE_NORMAL
- en: However, to take full advantage of Numpy functions, you have to think in terms
    of vectorizing your code
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Julia for-loop beats Python for-loop handsomely
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s compute the sum of a million random integers to test this out.
  prefs: []
  type: TYPE_NORMAL
- en: Julia code is below. The function takes a little over **1 millisecond.**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f00f6dcec5f39578a8e4d64e816ea9c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Python code is below. We kept the same functional nature of the code (Julia
    is a functional language) to keep the comparison fair and easy to verify. The
    for-loop takes **over 200 milliseconds**!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/892c5d3f6b017da7b0182bd6a7a05834.png)'
  prefs: []
  type: TYPE_IMG
- en: But how does a Julia array compare to Numpy array?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the code above, we created an array variable. This is the most useful data
    structure in Julia for data science as it can be directly used for statistical
    computation or linear algebra operations, right out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: No need for a separate library or anything. Julia arrays are order-of-magnitude
    faster than Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: But, Numpy arrays are fast and let’s benchmark the same summing operation.
  prefs: []
  type: TYPE_NORMAL
- en: Julia code below using the `sum()` function on the array. It takes ~**451 msec** (faster
    than the for-loop approach but only half the time).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5cf9fb542ccb1d3cb22357d95d349654.png)'
  prefs: []
  type: TYPE_IMG
- en: And here is Numpy execution,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d0d136a018840ab08c222a0606783be8.png)'
  prefs: []
  type: TYPE_IMG
- en: Wow! **353 msec** which beats the Julia speed and almost 628 times faster than
    naive Python for-loop code.
  prefs: []
  type: TYPE_NORMAL
- en: So, is the verdict settled in favor of Numpy array?
  prefs: []
  type: TYPE_NORMAL
- en: Not so fast. What if we wanted to sum up only the odd numbers in the array?
  prefs: []
  type: TYPE_NORMAL
- en: No need for a separate library. Julia arrays are order-of-magnitude faster than
    Python lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here comes the logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Julia, the code change will be fairly straightforward. We will just use
    the for-loop, check if an element of the array is divisible by 2, and if not (odd
    number), then add it to the running sum. As pedantic as one can get!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/120bec7547204a263b62e8657dd52363.png)'
  prefs: []
  type: TYPE_IMG
- en: So, that ran in **close to 4 milliseconds**. Certainly slower than just the
    blind sum (using the for loop) but not too much (the for-loop plain sum too ~1.1
    milliseconds).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we certainly cannot compete with this speed with a Python for-loop! We
    know how that will turn out, don’t we? So, we have to use a Numpy vectorized code.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we check for odd numbers and only then sum them up in case of a Numpy
    array? Fortunately, we have the `np.where()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the Python code. Not that straightforward (unless you know how to use
    the `np.where` (correctly), is it?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0b980fcdff9cddf459accbf33b0a8d7e.png)'
  prefs: []
  type: TYPE_IMG
- en: But look at the speed. Even with a single-line of vectorized code using Numpy
    method, that took **16.7 milliseconds** on average.
  prefs: []
  type: TYPE_NORMAL
- en: Julia code was simpler and ran faster!
  prefs: []
  type: TYPE_NORMAL
- en: Another slightly complicated operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we have three arrays (say ***W***, ***X***, and ***B***) with random
    floating-point numbers ranging from -2 to 2 and we want to compute a special quantity:
    product of two of these arrays, added to the third i.e. ***A***.***X***+***B*** but
    the quantity will be added to the final sum only if the element-wise linear combination
    exceeds zero***.***'
  prefs: []
  type: TYPE_NORMAL
- en: Does this logic look familiar to you? It is a variation on any densely connected
    neural network (or even a single perceptron), where the linear combination of
    weight, feature, and bias vector has to exceed a certain threshold to propagate
    to the next layer.
  prefs: []
  type: TYPE_NORMAL
- en: So, here is the Julia code. Again, simple and sweet. Took ~**1.8 milliseconds**.
    Note, it uses a special function called `muladd()` which multiplies two numbers
    and adds to a third.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/87526a916a991ca9c76654020058bb2e.png)'
  prefs: []
  type: TYPE_IMG
- en: We tried the Python using a similar code (using for-loop), and the result was
    terrible, as expected! It took **more than a second** on average.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/db66467a4bdbd3e65d459946fc811de6.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, we tried to be creative and use a Numpy vectorized code and the result
    was much better than the for-loop case, but worse than the Julia case ~ **14.9
    milliseconds**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b615c50f8439981ee85950423df97973.png)'
  prefs: []
  type: TYPE_IMG
- en: So, how does it look like?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, the trend is becoming clear. For numerical operations, where
    complex logic needs to be checked before some mathematical operation can happen,
    Julia beats Python (even Numpy) hands down because **we can just write the logic
    in the simplest possible code in Julia and forget it**. It will still run at breakneck
    speed, thanks to the [just-in-time (JIT) compiler](https://agilescientific.com/blog/2014/9/4/julia-in-a-nutshell.html) and
    internal type-related optimizations (Julia has an [extremely elaborate type system](https://en.wikibooks.org/wiki/Introducing_Julia/Types) to
    make programs runs fast with correct data types for each variable and optimizing
    code and memory correspondingly).
  prefs: []
  type: TYPE_NORMAL
- en: Writing the same code using native Python data structures and for-loop is hopelessly
    slow. Even with a Numpy vectorized code, the speed is slower than that of Julia
    as the complexity grows.
  prefs: []
  type: TYPE_NORMAL
- en: Numpy is great for the simple methods that an array already comes with such
    as `sum()` or `mean()` or `std()`, but using logic along with them is not always
    straightforward and it slows the operation down considerably.
  prefs: []
  type: TYPE_NORMAL
- en: '**In Julia, there is not much headache of thinking hard to vectorize your code**.
    Even an apparently stupid-looking code, with a plain vanilla for-loop and element-by-element
    logic checking, runs amazingly fast!'
  prefs: []
  type: TYPE_NORMAL
- en: For numerical operations, where complex logic needs to be checked before some
    mathematical operation can happen, Julia beats Python (even Numpy) hands down
    because we can just write the logic in the simplest possible code in Julia and
    forget it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this article, we showed some comparative benchmark of numerical computation
    between Julia and Python — both native Python code and optimized Numpy functions.
  prefs: []
  type: TYPE_NORMAL
- en: Although in the case of straightforward functions, Numpy is on par with Julia
    in terms of speed, Julia scores higher when complex logic is introduced in the
    computing problem. Julia code is inherently simple to write without the need to
    think hard about vectorizing the functions.
  prefs: []
  type: TYPE_NORMAL
- en: With many ongoing developments in the data science and machine learning support
    systems, Julia is one of the most exciting new languages to look forward to in
    the coming days. This is one tool, that budding data scientists should add to
    their repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: I am building a Github repo with Julia fundamentals and data science examples. [**Check
    it out here**](https://github.com/tirthajyoti/Julia-data-science).
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional reading**'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-tips-1](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-tips-1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://agilescientific.com/blog/2014/9/4/julia-in-a-nutshell.html](https://agilescientific.com/blog/2014/9/4/julia-in-a-nutshell.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://en.wikibooks.org/wiki/Introducing_Julia/Types](https://en.wikibooks.org/wiki/Introducing_Julia/Types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://dev.to/epogrebnyak/julialang-and-surprises---what-im-learning-with-a-new-programming-language--21df](https://dev.to/epogrebnyak/julialang-and-surprises---what-im-learning-with-a-new-programming-language--21df)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have any questions or ideas to share, please contact the author at [**tirthajyoti[AT]gmail.com**](mailto:tirthajyoti@gmail.com).
    Also, you can check the author’s [**GitHub**](https://github.com/tirthajyoti?tab=repositories)** repositories **for
    code, ideas, and resources in machine learning and data science. If you are, like
    me, passionate about AI/machine learning/data science, please feel free to [add
    me on LinkedIn](https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/) or [follow
    me on Twitter](https://twitter.com/tirthajyotiS).
  prefs: []
  type: TYPE_NORMAL
- en: '**Bio: [Tirthajyoti Sarkar](https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/)**
    is Sr Principal Engineer at ON Semiconductor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](https://towardsdatascience.com/complex-logic-at-breakneck-speed-try-julia-for-data-science-bcd4dfa23541).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Guerrilla Guide to Machine Learning with Julia](/2017/07/guerrilla-guide-machine-learning-julia.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Whole Data Science World in Your Hands](/2019/06/whole-data-science-world.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing Gen: MIT’s New Language That Wants to be the TensorFlow of Programmable
    Inference](/2019/07/introducing-gen-language-progammable-inference.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[5 Free Julia Books For Data Science](https://www.kdnuggets.com/2023/06/5-free-julia-books-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3 Julia Packages for Data Visualization](https://www.kdnuggets.com/2023/02/3-julia-packages-data-visualization.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Learn Data Analysis with Julia](https://www.kdnuggets.com/learn-data-analysis-with-julia)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Should I Learn Julia?](https://www.kdnuggets.com/2022/11/learn-julia.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Setup Julia on Jupyter Notebook](https://www.kdnuggets.com/2022/11/setup-julia-jupyter-notebook.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10 Simple Things to Try Before Neural Networks](https://www.kdnuggets.com/2021/12/10-simple-things-try-neural-networks.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
