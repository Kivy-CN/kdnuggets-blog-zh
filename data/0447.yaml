- en: How to Answer Data Science Coding Interview Questions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何回答数据科学编码面试问题
- en: 原文：[https://www.kdnuggets.com/2022/01/answer-data-science-coding-interview-questions.html](https://www.kdnuggets.com/2022/01/answer-data-science-coding-interview-questions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2022/01/answer-data-science-coding-interview-questions.html](https://www.kdnuggets.com/2022/01/answer-data-science-coding-interview-questions.html)
- en: '![How to Answer Data Science Coding Interview Questions](../Images/b36e2798a8cc9f7c19c0e7e45050a647.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![如何回答数据科学编码面试问题](../Images/b36e2798a8cc9f7c19c0e7e45050a647.png)'
- en: There’s no recipe for how you should answer data science coding interview questions.
    There’s no one approach that will always work. However, there are some guiding
    principles that, in most cases, will help you better answer the coding questions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于如何回答数据科学编码面试问题，没有固定的公式。没有一种方法可以总是有效。然而，有一些指导原则在大多数情况下会帮助你更好地回答编码问题。
- en: These guidelines are formed on the experience of going to the interviews and
    answering the coding questions. We divided these guidelines into four sections.
    You can use these guidelines as a checklist, especially if you’re not that experienced
    with [data science coding interview questions](https://www.stratascratch.com/blog/data-science-coding-interview-questions-with-5-technical-concepts/).
    Later on, you’ll, of course, be able to find your own approach, maybe disregard
    some points or even include something that works for you better.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指导原则基于参加面试和回答编码问题的经验。我们将这些指导原则分成四个部分。你可以将这些指导原则作为清单使用，特别是如果你对[data science
    coding interview questions](https://www.stratascratch.com/blog/data-science-coding-interview-questions-with-5-technical-concepts/)还不够熟悉的话。当然，之后你会找到自己的方法，也许会忽略一些要点，甚至加入一些对你更有效的内容。
- en: But no matter your experience, if you follow this checklist, you’re increasing
    your chances of giving a great answer to a coding question.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论你的经验如何，如果你遵循这个清单，你就会提高对编码问题给出优秀回答的机会。
- en: The Four-Part Checklist
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 四部分清单
- en: 'The four parts of this checklist are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单的四个部分是：
- en: Question Analysis
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题分析
- en: Approach to Solution
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案的思路
- en: Writing a Code
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码
- en: Reviewing Your Code
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查你的代码
- en: Now that you have the checklist outline, we’ll look into every section and explain
    the checklist points it contains.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了清单的概要，我们将逐一探讨每个部分，并解释其中包含的清单点。
- en: 1\. Question Analysis
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1. 问题分析
- en: The Question Analysis part of the checklist deals with taking a few minutes
    and thoroughly thinking about the question you just got. Like you will see when
    dealing with real business problems, it’s always better to first think about the
    problem and “lose” some time to see it from all perspectives. Remember, thinking
    is never a waste of time!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单中的问题分析部分涉及花费几分钟时间，彻底思考你刚刚得到的问题。正如你在处理实际商业问题时会看到的那样，首先思考问题并“浪费”一些时间从各个角度看待它总是更好。记住，思考绝不是浪费时间！
- en: These few minutes will pay off later. If you immediately jump to writing the
    solution, the chances are high that you’ll have to start from scratch once you’ve
    realized your approach doesn’t lead to the desired solution. Or that you constantly
    have to change and rewrite your code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这几分钟的时间会在之后得到回报。如果你立即跳到编写解决方案，可能会发现一旦你意识到你的方法无法达到预期的解决方案，你就不得不从头开始。或者你需要不断更改和重写你的代码。
- en: 'The points that will help you practice thinking about the problem are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将帮助你练习思考问题的要点包括：
- en: Understand the question
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解问题
- en: Analyze the tables and data you are working with
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析你正在处理的表格和数据
- en: Think about the code result
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 思考代码结果
- en: '**i. Understand the Question**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**i. 理解问题**'
- en: To make sure you understand the question, you’ll have to read the question very
    carefully. Read it slowly. And read it 2-3 times to make sure you didn’t miss
    anything. This applies to all [data science interview questions](https://www.stratascratch.com/blog/data-science-interview-guide-questions-from-80-different-companies/),
    no matter how easy or hard they are. The point is, you won’t know if the question
    you got is hard or easy. Some of the questions can look deceptively simple, but
    they have some catch which is there exactly to eliminate those candidates who
    are not thorough enough and tend to be superficial.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你理解了问题，你需要非常仔细地阅读问题。慢慢阅读。阅读2-3遍，确保没有遗漏任何内容。这适用于所有[data science interview
    questions](https://www.stratascratch.com/blog/data-science-interview-guide-questions-from-80-different-companies/)，无论问题有多简单或多难。重点是，你不会知道你得到的问题是难还是易。有些问题看似简单，但它们实际上有一些陷阱，正是为了排除那些不够彻底、倾向于肤浅的候选人。
- en: If the question is not written, also feel free to ask the interviewer to repeat
    it if you didn’t catch something. In this case, it’s also advisable, once you
    understand the question, to repeat it back to the interviewer. That way, you’ll
    make sure you got it all right and allow the interviewer to correct themselves
    in case they didn’t give you all the necessary information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题没有写清楚，也可以请面试官重复一遍，如果你没有听清楚的话。在这种情况下，一旦你理解了问题，也建议你将问题复述一遍给面试官。这样，你可以确保你理解正确，并允许面试官纠正自己，以防他们没有给你提供所有必要的信息。
- en: '**ii. Analyze the Tables and Data You’re Working With**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**ii. 分析你所处理的表和数据**'
- en: Once you understand the question, the next logical step is to analyze the tables
    you’re given. This means you need to analyze how many tables there are and how
    they are connected to each other (foreign key and primary key).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了问题，接下来的逻辑步骤是分析你所给出的表。这意味着你需要分析表的数量以及它们如何相互关联（外键和主键）。
- en: You’ll also want to see what data is in these tables. Meaning what columns are
    there in each table. What type of data is in every column. This is important because
    your code will depend on whether you’re handling string data, integer, money,
    or any other type of data. Maybe you’ll even need to convert one data type to
    another to get the desired result.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要查看这些表中的数据。也就是说，每个表中有哪些列。每列的数据类型是什么。这一点很重要，因为你的代码将取决于你处理的是字符串数据、整数、货币或其他类型的数据。也许你甚至需要将一种数据类型转换为另一种，以获得期望的结果。
- en: Besides the data type, it’s also important to understand how data is organized,
    ordered, and granulated. Meaning, are there duplicate values in the table? Is
    data presented on a, say, customer level, transaction level, etc.?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据类型，还需要了解数据如何组织、排序和颗粒化。意思是，表中是否有重复值？数据是否以客户级别、交易级别等方式呈现？
- en: '**iii. Think About the Code Result**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**iii. 考虑代码结果**'
- en: Before you start coding, you should know how you want your result to look like.
    This, of course, also depends on the question you want to answer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编码之前，你应该知道你希望结果是什么样的。这当然也取决于你要回答的问题。
- en: But thinking about the result literary means, will it be only one value in one
    line or a table with several columns. If it’s a table, you again have to think
    about how your data will be aggregated and ordered, how many columns you have
    to show, etc.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但要从结果的字面意思来思考，它会是单行中的一个值，还是包含几个列的表。如果是表格，你还需要考虑数据将如何汇总和排序，需要显示多少列等。
- en: '**Question Analysis – Example**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题分析 – 示例**'
- en: 'To show you how this first section of the checklist should be applied, we’ll
    use the Dropbox coding question. The question goes like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你展示如何应用清单的第一部分，我们将使用 Dropbox 编程问题。问题如下：
- en: '![How to Answer Data Science Coding Interview Questions](../Images/de8cba848dd5b032e6e1b12d826e5136.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![如何回答数据科学编程面试问题](../Images/de8cba848dd5b032e6e1b12d826e5136.png)'
- en: '*“Write a query that calculates the difference between the highest salaries
    found in the marketing and engineering departments. Output just the difference
    in salaries.”*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*“编写一个查询，计算市场营销和工程部门中最高工资之间的差异。仅输出工资差异。”*'
- en: Link to the question: [https://platform.stratascratch.com/coding/10308-salaries-differences](https://platform.stratascratch.com/coding/10308-salaries-differences?python=)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10308-salaries-differences](https://platform.stratascratch.com/coding/10308-salaries-differences?python=)
- en: 'If you carefully read the question, you’ll realize that you’re required to
    find the highest salary. OK, but not the highest salary in every department but
    only in two departments: marketing and engineering. Once you find the highest
    salary in these two departments, you need to calculate the difference between
    them.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读问题，你会发现你需要找到最高的工资。好的，但不是每个部门的最高工资，而只是两个部门的：市场营销和工程。找到这两个部门的最高工资后，你需要计算它们之间的差异。
- en: 'Now that you understand the question, you can analyze the tables and data in
    them. The tables you’ll work with are db_employee and db_dept. The table db_employee
    contains data about company employees. It has five columns:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你理解了问题，你可以分析表和其中的数据。你将处理的表是 db_employee 和 db_dept。表 db_employee 包含有关公司员工的数据。它有五列：
- en: '| id | int |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| id | int |'
- en: '| first_name | varchar |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| first_name | varchar |'
- en: '| last_name | varchar |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| last_name | varchar |'
- en: '| salary | int |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| salary | int |'
- en: '| department_id | int |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| department_id | int |'
- en: 'You see, the name columns are varchar data type, while salary is an integer.
    It could be important to know there are no decimals in the salary values. If you
    use the preview option you have available here, you’ll see this data is unique:
    every employee has only one salary value allocated to them. Also, an important
    thing to know; it could also be historical data where you’ll have all the previous
    salaries over the years for every employee. There’s a column department_id, which
    is a foreign key that links this table with the table db_dept:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，名字列是varchar数据类型，而薪水是整数。了解薪水值中没有小数可能很重要。如果你使用这里提供的预览选项，你会发现这些数据是唯一的：每个员工只有一个分配的薪水值。还有一个重要的点是：这可能也是历史数据，其中包含每个员工多年来的所有以前薪水。还有一个名为department_id的列，它是一个外键，将此表与db_dept表连接起来：
- en: '| id | int |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| id | int |'
- en: '| department | varchar |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| department | varchar |'
- en: Only two columns in this table. It’s only a list of departments, no duplicates,
    with six departments shown in the table.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表中只有两列。它只是一个部门列表，没有重复，表中显示了六个部门。
- en: 'Good, you’ve analyzed the data. Now, go back to the question and read the second
    sentence. Yes, this is instruction on what your solution needs to be. You don’t
    need to show the highest salary from one department in one column, then the highest
    salary from the other in the second column, and then the difference between them
    in the third column. No, the output will be only the difference:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，你已经分析了数据。现在，回到问题上来，阅读第二句话。是的，这是关于你的解决方案需要是什么的指示。你不需要在一列中显示一个部门的最高薪水，在另一列中显示另一个部门的最高薪水，然后在第三列中显示它们之间的差异。不，输出将只是差异：
- en: '![How to Answer Data Science Coding Interview Questions](../Images/930f96cd839fa64ee74f66d0becfe8e8.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![如何回答数据科学编程面试问题](../Images/930f96cd839fa64ee74f66d0becfe8e8.png)'
- en: There was no instruction on what this output column should be named. So it won’t
    be a mistake whatever you name it or if you don’t name it at all. The important
    thing is you get this result and nothing else.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有关于这个输出列应该命名为什么的指示。因此，不管你如何命名它或是否根本不命名它，都不会是错误的。重要的是你得到这个结果，仅此而已。
- en: 'With that, you have the foundations to write a quality code. Now is the time
    to time about the strategy: how will you write a code?'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你就有了编写高质量代码的基础。现在是时候考虑策略了：你将如何编写代码？
- en: 2\. Approach to Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 解决方案的方法
- en: Before you start writing a code, it’s also important that you have a clear idea
    of what your code will look like. Coding should only be translating your (clear!)
    idea of the solution to the programming language.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，明确你的代码将是什么样子也很重要。编码应只是将你的（清晰的！）解决方案思路转化为编程语言。
- en: 'When you think about how you should approach your solution (or write a code),
    consider the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑如何解决问题（或编写代码）时，请考虑以下几点：
- en: '![How to Answer Data Science Coding Interview Questions](../Images/34092b6dcbefcc6c0b5ea1d8318712c1.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![如何回答数据科学编程面试问题](../Images/34092b6dcbefcc6c0b5ea1d8318712c1.png)'
- en: Are there several ways to write a code?
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有几种方式来编写代码？
- en: State your assumptions
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 陈述你的假设
- en: Break down your solution into steps
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的解决方案分解为步骤
- en: Start coding
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始编码
- en: '**i. Are There Several Ways to Write a Code?**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**i. 有没有几种方式来编写代码？**'
- en: When thinking about the solution, what first comes to mind is sometimes the
    best solution. And sometimes it is not. How could you know? Once you get the first
    idea, the trick is to think about whether there’s some other way of solving the
    problem. In [programming languages](https://www.stratascratch.com/blog/top-5-data-science-programming-languages/),
    more times than not, there are several possible solutions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑解决方案时，首先想到的有时是最佳方案，但有时不是。你怎么知道呢？一旦得到第一个想法，诀窍是考虑是否还有其他方法来解决问题。在[编程语言](https://www.stratascratch.com/blog/top-5-data-science-programming-languages/)中，往往有几种可能的解决方案。
- en: Have this in mind. There are several reasons this is important. First, there
    could be some simple trick or function that easily solves something you think
    of solving with a lengthy code—for example, using [window functions](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-window-functions/) or
    CTEs instead of writing a code with endless subqueries.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这一点。有几个原因说明这点很重要。首先，可能存在一些简单的技巧或函数，可以轻松解决你认为需要用冗长代码解决的内容——例如，使用[窗口函数](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-window-functions/)或CTE，而不是编写包含无尽子查询的代码。
- en: Always go with what’s easier to write, with as few lines of code as possible.
    When you’re at the interview, you also have to manage time at your disposal. This
    is one of the ways.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总是选择更容易编写的解决方案，尽可能少的代码行。当你在面试时，你还需要管理你可用的时间。这是其中的一种方法。
- en: Of course, if there are several more or less equally complex solutions, think
    about how the code will perform. On large amounts of data, different codes can
    take up much more time and memory to perform than others.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果有几个或多或少同样复杂的解决方案，考虑代码的执行效果。在大量数据上，不同的代码可能会比其他代码花费更多的时间和内存。
- en: In short, you should think about code efficiency in two ways. One is personal
    efficiency, or how fast you can write a code. The second one is the code efficiency
    or how fast the code will perform what you want.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你应该从两个方面考虑代码效率。一是个人效率，即你写代码的速度。第二个是代码效率，即代码执行你所需功能的速度。
- en: '**ii. State Your Assumptions**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**ii. 陈述你的假设**'
- en: Stating your assumptions is important for several reasons. The first one is
    to say out loud and write them, which will help you see potential problems with
    your approach.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 陈述你的假设很重要，原因有几个。第一个原因是大声说出来并写下来，这将帮助你发现你方法中的潜在问题。
- en: The second important reason is it invites your interviewer to communicate with
    you and even offer some help, which they usually do. If they don’t know what you
    want to do and why, they can’t help you. As we already mentioned, there are usually
    several solutions that return the same result. Communicating your assumptions
    allows the interviewer to steer you in the right direction based on the approach
    you chose. Or even steer you from the completely wrong assumptions that will mess
    up your solution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要原因是它邀请你的面试官与你沟通，甚至提供一些帮助，他们通常会这样做。如果他们不知道你想做什么以及为什么，他们就无法帮助你。正如我们已经提到的，通常有几种返回相同结果的解决方案。沟通你的假设使面试官能够根据你选择的方法将你引导到正确的方向。或者甚至将你从完全错误的假设中引导出来，以免搞砸你的解决方案。
- en: The third reason is, sometimes the question could be intentionally set up to
    be vague. These questions are not that concerned with the right solution but with
    how you think. So if you state your assumptions, it will show the interviewer
    how you think, which they’re usually very interested in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个原因是，有时候问题可能故意设计得模糊。这些问题并不太关心正确的解决方案，而是关心你的思维方式。因此，如果你陈述了你的假设，这将向面试官展示你的思维方式，他们通常对此非常感兴趣。
- en: 'The fourth and final reason for stating your assumptions is even if you get
    the answer completely wrong but correct within the assumptions you stated, the
    chances are you’ll still get some points for that. The thinking, in this case,
    goes around these lines: OK, maybe the candidate completely misunderstood what
    was asked, but the solution is actually correct within the context of what they
    understood.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 陈述假设的第四个也是最终的原因是，即使你得到的答案完全错误，但在你所陈述的假设范围内是正确的，你仍然有可能得到一些分数。在这种情况下，思考方式是：好吧，也许候选人完全误解了要求，但在他们理解的背景下，解决方案实际上是正确的。
- en: This all leads to [making sure to give the right answer to an interview question](https://www.stratascratch.com/blog/how-to-guarantee-the-right-answers-to-data-science-interview-questions/).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这都涉及到[确保在面试问题中给出正确答案](https://www.stratascratch.com/blog/how-to-guarantee-the-right-answers-to-data-science-interview-questions/)。
- en: '**iii. Break Down Your Solution Into Steps**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**iii. 将你的解决方案分解为步骤**'
- en: This is also a helpful point that will make it easier for you to have a clear
    solution idea and, later on, write a clean code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个有用的点，它将使你更容易形成清晰的解决方案思路，并且在之后编写干净的代码。
- en: Breaking down, in this case, means writing down. Yes, write down all the key
    steps and functions of your solution. Think about whether you should join tables,
    how many tables, and which join you’ll use. Should you write a subquery or a CTE?
    Write down your choice. Think about what aggregate functions you’ll have to use,
    whether you’ll have to convert data types, should data be ordered in a specific
    way, should it be filtered and grouped, etc.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，分解意味着写下来。是的，写下你解决方案中的所有关键步骤和功能。考虑一下你是否需要连接表，多少个表，以及你将使用哪种连接。你需要编写子查询还是CTE？写下你的选择。考虑一下你需要使用哪些聚合函数，是否需要转换数据类型，数据是否需要按特定方式排序，是否需要过滤和分组，等等。
- en: All these are distinct steps, so write them down, as well as the main keywords
    you’ll use in every step.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是不同的步骤，所以把它们写下来，以及你将在每一步中使用的主要关键词。
- en: '**iv. Start Coding**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**iv. 开始编码**'
- en: This one’s an emergency point, in a way. If you did think about your approach
    to the solution, but you simply can’t see the complete solution before your eyes,
    then you should simply start writing a code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上是一个紧急点。如果你已经考虑了你的解决方案方法，但还是看不到完整的解决方案，那你应该开始编写代码。
- en: The thinking behind this is even if you give an incomplete solution, it’s for
    sure worth more than not writing a single line of code. Also, some questions could
    be really difficult, and it’s hard even for the most experienced to see the whole
    solution immediately. Start coding, and there’s a chance you’ll come up with an
    idea along the way. And if not, again, you at least have something to show for.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的思路是，即使你提供了一个不完整的解决方案，它也肯定比什么都不写要更有价值。此外，一些问题可能非常困难，即使是经验最丰富的人也难以立即看到完整的解决方案。开始编码，你可能会在过程中想到一个点子。如果没有，你至少还有东西可以展示。
- en: 'One additional reason you should have in mind: some questions are not even
    intended to be answered. Some of them are simply (and intentionally!) too hard
    to solve in the time you’re given at the interview. Nobody solves them completely.
    The partial solution is the best anyone will get. So you will be marked on how
    far you got compared to the other incomplete solutions.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个额外的理由你需要记住：有些问题甚至没有意图得到答案。它们中的一些问题故意（且有意！）在面试时间内过于困难。没有人能完全解决它们。部分解决方案是任何人能获得的最好结果。所以，你将根据你比其他不完整解决方案的进展程度来评分。
- en: '**Approach to Solution – Example**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案方法 – 示例**'
- en: 'Now that you know how you should think about your solution approach let’s use
    one interview question to demonstrate how it works in practice. We’ll use the
    Amazon coding interview question:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道了如何思考解决方案的方法，让我们用一个面试问题来演示它在实践中的应用。我们将使用亚马逊编程面试问题：
- en: '![How to Answer Data Science Coding Interview Questions](../Images/8cebe258304256e02eec6acffd57c21e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何回答数据科学编程面试问题](../Images/8cebe258304256e02eec6acffd57c21e.png)'
- en: '*“Find the total cost of each customer''s orders. Output customer''s id, first
    name, and the total order cost. Order records by customer''s first name alphabetically.”*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*“找到每位客户订单的总成本。输出客户的 ID、名字和总订单成本。按客户名字的字母顺序排列订单记录。”*'
- en: Link to the question: [https://platform.stratascratch.com/coding/10183-total-cost-of-orders](https://platform.stratascratch.com/coding/10183-total-cost-of-orders?python=)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接：[https://platform.stratascratch.com/coding/10183-total-cost-of-orders](https://platform.stratascratch.com/coding/10183-total-cost-of-orders?python=)
- en: We’ll have to use data from two tables, table customers, and table orders with
    this question. We can write a code with subqueries to overcome this problem. However,
    you probably know that if the query and subquery are using data from multiple
    tables, then the solution could also be written using the JOIN. Having in mind
    the advice of writing as few lines of code as possible, it’s better to use JOIN.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用来自两个表的数据，即表 customers 和表 orders。我们可以通过子查询编写代码来解决这个问题。然而，你可能知道，如果查询和子查询使用来自多个表的数据，那么也可以使用
    JOIN 来编写解决方案。考虑到尽可能少写代码的建议，使用 JOIN 更为合适。
- en: What are the assumptions to this solution? One assumption could be that there
    may be customers who have zero orders. This means there could be customers in
    the table customers that will not show up in the table orders. The second assumption
    is that we will not show the customers with zero orders since the question did
    not explicitly say it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的假设是什么？一个假设可能是存在没有订单的客户。这意味着在表 customers 中可能存在不出现在表 orders 中的客户。第二个假设是我们不会展示没有订单的客户，因为问题中没有明确提到这一点。
- en: 'Now, this already leads us to a solution breakdown. We have to output two already
    existing columns, so we’ll for sure use SELECT. We need to find the total of each
    customer’s orders. We’ll have to sum it using the SUM() aggregate function. OK,
    tables have to be joined. We’ll do that using the JOIN keyword. Why not some other
    join? Because our assumption says, we want only customers that have at least one
    order. Using JOIN will give us exactly that: it will join two tables and find
    only values (customers) that are in both tables. What next? I’ve used the aggregate
    function, so I’ll have to use the GROUP BY. And the result has to be ordered alphabetically,
    so I’ll use ORDER BY and ASC.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这已经引导我们到解决方案分解。我们必须输出两个已经存在的列，因此我们肯定会使用 SELECT。我们需要找到每个客户订单的总数。我们将使用 SUM()
    聚合函数来求和。好的，表格必须连接。我们将使用 JOIN 关键字来完成。为什么不是其他连接？因为我们的假设是，我们只希望有至少一个订单的客户。使用 JOIN
    将正好满足这一点：它将连接两个表格，并找到两个表格中都有的值（客户）。接下来呢？我已经使用了聚合函数，因此我必须使用 GROUP BY。结果必须按字母顺序排序，所以我将使用
    ORDER BY 和 ASC。
- en: 'The resulting solution breakdown could then look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的解决方案分解可能看起来像这样：
- en: SELECT
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELECT
- en: SUM (total_order_cost)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUM (total_order_cost)
- en: JOIN
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JOIN
- en: GROUP BY
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GROUP BY
- en: ORDER BY ASC
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORDER BY ASC
- en: In your case, this is not an emergency since you understood everything, so you
    can move on to the next checklist section. Or you can also find the most common [SQL
    JOIN interview questions here](https://www.stratascratch.com/blog/sql-join-interview-questions/).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，这不是紧急情况，因为你已经理解了所有内容，所以你可以继续下一个检查列表部分。或者你也可以在这里找到最常见的[SQL JOIN 面试问题](https://www.stratascratch.com/blog/sql-join-interview-questions/)。
- en: 3\. Writing a Code
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. 编写代码
- en: After assessing the question and laying out the strategy for your code, it’s
    time that you start writing it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估问题并制定代码策略后，是时候开始编写代码了。
- en: '![How to Answer Data Science Coding Interview Questions](../Images/12dfd09887b60da859c773cd0161e131.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![如何回答数据科学编码面试问题](../Images/12dfd09887b60da859c773cd0161e131.png)'
- en: Stick to a chosen dialect
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 坚持选择的方言
- en: Go line by line when coding
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码时逐行进行
- en: Talk as you code
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一边编码一边讲解
- en: Make it readable
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其可读
- en: Be consistent with the chosen conventions
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择的约定中保持一致
- en: '**i. Stick to a Chosen Dialect**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**i. 坚持选择的方言**'
- en: This is especially important if you’re in the SQL coding interview. As you already
    know, there’s an ANSI/ISO SQL standard, and there are many SQL dialects. Virtually
    every RDBMS uses its own SQL dialect. Of course, you can’t know all of them. And
    the company you’re interviewing for is probably using one of those dialects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 SQL 编码面试中，这一点尤其重要。如你所知，存在 ANSI/ISO SQL 标准，并且有许多 SQL 方言。几乎每个 RDBMS 都使用自己的
    SQL 方言。当然，你不能知道所有的方言。你面试的公司可能正在使用这些方言中的一种。
- en: If the interviewer doesn’t care which dialect you use, choose the one you’re
    most comfortable with. Don’t try to appeal to the interviewer by choosing the
    SQL dialect they use if you’re not very strong with coding in that dialect. It’s
    better to choose the dialect you know best and solve the problem than using some
    other dialect you don’t feel so sure about. If you choose the latter one, chances
    are you’ll be more nervous than necessary. Also, not being that familiar with
    the particular SQL dialect could make you mess up the solution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果面试官不在乎你使用哪个方言，选择你最熟悉的方言。如果你对某个方言不太擅长，不要试图通过选择面试官使用的 SQL 方言来吸引面试官。选择你最熟悉的方言解决问题要比使用你不太确定的其他方言更好。如果你选择后者，你可能会比必要时更紧张。此外，对特定
    SQL 方言不太熟悉可能会让你搞砸解决方案。
- en: Once you choose the SQL dialect, stick to it. For example, if you choose to
    write in PostgreSQL, don’t mix it up with T-SQL.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了 SQL 方言，就要坚持使用。例如，如果你选择使用 PostgreSQL，不要与 T-SQL 混用。
- en: '**ii. Go Line by Line**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**ii. 逐行进行**'
- en: Having a clear solution breakdown will help you check this point almost unnoticed.
    As you have the functions and sections of your code already outlined, you just
    need to remain calm and write a code systematically following the solution outline.
    Code is nothing more than a programming language version of your thoughts. If
    your thoughts and your solution outline are clear, your code will be too.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有明确的解决方案分解将帮助你几乎不被察觉地检查这一点。由于你已经概述了代码的功能和部分，你只需要保持冷静，系统地按照解决方案大纲编写代码。代码不过是你思想的编程语言版本。如果你的思想和解决方案大纲清晰，你的代码也会如此。
- en: If you start jumping from one line to another, you’ll get yourself and the interviewer
    confused. Which will probably lead to not writing the correct code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始在一行和另一行之间跳跃，你会让自己和面试官感到困惑。这可能会导致你写出错误的代码。
- en: '**iii. Talk as You Code**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**iii. 编码时讨论**'
- en: As you write your code line by line, you should also talk about what you’re
    doing. This is important because when saying out loud what you’re doing, it’s
    easier for you to see if you’re doing something wrong. Everything could sound
    great in your head. But when you voice it out, the not-so-great ideas really stick
    out! This gives you the opportunity to correct the code as you go along. Otherwise,
    you could finish your code, not even realizing you did something wrong.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你逐行编写代码时，你也应该谈论你在做什么。这很重要，因为当你大声说出你在做什么时，你更容易发现自己是否做错了什么。脑中一切听起来都很棒，但当你说出来时，不太好的想法会特别突出！这使你能够在编写代码时进行修正。否则，你可能会完成代码，却没有意识到自己做错了什么。
- en: One of the reasons why it’s important to explain every line as you write it
    is it again invites the interviewer to participate in your solution. It makes
    it possible for them to understand what you’re doing and give you some hints.
    If you just write a code and keep to yourself what you’re doing, the interviewer
    will also probably shut down and simply wait for you to finish the code to let
    you know how you did.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 解释每一行的原因之一是，它再次邀请面试官参与你的解决方案。这样面试官就能理解你在做什么，并给你一些提示。如果你只是编写代码，并对自己所做的事情保持沉默，面试官也可能会关闭交流，只等你完成代码后再告诉你做得如何。
- en: '**iv. Make it Readable**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**iv. 使其可读**'
- en: Having a well-structured code is a joy to see simply from the aesthetic point
    of view. Not only that, but it makes it easier for you and for the interviewer
    to read your code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从美学角度来看，结构良好的代码令人赏心悦目。不仅如此，这也使你和面试官更容易阅读你的代码。
- en: 'The main thing that makes your code readable is mentioned in one of the points
    above: write it as simple as possible. However, some solutions can’t be simple.
    And even a few lines of code could be a nightmare to read if you don’t make an
    effort to make it readable.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的代码可读的主要因素在上面的一点中提到：尽可能简单地编写代码。然而，有些解决方案不能简单。即使是几行代码，如果你不付出努力使其易读，也可能变成一场噩梦。
- en: One of the tips to keep in mind is to use space, tab, and enter. And use it
    a lot! These keys are there to separate your code into sections, making it easier
    to understand what the code does. Think of it like anything you say or write.
    Space, tab, and enter will make your code have commas, sentences, and paragraphs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住的一个小贴士是使用空格、制表符和回车键，并且要多使用这些键！这些键是用来将你的代码分成若干部分，使代码更易于理解。想象一下，就像你说或写的任何东西一样。空格、制表符和回车键将使你的代码有逗号、句子和段落。
- en: If possible, use aliases for tables. But try to make them self-explanatory.
    Avoid using single-letter aliases, but also don’t make aliases too verbose and
    descriptive. The same goes for the variable names.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，使用表的别名。但尽量使别名具有自解释性。避免使用单字母别名，但也不要使别名过于冗长和描述性。变量名也是如此。
- en: While SQL is not case sensitive, it’s always better to write the SQL keywords
    in the upper case. This will also make them stick out in the code, especially
    if all the column and table names are written lowercase.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQL 不区分大小写，但最好还是使用大写书写 SQL 关键字。这样会使它们在代码中更为突出，尤其是当所有列和表名都用小写字母时。
- en: 'Check out our post "[*Best Practices to Write SQL Queries: How To Structure
    Your Code*](https://www.stratascratch.com/blog/best-practices-to-write-sql-queries-how-to-structure-your-code/)"
    which focuses on how your SQL queries can be improved, in particular when it comes
    to performance and readability.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的文章 "[*最佳实践：如何编写 SQL 查询并构建你的代码*](https://www.stratascratch.com/blog/best-practices-to-write-sql-queries-how-to-structure-your-code/)"，重点讨论了如何改进你的
    SQL 查询，特别是在性能和可读性方面。
- en: '**v. Be Consistent With the Chosen Conventions**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**v. 遵循一致的约定**'
- en: There are no rules that make you write in upper or lower case; there’s no prescribed
    naming convention, so it’s up to you and how you like it. But whatever you do,
    be consistent with it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 没有规则要求你必须使用大写或小写字母；没有规定的命名约定，所以这完全取决于你以及你喜欢的方式。但无论你做什么，都要保持一致。
- en: If you want to write all the new column names in lower case and separate words
    with underscores, please do so and keep it that way. Naming a column salary_per_employee
    looks rather good. But try to avoid naming one column salary_per_employee, the
    other one SalaryPerDepartment, the third one ‘Total Salary’, and the fourth one
    MAX_sALAryPerdeparment. You’ll hurt yourself when trying to read the code, especially
    with the last one.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将所有新列名写成小写字母，并用下划线分隔单词，请这样做并保持这种方式。命名为 salary_per_employee 看起来相当好。但尽量避免将一个列命名为
    salary_per_employee，另一个命名为 SalaryPerDepartment，第三个命名为 ‘Total Salary’，第四个命名为 MAX_sALAryPerdeparment。在阅读代码时，你会感到困扰，尤其是最后一个。
- en: The same goes when writing table names, using aliases, etc. Keeping consistency
    will also add to your code readability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，编写表名、使用别名等时也是如此。保持一致性也会提高代码的可读性。
- en: Speaking of consistency, we’ll show you how this checklist section works in
    practice.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 说到一致性，我们将向你展示这一检查清单部分在实际中的运作方式。
- en: '**Writing a Code – Example**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写代码 – 示例**'
- en: 'Here’s a coding question by Facebook:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Facebook 提出的编码问题：
- en: '![How to Answer Data Science Coding Interview Questions](../Images/0193d4b8b1d3a1c4c406ef9dadaf93f0.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![如何回答数据科学编码面试问题](../Images/0193d4b8b1d3a1c4c406ef9dadaf93f0.png)'
- en: “Facebook sends SMS texts when users attempt to 2FA (2-factor authenticate)
    into the platform to log in. In order to successfully 2FA they must confirm they
    received the SMS text message. Confirmation texts are only valid on the date they
    were sent. Unfortunately, there was an ETL problem with the database where friend
    requests and invalid confirmation records were inserted into the logs, which are
    stored in the 'fb_sms_sends' table. These message types should not be in the table.
    Fortunately, the 'fb_confirmers' table contains valid confirmation records so
    you can use this table to identify SMS text messages that were confirmed by the
    user.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: “Facebook 在用户尝试通过 2FA（双因素认证）登录平台时，会发送 SMS 短信。为了成功完成 2FA，他们必须确认收到 SMS 短信消息。确认短信仅在发送日期有效。不幸的是，数据库中存在
    ETL 问题，导致好友请求和无效的确认记录被插入到日志中，这些日志存储在 'fb_sms_sends' 表中。这些消息类型不应该出现在表中。幸运的是，'fb_confirmers'
    表包含有效的确认记录，因此你可以使用这个表来识别用户确认的 SMS 短信消息。
- en: Calculate the percentage of confirmed SMS texts for August 4, 2020.”
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 2020 年 8 月 4 日确认的 SMS 短信的百分比。”
- en: Link to the question: [https://platform.stratascratch.com/coding/10291-sms-confirmations-from-users](https://platform.stratascratch.com/coding/10291-sms-confirmations-from-users?python=)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '问题链接: [https://platform.stratascratch.com/coding/10291-sms-confirmations-from-users](https://platform.stratascratch.com/coding/10291-sms-confirmations-from_users?python=)'
- en: 'If you write a code like this, it will cover everything that we mentioned in
    this checklist section:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写出这样的代码，它将覆盖我们在此检查清单部分提到的所有内容：
- en: '[PRE0]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s imagine Facebook uses SQL Server, but it leaves it up to you which SQL
    dialect you’ll write your code in. You’re not familiar with T-SQL, so you decide
    to write in PostgreSQL.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Facebook 使用 SQL Server，但你可以选择使用哪种 SQL 方言编写你的代码。你对 T-SQL 不熟悉，因此决定使用 PostgreSQL。
- en: For example, EXTRACT() and double colon (::) are functions typical for PostgreSQL.
    The first one extracts the part of the date from the datetime data type. It doesn’t
    exist in T-SQL! So if you said to the interviewer you’re writing in T-SQL and
    then use this function, you’d be making a mistake. In T-SQL, you should use the
    DATEPART() function. And you should know that this function in PostgreSQL is called
    DATE_PART(). One underscore could mean a difference between your code working
    and not working.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，EXTRACT() 和双冒号 (::) 是 PostgreSQL 中典型的函数。第一个函数从 datetime 数据类型中提取日期部分。T-SQL
    中不存在这个函数！所以如果你告诉面试官你在写 T-SQL 然后使用这个函数，你会犯错。在 T-SQL 中，你应该使用 DATEPART() 函数。你还应该知道，在
    PostgreSQL 中，这个函数叫做 DATE_PART()。一个下划线的差别可能会影响你的代码是否正常工作。
- en: Similarly, double colon (::) in PostgreSQL is used for data type conversion.
    In T-SQL it doesn’t work; you’ll have to use either CAST() or CONVERT().
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，PostgreSQL 中的双冒号 (::) 用于数据类型转换。在 T-SQL 中它不起作用；你需要使用 CAST() 或 CONVERT()。
- en: Having a solution breakdown for this code will make it easy for you to write
    it line by line. It’s easy, actually. First, you have to select some data from
    a table, filter it, group it, and finally order it. Don’t first write the WHERE
    clause, then go to SELECT statement, then to data type converting or any other
    bizarre way of approaching your code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对这段代码进行解决方案分解会使你逐行编写代码变得容易。实际上这很简单。首先，你需要从表格中选择一些数据，筛选它，分组，最后排序。不要先写WHERE子句，然后去编写SELECT语句，再去进行数据类型转换或其他任何奇怪的编程方式。
- en: 'As you code, you could talk to the interviewer like this: I’m selecting the
    column cust_id using the SUM() function to calculate the revenue from table orders.
    Then I’m using the WHERE clause to filter data based on the month and year from
    the column order_date. After that, I’m grouping data on customer level and ordering
    the result in a descending order.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，你可以这样跟面试官沟通：我正在使用SUM()函数从表格orders中计算列cust_id的收入。然后，我使用WHERE子句根据列order_date中的月份和年份筛选数据。之后，我在客户级别上对数据进行分组，并按降序排列结果。
- en: 'You see that there is indentation to this code, there is a new line for every
    key part of the code, and naming conventions are consistent. Do you want to see
    how the code could look like if we didn’t follow this? Here it is:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这段代码有缩进，每个关键部分都有新行，并且命名约定一致。如果我们没有遵循这些，你想看看代码会是什么样的吗？请看这里：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Good luck with reading it!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你阅读顺利！
- en: 4\. Reviewing Your Code
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4\. 审查你的代码
- en: After you’ve written the code, it’s time you review it before it becomes your
    final answer. If you’ve followed all the items on a checklist so far, it’ll be
    easy for you to review it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码后，是时候在它成为最终答案之前进行审查。如果你已经遵循了检查清单上的所有项目，那么审查代码将会很容易。
- en: 'Reviewing your code is, in a way, checking it against some points on your checklist:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 审查你的代码，从某种程度上来说，就是将其与检查清单上的一些点进行对比：
- en: Check how much time you have left
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你剩余的时间
- en: Check it against the required output
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对照所需输出检查代码
- en: Check it against the stated assumptions
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对照声明的假设检查
- en: Check its readability
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查代码的可读性
- en: Lead the interviewer through the solution
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导面试官了解解决方案
- en: Optimize your code
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化你的代码
- en: '**i. Check How Much Time You Have Left**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**i. 检查你剩余的时间**'
- en: All other points in this part of the checklist depend on this one. If you have
    no time left, then you can’t do anything. You did what you did, and your code
    is the answer you’ve got, like it or not.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分清单中的所有其他点都依赖于这一点。如果你没有剩余时间，那么你就无法做任何事情。你已经做了你能做的，你的代码就是你得到的答案，无论你喜不喜欢。
- en: Time management is important, so you should intentionally leave some time for
    reviewing a code. Ideally, you’ll have time to perform the three following checks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 时间管理很重要，所以你应该有意留出一些时间来审查代码。理想情况下，你应该有时间进行以下三项检查。
- en: '**ii. Check the Code Against the Required Output**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**ii. 对照所需输出检查代码**'
- en: You should go back to your question and see if your code really returns what
    is required. Did you forget to include some required columns? Did you really order
    the result like it’s requested? Those and other similar questions are you should
    ask yourself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该回到你的问题中，看看你的代码是否真的返回了所需的结果。你是否忘记包括一些必需的列？你是否真的按要求对结果进行了排序？这些以及其他类似的问题是你应该问自己的。
- en: If you have time, correct the mistakes you made. If there’s no time, leave the
    code as it is, but write down what you did wrong.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有时间，纠正你犯的错误。如果没有时间，就保持代码原样，但写下你做错了什么。
- en: '**iii. Check the Code Against the Stated Assumptions**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**iii. 对照声明的假设检查代码**'
- en: You wrote your code based on some assumptions. Go back to your assumptions list
    and check if you followed them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你是根据一些假设编写了代码。回到你的假设列表中，检查你是否遵循了它们。
- en: It would be perfect if you did. But when writing more complex code, it’s possible
    that you discarded some assumptions or introduced new ones. Write that down, too.
    If you didn’t follow all the assumptions, but you think you should have and you
    have time to change the code, do it. If not, leave it as it is.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做到了，那将是完美的。但在编写更复杂的代码时，你可能会丢弃一些假设或引入新的假设。也请将这些写下来。如果你没有遵循所有假设，但认为你应该遵循并且有时间修改代码，那就去做。如果没有时间，就保持原样。
- en: '**iv. Check the Code Readability**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**iv. 检查代码的可读性**'
- en: Here you should check whether you understand what you just wrote. Go back to
    your code, check once again every line for its syntax and logic. As you go line
    by line, assess whether the code readability could be improved. Were you consistent
    in naming conventions? Are your aliases clear to understand? Is there any ambiguity?
    Is the code structured in a logical way and into logical parts?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应该检查你是否理解你刚刚写的内容。回到你的代码，再次检查每一行的语法和逻辑。逐行检查时，评估代码的可读性是否可以提高。你在命名约定中是否保持一致？你的别名是否清晰易懂？是否存在任何歧义？代码是否以逻辑方式和逻辑部分进行结构化？
- en: Again, if you have time, improve the code readability. If there’s no time, try
    writing down or simply remembering what you could’ve done better.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有时间的话，再提高一下代码的可读性。如果没有时间，尽量写下或记住你本可以做得更好的地方。
- en: '**v. Lead the Interviewer Through the Solution**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**v. 带领面试官通过解决方案**'
- en: If you did all the steps above, this one should just come naturally to you.
    The most important thing is that you’re honest when you explain your code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了上述所有步骤，那么这一点应该自然会出现。最重要的是，当你解释你的代码时要诚实。
- en: Whatever mistakes you found in your code when reviewing it, state them explicitly.
    Don’t count on your interviewer not noticing them. Don’t try to hide them. Own
    your mistakes and show that you know what you did wrong. Everybody makes mistakes,
    but not everybody can realize they made them and admit to them. It shows you know
    what you’re doing even though you made a mistake. Speaking of mistakes, [here
    are the most common ones people make in data science interviews](https://www.stratascratch.com/blog/most-common-coding-mistakes-on-data-science-interviews/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你在回顾代码时发现了什么错误，都要明确指出。不要指望面试官没有注意到它们。不要试图掩盖它们。承认你的错误，展示你知道自己做错了什么。每个人都会犯错误，但不是每个人都能意识到自己犯了错误并承认它们。这表明你即使犯了错，也知道自己在做什么。说到错误，[这里是数据科学面试中人们常犯的一些错误](https://www.stratascratch.com/blog/most-common-coding-mistakes-on-data-science-interviews/)。
- en: 'If you included an unnecessary column in your output, say so and continue explaining
    the output you have. You strayed away from your initial assumptions or included
    new ones? Say so and explain why. If you did it by mistake, say it wasn’t intentional,
    but you see that your solution should include some additional assumptions. State
    what they should be for your code to work. The same goes with readability: if
    you see you could make your code better, explain how.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在输出中包含了不必要的列，请说明并继续解释你所拥有的输出。你偏离了最初的假设或加入了新的假设？请说明并解释原因。如果是因为错误，说明这不是故意的，但你看到你的解决方案应该包含一些额外的假设。说明这些假设是什么，以便你的代码能够正常工作。可读性也是如此：如果你看到可以改进你的代码，请解释如何改进。
- en: By doing all this, you’ll not only show your coding ability but also how fast
    you think, that you’re accountable and honest. These are all very highly regarded
    characteristics by all companies.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过做这些，你不仅能展示你的编码能力，还能表现出你的思维速度、责任心和诚实。这些都是所有公司非常看重的特质。
- en: '**vi. Optimize Your Code**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**vi. 优化你的代码**'
- en: The last question in the coding interview is usually the one that asks you to
    optimize your code. That way, the interviewer will test your SQL theory knowledge.
    For example, if you know that JOINs can be computationally time-consuming? You’ll
    be asked to find out if there’s a way to eliminate JOIN or a subquery. For example,
    you can usually remove a subquery in the WHERE clause with some function, such
    as ranking function, if trying to find the maximum value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编码面试中的最后一个问题通常是要求你优化你的代码。通过这种方式，面试官会测试你的 SQL 理论知识。例如，你知道 JOIN 操作可能会消耗大量计算时间吗？你会被要求找出是否有办法消除
    JOIN 或子查询。例如，你通常可以使用一些函数，比如排名函数，来去除 WHERE 子句中的子查询，以找到最大值。
- en: Or if you know how fast operations are performed on certain data types. For
    example, string comparison is slow than integer comparison, so maybe there’s a
    way to do it on string data?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你知道某些数据类型上的操作速度如何。例如，字符串比较比整数比较要慢，所以也许有办法在字符串数据上进行操作吗？
- en: Conclusion
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: 'All this sums up to this: writing a code should almost be a technicality if
    you structure your approach well. The accent is more on thinking and less on coding.
    And writing a code should be done in a very organized way.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说：如果你很好地构建你的方法，编写代码几乎应该是一种技术性操作。重点在于思考而非编码。编写代码应该以非常有组织的方式进行。
- en: You should think through the question, the data you have in front of you, the
    possible solution(s), your assumptions, and the functions you’ll need. Only after
    that, you should start coding. Once you start coding, you should be able to include
    the interviewer in what you’re doing and let them know every step you make. Like
    in real life, you’ll have to check and optimize your code before you start using
    it in production. This interview is your production; manage your time so that
    you can review your solution.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑问题、手头的数据、可能的解决方案、你的假设以及你需要的函数。只有在这些都考虑清楚后，你才应该开始编写代码。一旦开始编码，你应该能够让面试官了解你的操作，并告知他们你每一步的进展。像在现实生活中一样，你需要检查和优化你的代码，然后再开始在生产环境中使用它。这次面试就是你的生产环境；合理管理你的时间，以便能够复查你的解决方案。
- en: These are the things you should do. There are also more preparation tips in
    our post: [5 Tips to Prepare for a Data Science Interview](https://www.stratascratch.com/blog/5-tips-to-prepare-for-a-data-science-interview/).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你应该做的事情。我们帖子中还有更多准备技巧：[5个准备数据科学面试的技巧](https://www.stratascratch.com/blog/5-tips-to-prepare-for-a-data-science-interview/)。
- en: All this is not easy. It requires experience and practice; nobody can fake this.
    But following this checklist will for sure add a solid structure to your thinking
    and interview performance, no matter your experience. It can only make you perform
    better.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不容易。这需要经验和实践；没有人能假装这一点。但按照这个检查清单，必定会为你的思维和面试表现增添坚实的结构，无论你的经验如何。它只能让你表现得更好。
- en: '**[Nate Rosidi](https://www.stratascratch.com)** is a data scientist and in
    product strategy. He''s also an adjunct professor teaching analytics, and is the
    founder of [StrataScratch](https://www.stratascratch.com/), a platform helping
    data scientists prepare for their interviews with real interview questions from
    top companies. Connect with him on [Twitter: StrataScratch](https://twitter.com/StrataScratch)
    or [LinkedIn](https://www.linkedin.com/in/nathanrosidi/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**[内特·罗西迪](https://www.stratascratch.com)**是一位数据科学家和产品策略专家。他还是一名兼职教授，教授分析学，并且是[StrataScratch](https://www.stratascratch.com/)的创始人，这个平台帮助数据科学家通过来自顶级公司的真实面试问题来准备面试。在[Twitter:
    StrataScratch](https://twitter.com/StrataScratch)或[LinkedIn](https://www.linkedin.com/in/nathanrosidi/)上与他联系。'
- en: '[Original](https://www.stratascratch.com/blog/how-to-answer-data-science-coding-interview-questions/).
    Reposted with permission.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[原文](https://www.stratascratch.com/blog/how-to-answer-data-science-coding-interview-questions/)。经许可转载。'
- en: More On This Topic
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多相关话题
- en: '[Top 10 Advanced Data Science SQL Interview Questions You Must Know…](https://www.kdnuggets.com/2023/01/top-10-advanced-data-science-sql-interview-questions-must-know-answer.html)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[你必须知道的前10大高级数据科学SQL面试问题…](https://www.kdnuggets.com/2023/01/top-10-advanced-data-science-sql-interview-questions-must-know-answer.html)'
- en: '[KDnuggets News, May 4: 9 Free Harvard Courses to Learn Data…](https://www.kdnuggets.com/2022/n18.html)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[KDnuggets新闻，5月4日：9门免费的哈佛课程来学习数据…](https://www.kdnuggets.com/2022/n18.html)'
- en: '[15 Python Coding Interview Questions You Must Know For Data Science](https://www.kdnuggets.com/2022/04/15-python-coding-interview-questions-must-know-data-science.html)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学必知的15个Python编程面试问题](https://www.kdnuggets.com/2022/04/15-python-coding-interview-questions-must-know-data-science.html)'
- en: '[3 Hard Python Coding Interview Questions For Data Science](https://www.kdnuggets.com/2023/03/3-hard-python-coding-interview-questions-data-science.html)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3个数据科学领域的困难Python编程面试问题](https://www.kdnuggets.com/2023/03/3-hard-python-coding-interview-questions-data-science.html)'
- en: '[Google Answer to ChatGPT by Adding Generative AI into Docs and Gmail](https://www.kdnuggets.com/2023/03/google-answer-chatgpt-adding-generative-ai-docs-gmail.html)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[谷歌通过将生成式AI加入Docs和Gmail来回应ChatGPT](https://www.kdnuggets.com/2023/03/google-answer-chatgpt-adding-generative-ai-docs-gmail.html)'
- en: '[12 Most Challenging Data Science Interview Questions](https://www.kdnuggets.com/2022/07/12-challenging-data-science-interview-questions.html)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12个最具挑战性的数据科学面试问题](https://www.kdnuggets.com/2022/07/12-challenging-data-science-interview-questions.html)'
