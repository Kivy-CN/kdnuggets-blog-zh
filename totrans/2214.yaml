- en: 'Customer Segmentation in Python: A Practical Approach'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://www.kdnuggets.com/customer-segmentation-in-python-a-practical-approach](https://www.kdnuggets.com/customer-segmentation-in-python-a-practical-approach)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/030e6da7950544c232cbe08351c32b44.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author | Created Using Excalidraw and Flaticon
  prefs: []
  type: TYPE_NORMAL
- en: Customer segmentation can help businesses tailor their marketing efforts and
    improve customer satisfaction. Here‚Äôs how.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Functionally, customer segmentation involves dividing a customer base into distinct
    *groups* or *segments*‚Äîbased on shared characteristics and behaviors. By understanding
    the needs and preferences of each segment, businesses can deliver more personalized
    and effective marketing campaigns, leading to increased customer retention and
    revenue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this tutorial, we‚Äôll explore customer segmentation in Python by combining
    two fundamental techniques: **RFM (Recency, Frequency, Monetary) analysis** and
    **K-Means clustering**. RFM analysis provides a structured framework for evaluating
    customer behavior, while K-means clustering offers a data-driven approach to group
    customers into meaningful segments. We‚Äôll work with a real-world dataset from
    the retail industry: the [Online Retail dataset](https://archive.ics.uci.edu/dataset/352/online+retail)
    from UCI machine learning repository.'
  prefs: []
  type: TYPE_NORMAL
- en: From data preprocessing to cluster analysis and visualization, we‚Äôll code our
    way through each step. So let‚Äôs dive in!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Approach: RFM Analysis and K-Means Clustering'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let‚Äôs start by stating our goal: By applying RFM analysis and K-means clustering
    to this dataset, we‚Äôd like to gain insights into customer behavior and preferences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'RFM Analysis is a simple yet powerful method to quantify customer behavior.
    It evaluates customers based on three key dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recency (R)**: How recently did a particular customer make a purchase?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency (F)**: How often do they make purchases?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monetary Value (M)**: How much money do they spend?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We‚Äôll use the information in the dataset to compute the recency, frequency,
    and monetary values. Then, we‚Äôll map these values to the generally used RFM score
    scale of 1 - 5.
  prefs: []
  type: TYPE_NORMAL
- en: If you‚Äôd like, you can explore and analyze further using these RFM scores. But
    we‚Äôll try to identify customer segments with similar RFM characteristics. And
    for this, we‚Äôll use K-Means clustering, an unsupervised machine learning algorithm
    that groups similar data points into clusters.
  prefs: []
  type: TYPE_NORMAL
- en: So let‚Äôs start coding!
  prefs: []
  type: TYPE_NORMAL
- en: üîó [Link to Google Colab notebook](https://github.com/balapriyac/python-data-analysis/blob/main/customer-segmentation/Customer_Segmentation_in_Python.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 ‚Äì Import Necessary Libraries and Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let‚Äôs import the necessary libraries and the specific modules as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We need pandas and matplotlib for data exploration and visualization, and the
    `KMeans` class from scikit-learn‚Äôs cluster module to perform K-Means clustering.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 ‚Äì Load the Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, we‚Äôll use the Online Retail dataset. The dataset contains customer
    records: transactional information, including purchase dates, quantities, prices,
    and customer IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's read in the data that‚Äôs originally in an excel file from its URL into
    a pandas dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can [download the dataset](https://archive.ics.uci.edu/static/public/352/online+retail.zip)
    and read the excel file into a pandas dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 ‚Äì Explore and Clean the Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let‚Äôs start exploring the dataset. Look at the first few rows of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/1b012739c46d0bb3bbea881b94a68792.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of data.head()
  prefs: []
  type: TYPE_NORMAL
- en: 'Now call the `describe()` method on the dataframe to understand the numerical
    features better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the ‚ÄúCustomerID‚Äù column is currently a floating point value. When
    we clean the data, we‚Äôll cast it into an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/066ce9e79f212f2a620fbd8fab6eca9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of data.describe()
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that the dataset is quite noisy. The ‚ÄúQuantity‚Äù and ‚ÄúUnitPrice‚Äù columns
    contain negative values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/2aa4d515986463219abe340683da9984.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of data.describe()
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs take a closer look at the columns and their data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the dataset has over 541K records and the ‚ÄúDescription‚Äù and ‚ÄúCustomerID‚Äù
    columns contain missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/88f36c7be0119b5c6475eff9bdb604c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let‚Äôs get the count of missing values in each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the ‚ÄúCustomerID‚Äù and ‚ÄúDescription‚Äù columns contain missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/019048ec21eefa3ceb37371015a29fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For our analysis, we don‚Äôt need the product description contained in the ‚ÄúDescription‚Äù
    column. However, we need the ‚ÄúCustomerID‚Äù for the next steps in our analysis.
    So let‚Äôs drop the records with missing ‚ÄúCustomerID‚Äù:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also recall that the values ‚ÄúQuantity‚Äù and ‚ÄúUnitPrice‚Äù columns should be strictly
    non-negative. But they contain negative values. So let''s also drop the records
    with negative values for¬† ‚ÄúQuantity‚Äù and ‚ÄúUnitPrice‚Äù:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs also convert the ‚ÄúCustomerID‚Äù to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/7b849734cdca050b7c6349d8b347ec8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 ‚Äì Compute Recency, Frequency, and Monetary Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let‚Äôs start out by defining a reference date `snapshot_date` that‚Äôs a day later
    than the most recent date in the ‚ÄúInvoiceDate‚Äù column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a ‚ÄúTotal‚Äù column that contains Quantity*UnitPrice for all the
    records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the Recency, Frequency, and MonetaryValue, we calculate the following‚Äî**grouped
    by CustomerID**:'
  prefs: []
  type: TYPE_NORMAL
- en: For **recency**, we‚Äôll calculate the difference between the most recent purchase
    date and a reference date (`snapshot_date`). This gives the **number of days since
    the customer's last purchase**. So *smaller values* indicate that a customer has
    made a purchase *more recently*. But when we talk about *recency scores*, we‚Äôd
    want customers who bought recently to have a higher recency score, yes? We‚Äôll
    handle this in the next step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because **frequency** measures how often a customer makes purchases, we‚Äôll calculate
    it as the total **number of unique invoices** or transactions made by each customer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monetary value** quantifies how much money a customer spends. So we‚Äôll find
    the average of the total monetary value across transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs rename the columns for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/c5671b7ae07d5464322b95df07ad4a79.png)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 ‚Äì Map RFM Values onto a 1-5 Scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let‚Äôs map the ‚ÄúRecency‚Äù, ‚ÄúFrequency‚Äù, and ‚ÄúMonetaryValue‚Äù columns to take
    on values in a scale of 1-5; one of {1,2,3,4,5}.
  prefs: []
  type: TYPE_NORMAL
- en: 'We‚Äôll essentially assign the values to five different bins, and map each bin
    to a value. To help us fix the bin edges, let‚Äôs use the quantile values of the
    ‚ÄúRecency‚Äù, ‚ÄúFrequency‚Äù, and ‚ÄúMonetaryValue‚Äù columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/dd35049e987fde3395ccd9fc46b9b14d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here‚Äôs how we define the custom bin edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we‚Äôve defined the bin edges, let‚Äôs map the scores to corresponding
    labels between 1 and 5 (both inclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the R_Score, based on the bins, is 1 for recent purchases 5 for
    all purchases made over 250 days ago. But we‚Äôd like the most recent purchases
    to have an R_Score of 5 and purchases made over 250 days ago to have an R_Score
    of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the desired mapping, we do: `5 - rfm[''R_Score''].astype(int) +
    1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs look at the first few rows of the R_Score, F_Score, and M_Score columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/2406fb57788000d4e6ee2e0f654d436b.png)'
  prefs: []
  type: TYPE_IMG
- en: If you‚Äôd like, you can use these R, F, and M scores to carry out an in-depth
    analysis. Or use clustering to identify segments with similar RFM characteristics.
    We‚Äôll choose the latter!
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 ‚Äì Perform K-Means Clustering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: K-Means clustering is sensitive to the scale of features. Because the R, F,
    and M values are all on the same scale, we can proceed to perform clustering without
    further scaling the features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs extract the R, F, and M scores to perform K-Means clustering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to find the *optimal* number of clusters. For this let‚Äôs run
    the K-Means algorithm for a range of K values and use the *elbow method* to pick
    the optimal K:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We see that the curve elbows out at 4 clusters. So let‚Äôs divide the customer
    base into four segments.
  prefs: []
  type: TYPE_NORMAL
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/445ef9cef78341fb88e185bec085b99d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We‚Äôve fixed K to 4\. So let‚Äôs run the K-Means algorithm to get the cluster
    assignments for all points in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Step 7 ‚Äì Interpret the Clusters to Identify Customer Segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the clusters, let‚Äôs try to characterize them based on the RFM
    scores.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The average R, F, and M scores for each cluster should already give you an idea
    of the characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/e3193fe4aa77709beb2a8180fde47753.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But let‚Äôs visualize the average R, F, and M scores for the clusters so it‚Äôs
    easy to interpret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/8a77b0dbf09aaee9eb8455243a06fe3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how the customers in each of the segments can be characterized based
    on the recency, frequency, and monetary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster 0**: Of all the four clusters, this cluster has the *highest* recency,
    frequency, and monetary values. Let‚Äôs call the customers in this cluster **champions
    (or power shoppers)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster 1**: This cluster is characterized by *moderate* recency, frequency,
    and monetary values. These customers still spend more and purchase more frequently
    than clusters 2 and 3\. Let‚Äôs call them **loyal customers**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster 2**: Customers in this cluster tend to spend less. They don‚Äôt buy
    often, and haven‚Äôt made a purchase recently either. These are likely *inactive*
    or **at-risk customers**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster 3**: This cluster is characterized by *high recency* and relatively
    lower frequency and moderate monetary values. So these are **recent customers**
    who can potentially become long-term customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of how you can tailor marketing efforts‚Äîto target customers
    in each segment‚Äîto enhance customer engagement and retention:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For Champions/Power Shoppers**: Offer personalized special discounts, early
    access, and other premium perks to make them feel valued and appreciated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For Loyal Customers**: Appreciation campaigns, referral bonuses, and rewards
    for loyalty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For At-Risk Customers**: Re-engagement efforts that include running discounts
    or promotions to encourage buying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For Recent Customers**: Targeted campaigns educating them about the brand
    and discounts on subsequent purchases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It‚Äôs also helpful to understand what percentage of customers are in the different
    segments. This will further help streamline marketing efforts and grow your business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs visualize the distribution of the different clusters using a pie chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Customer Segmentation in Python: A Practical Approach](../Images/32d5956b8e13aa7df201cf8802848137.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we go! For this example, we have quite an even distribution of customers
    across segments. So we can invest time and effort in retaining existing customers,
    re-engaging with at-risk customers, and educating recent customers.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And that‚Äôs a wrap! We went from over *154K customer records to 4 clusters in
    7 easy steps*. I hope you understand how customer segmentation allows you to make
    data-driven decisions that influence business growth and customer satisfaction
    by allowing for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Personalization**: Segmentation allows businesses to tailor their marketing
    messages, product recommendations, and promotions to each customer group''s specific
    needs and interests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved Targeting**: By identifying *high-value* and *at-risk* customers,
    businesses can allocate resources more efficiently, focusing efforts where they
    are most likely to yield results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer Retention**: Segmentation helps businesses create retention strategies
    by understanding what keeps customers engaged and satisfied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a next step, try applying this approach to another dataset, document your
    journey, and share with the community! But remember, effective customer segmentation
    and running targeted campaigns requires a good understanding of your customer
    base‚Äîand how the customer base evolves. So it requires periodic analysis to refine
    your strategies over time.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset Credits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [Online Retail Dataset](https://archive.ics.uci.edu/dataset/352/online+retail)
    is licensed under a [Creative Commons Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/legalcode)
    (CC BY 4.0) license:'
  prefs: []
  type: TYPE_NORMAL
- en: Online Retail. (2015). UCI Machine Learning Repository. https://doi.org/10.24432/C5BW33.
  prefs: []
  type: TYPE_NORMAL
- en: '**[](https://twitter.com/balawc27)**[Bala Priya C](https://www.kdnuggets.com/wp-content/uploads/bala-priya-author-image-update-230821.jpg)****
    is a developer and technical writer from India. She likes working at the intersection
    of math, programming, data science, and content creation. Her areas of interest
    and expertise include DevOps, data science, and natural language processing. She
    enjoys reading, writing, coding, and coffee! Currently, she''s working on learning
    and sharing her knowledge with the developer community by authoring tutorials,
    how-to guides, opinion pieces, and more. Bala also creates engaging resource overviews
    and coding tutorials.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[A Practical Approach To Feature Engineering In Machine Learning](https://www.kdnuggets.com/2023/07/practical-approach-feature-engineering-machine-learning.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Free eBook: 10 Practical Python Programming Tricks](https://www.kdnuggets.com/2023/04/free-ebook-10-practical-python-programming-tricks.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Guide On How To Become A Data Scientist (Step By Step Approach)](https://www.kdnuggets.com/2021/05/guide-become-data-scientist.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Support Vector Machines: An Intuitive Approach](https://www.kdnuggets.com/2022/08/support-vector-machines-intuitive-approach.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Data Science Project of Rotten Tomatoes Movie Rating Prediction:‚Ä¶](https://www.kdnuggets.com/2023/06/data-science-project-rotten-tomatoes-movie-rating-prediction-first-approach.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Data Science Project of Rotten Tomatoes Movie Rating Prediction:‚Ä¶](https://www.kdnuggets.com/2023/07/data-science-project-rotten-tomatoes-movie-rating-prediction-second-approach.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
