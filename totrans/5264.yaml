- en: 'How To Write Better SQL Queries: The Definitive Guide – Part 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2017/08/write-better-sql-queries-definitive-guide-part-1.html](https://www.kdnuggets.com/2017/08/write-better-sql-queries-definitive-guide-part-1.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**By Karlijn Willems, Data Science Journalist & [DataCamp](https://www.datacamp.com/)
    Contributor**.'
  prefs: []
  type: TYPE_NORMAL
- en: Structured Query Language (SQL) is an indispensable skill in the data science
    industry and generally speaking, learning this skill is fairly easy. However,
    most forget that SQL isn’t just about writing queries, which is just the first
    step down the road. Ensuring that queries are performant or that they fit the
    context that you’re working in is a whole other thing.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why this SQL tutorial will provide you with a small peek at some steps
    that you can go through to evaluate your query:'
  prefs: []
  type: TYPE_NORMAL
- en: First off, you’ll start with a short overview of the [importance of learning
    SQL](https://www.datacamp.com/community/tutorials/sql-tutorial-query#importance) for
    jobs in data science;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, you’ll first learn more about how [SQL query processing and execution](https://www.datacamp.com/community/tutorials/sql-tutorial-query#execution) so
    that you can properly understand the importance of writing qualitative queries:
    more specifically, you’ll see that the query is parsed, rewritten, optimized and
    finally evaluated;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that in mind, you’ll not only go over some [query anti-patterns](https://www.datacamp.com/community/tutorials/sql-tutorial-query#antipattern) that
    beginners make when writing queries, but you’ll also learn more about alternatives
    and solutions to those possible mistakes; You’ll also learn more about the [set-based
    versus the procedural approach](https://www.datacamp.com/community/tutorials/sql-tutorial-query#setbased) to
    querying.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also see that these anti-patterns stem from performance concerns and
    that, besides the “manual” approach to improving SQL queries, you can [analyze
    your queries](https://www.datacamp.com/community/tutorials/sql-tutorial-query#queryplan) also
    in a more structured, in-depth way by making use of some other tools that help
    you to see the query plan; And,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll briefly go more into [time complexity and the big O notation](https://www.datacamp.com/community/tutorials/sql-tutorial-query#bigo) to
    get an idea about the time complexity of an execution plan before you execute
    your query; Lastly,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll briefly get some pointers on how you can [tune your query](https://www.datacamp.com/community/tutorials/sql-tutorial-query#tune) further.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/3fec2cbe3c0764a970df9ee5b3657839.png)'
  prefs: []
  type: TYPE_IMG
- en: Are you interested in an SQL course? Take DataCamp’s [Intro to SQL for Data
    Science](https://www.datacamp.com/courses/intro-to-sql-for-data-science) course!
  prefs: []
  type: TYPE_NORMAL
- en: Why Should I Learn SQL For Data Science?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQL is far from dead: it’s one of the most in-demand skills that you find in
    job descriptions from the data science industry, whether you’re applying for a
    data analyst, a data engineer, a data scientist or [any other roles](https://www.datacamp.com/community/tutorials/data-science-industry-infographic).
    This is confirmed by 70% of the respondents of the 2016 O’Reilly Data Science
    Salary Survey, who indicate that they use SQL in their professional context. What’s
    more, in this survey, SQL stands out way above the R (57%) and Python (54%) programming
    languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You get the picture: SQL is a must-have skill when you’re working towards getting
    a job in the data science industry.'
  prefs: []
  type: TYPE_NORMAL
- en: Not bad for a language that was developed in the early 1970s, right?
  prefs: []
  type: TYPE_NORMAL
- en: But why exactly is it that it is so frequently used? And why isn’t it dead even
    though it has been around for such a long time?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reasons: one of the first reasons would be that companies
    mostly store data in Relational Database Management Systems (RDBMS) or in Relational
    Data Stream Management Systems (RDSMS) and you need SQL to access that data. SQL
    is the lingua franca of data: it gives you the ability to interact with almost
    any database or to even build your own locally!'
  prefs: []
  type: TYPE_NORMAL
- en: As if this wasn’t enough yet, keep in mind that there are quite a few SQL implementations
    that are incompatible between vendors and do not necessarily follow standards.
    Knowing the standard SQL is thus a requirement for you to find your way around
    in the (data science) industry.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, it’s safe to say that SQL has also been embraced by newer technologies,
    such as Hive, a SQL-like query language interface to query and manage large datasets,
    or Spark SQL, which you can use to execute SQL queries. Once again, the SQL that
    you find there will differ from the standard that you might have learned, but
    the learning curve will be considerably easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do want to make a comparison, consider it as learning linear algebra:
    by putting all that effort into this one subject, you know that you will be able
    to use it to master machine learning as well!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, this is why you should learn this query language:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s is fairly easy to learn, even for total newbies. The learning curve is
    quite easy and gradual, so you’ll be writing queries in no time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It follows the “learn once, use anywhere” principle, so it’s a great investment
    of your time!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s an excellent addition to programming languages; In some cases, writing
    a query is even preferred over writing code because it’s more performant!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are you still waiting for? :)
  prefs: []
  type: TYPE_NORMAL
- en: SQL Processing & Query Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To improve the performance of your SQL query, you first have to know what happens
    internally when you press the shortcut to run the query.
  prefs: []
  type: TYPE_NORMAL
- en: First, the query is parsed into a “parse tree”; The query is analyzed to see
    if it satisfies the syntactical and semantical requirements. The parser creates
    an internal representation of the input query. This output is then passed on to
    the rewrite engine.
  prefs: []
  type: TYPE_NORMAL
- en: It is then the task of the optimizer to find the optimal execution or query
    plan for the given query. The execution plan defines exactly what algorithm is
    used for each operation, and how the execution of the operations is coordinated.
  prefs: []
  type: TYPE_NORMAL
- en: To indeed find the most optimal execution plan, the optimizer enumerates all
    possible execution plans, determines the quality or cost of each plan, takes information
    about the current database state and then chooses the best one as the final execution
    plan. Because query optimizers can be imperfect, database users and administrators
    sometimes need to manually examine and tune the plans produced by the optimizer
    to get better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Now you probably wonder what is considered to be a “good query plan”.
  prefs: []
  type: TYPE_NORMAL
- en: As you already read, the quality of cost of a plan plays a huge role. More specifically,
    things such as the number of disk I/Os that are required to evaluate the plan,
    the plan’s CPU cost and the overall response time that can be observed by the
    database client and the total execution time are essential. That is where the
    notion of time complexity will come in. You’ll read more about this later on.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the chosen query plan is executed, evaluated by the system’s execution
    engine and the results of your query are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1d9ed9522e2baf1b62b9ec5d87a3dbf0.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing SQL Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What might not have become clear from the previous section is that the Garbage
    In, Garbage Out (GIGO) principle naturally surfaces within the query processing
    and execution: the one who formulates the query also holds the keys to the performance
    of your SQL queries. If the optimizer gets a badly formulated query, it will only
    be able to do as much…'
  prefs: []
  type: TYPE_NORMAL
- en: 'That means that there are some things that *you* can do when you’re writing
    a query. As you already saw in the introduction, the responsibility is two-fold:
    it’s not only about writing queries that live up to a certain standard, but also
    about gathering an idea of where performance problems might be lurking within
    your query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An ideal starting point is to think of “spots” within your queries where issues
    might sneak in. And, in general, there are four clauses and keywords where newbies
    can expect performance issues to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The `WHERE` clause;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any `INNER JOIN` or `LEFT JOIN` keywords; And,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HAVING` clause;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granted, this approach is simple and naive, but as a beginner, these clauses
    and statements are nice pointers and it’s safe to say that when you’re just starting
    out, these spots are the ones where mistakes happen and, ironically enough, where
    they’re also hard to spot.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you should also realize that performance is something that needs a
    context to become meaningful: simply saying that these clauses and keywords are
    bad isn’t the way to go when you’re thinking about SQL performance. Having a `WHERE` or `HAVING` clause
    in your query doesn’t necessarily mean that it’s a bad query…'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the following section to learn more about anti-patterns and alternative
    approaches to building up your query. These tips and tricks are meant as a guide.
    How and if you actually need to rewrite your query depends on the amount of data,
    the database and the number of times you need to execute the query, among other
    things. It entirely depends on the goal of your query and having some prior knowledge
    about the database that you want to query is crucial!
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Only Retrieve The Data You Need
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mindset of “the more data, the better” isn’t one that you should necessarily
    live by when you’re writing SQL queries: not only do you risk obscuring your insights
    by getting more than what you actually need, but also your performance might suffer
    from the fact that your query pulls up too much data.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s why it’s generally a good idea to look out for the `SELECT` statement,
    the `DISTINCT` clause and the `LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '**The `SELECT` Statement**'
  prefs: []
  type: TYPE_NORMAL
- en: A first thing that you can already check when you have written your query is
    whether the `SELECT` statement is as compact as possible. Your aim here should
    be to remove unncessary columns from `SELECT`. This way you force yourself to
    only pull up data that serves your query goal.
  prefs: []
  type: TYPE_NORMAL
- en: In case you have correlated subqueries that have `EXISTS`, you should try to
    use a constant in the `SELECT` statement of that subquery instead of selecting
    the value of an actual column. This is especially handy when you’re checking the
    existence only.
  prefs: []
  type: TYPE_NORMAL
- en: '**Remember** that a correlated subquery is a subquery that uses values from
    the outer query. And note that, even though `NULL` can work in this context as
    a “constant”, it’s very confusing!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example to understand what is meant by using a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Tip**: it’s handy to know that having a correlated subquery isn’t always
    a good idea. You can always consider getting rid of them by, for example, rewriting
    them with an `INNER JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**The `DISTINCT` Clause**'
  prefs: []
  type: TYPE_NORMAL
- en: The `SELECT DISTINCT` statement is used to return only distinct (different)
    values. `DISTINCT` is a clause that you should definitely try to avoid if you
    can; Like you have read in other examples, the execution time only increases if
    you add this clause to your query. It’s therefore always a good idea to consider
    whether you really need this `DISTINCT` operation to take place to get the results
    that you want to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: '**The `LIKE` Operator**'
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `LIKE` operator in a query, the index isn’t used if the pattern
    starts with `%` or `_`. It will prevent the database from using an index (if it
    exists). Of course, from another point of view, you could also argue that this
    type of query potentially leaves the door open to retrieve too many records that
    don’t necessarily satisfy your query goal.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, your knowledge of the data that is stored in the database can help
    you to formulate a pattern that will filter correctly through all the data to
    find only the rows that really matter for your query.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Limit Your Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you can not avoid filtering down on your `SELECT` statement, you can consider
    limiting your results in other ways. Here’s where approaches such as the `LIMIT` clause
    and data type conversions come in.
  prefs: []
  type: TYPE_NORMAL
- en: '**`TOP`, `LIMIT` And `ROWNUM` Clauses**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the `LIMIT` or `TOP` clauses to your queries to set a maximum number
    of rows for the result set. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Note** that you can further specify the `PERCENT`, for example, if you change
    the first line of the query by `SELECT TOP 50 PERCENT *`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you can also add the `ROWNUM` clause, which is equivalent to
    using `LIMIT` in your query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Data Type Conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should always use the most efficient, that is, smallest, data types possible.
    There’s always a risk when you provide a huge data type when a smaller one will
    be more sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you add data type conversion to your query, you only increase
    the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is just to avoid data type conversion as much as possible. Note
    also here that it’s not always possible to remove or omit the data type conversion
    from your queries, but that you should definitely aim to be careful in including
    them and that when you do, you test the effect of the addition before you run
    the query.
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[The Definitive Guide To Switching Your Career Into Data Science](https://www.kdnuggets.com/2022/05/definitive-guide-switching-career-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python Function Arguments: A Definitive Guide](https://www.kdnuggets.com/2023/02/python-function-arguments-definitive-guide.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Definitive Guide to Solving the Phantom Read in MySQL](https://www.kdnuggets.com/2022/06/definitive-guide-solving-phantom-read-mysql.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Step by Step Guide to Reading and Understanding SQL Queries](https://www.kdnuggets.com/a-step-by-step-guide-to-reading-and-understanding-sql-queries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Write SQL in Native Python](https://www.kdnuggets.com/2022/02/easy-sql-native-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News, December 7: Top 10 Data Science Myths Busted • 4…](https://www.kdnuggets.com/2022/n47.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
