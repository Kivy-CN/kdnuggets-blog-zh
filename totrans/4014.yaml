- en: 'Getting Started with PyTest: Effortlessly Write and Run Tests in Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/getting-started-with-pytest-effortlessly-write-and-run-tests-in-python](https://www.kdnuggets.com/getting-started-with-pytest-effortlessly-write-and-run-tests-in-python)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Getting Started with PyTest](../Images/e14abc30eccb9a742052e136c5e1a866.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever encountered software that didn't work as expected? Maybe you clicked
    a button, and nothing happened, or a feature you were excited about turned out
    to be buggy or incomplete. These issues can be frustrating for users and can even
    lead to financial losses for businesses.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: To address these challenges, developers follow a programming approach called
    **test-driven development**. TDD is all about minimizing software failures and
    ensuring that the software meets the intended requirements. These test cases describe
    the expected behavior of the code. By writing these tests upfront, developers
    get a clear understanding of what they want to achieve. Test pipelines are an
    essential part of the software development process for any organization. Whenever
    we make changes to our codebase, we need to ensure that they don't introduce new
    bugs. This is where test pipelines come in to help us.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about PyTest. PyTest is a Python package that simplifies the
    process of writing and running test cases. This full-featured testing tool has
    matured to become the de facto standard for many organizations, as it easily scales
    for complex codebases and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of the PyTest Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Improved Logging and Test Reports**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon the execution of tests, we receive a complete log of all executed tests
    and the status of each test case. In the event of failure, a complete stack trace
    is provided for each failure, along with the exact values that caused an assert
    statement to fail. This is extremely beneficial for debugging and makes it easier
    to trace the exact issue in our code to solve the bugs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Automatic Discovery of Test Cases**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not have to manually configure any test case to be executed. All files
    are recursively scanned, and all function names prefixed with "test" are executed
    automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Fixtures and Parametrization**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During test cases, specific requirements may not always be accessible. For example,
    it is inefficient to fetch a resource from the network for testing, and internet
    access may not be available when running a test case. In such scenarios, if we
    want to execute a test that makes internet requests, we will need to add stubs
    that create a dummy response for that specific part. Moreover, it may be necessary
    to execute a function multiple times with different arguments to cover all possible
    edge cases. PyTest makes it simple to implement this using fixtures and parametrization
    decorators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PyTest is available as a PyPI package that can be easily installed using the
    Python package manager. To set up PyTest, it is good to start with a fresh environment.
    To create a new Python virtual environment, use the below commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up the PyTest module, you can install the official PyPI package using
    pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running your First Test Case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s dive into writing and running your very first test case in Python using
    PyTest. We'll start from scratch and build a simple test to get a feel for how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a Python Project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start writing tests, it's essential to organize our project properly.
    This helps keep things tidy and manageable, especially as our projects grow. We'll
    follow a common practice of separating our application code from our test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we''ll structure our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our root directory *pytest_demo* contains separate src and tests directories.
    Our application code resides in src, while our test code lives in tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Simple Program and Its Associated Test Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s create a basic sorting program using the bubble sort algorithm.
    We''ll place this in src/sorting.py:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We've implemented a basic Bubble Sort algorithm, a simple yet effective way
    to sort elements in a list by repeatedly swapping adjacent elements if they are
    in the wrong order.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's ensure our implementation works by writing comprehensive test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In our test file, we've written three different test cases. Note how each function
    name starts with the *test* prefix, which is a rule PyTest follows to recognize
    test functions.
  prefs: []
  type: TYPE_NORMAL
- en: We import the bubble sort implementation from the source code in the test file.
    This can now be used in our test cases. Each test must have an *"assert"* statement
    to check if it works as expected. We give the sorting function a list that's not
    in order and compare its output with what we expect. If they match, the test passes;
    otherwise, it fails.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, We've also included two simple tests, one that always passes and
    another that always fails. These are just placeholder functions that are useful
    for checking if our testing setup is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Executing Tests and Understanding the Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now run our tests from the command line. Navigate to your project root
    directory and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will recursively search all files in the tests directory. All functions
    and classes that start with the test prefix will be automatically recognized as
    a test case. From our tests directory, it will search in the test_sorting.py file
    and run all three test functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the tests, you’ll see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When running the PyTest command line utility, it displays the platform metadata
    and the total test cases that will be run. In our example, three test cases were
    added from the test_sorting.py file. Test cases are executed sequentially. A dot
    (".") represents that the test case passed whereas an “F” represents a failed
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: If a test case fails, PyTest provides a traceback, which shows the specific
    line of code and the arguments that caused the error. Once all the test cases
    have been executed, PyTest presents a final report. This report includes the total
    execution time and the number of test cases that passed and failed. This summary
    gives you a clear overview of the test results.
  prefs: []
  type: TYPE_NORMAL
- en: Function Parametrization for Multiple Test Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we test only one scenario for the sorting algorithm. Is that
    sufficient? Obviously not! We need to test the function with multiple examples
    and edge cases to ensure there are no bugs in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyTest makes this process easy for us. We use the parametrization decorator
    provided by PyTest to add multiple test cases for a single function. The code
    appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the updated code, we have modified the test_sorting function using the *pytest.mark.parametrize*
    decorator. This decorator allows us to pass multiple sets of input values to the
    test function. The decorator expects two parameters: a string representing the
    comma-separated names of the function parameters, and a list of tuples where each
    tuple contains the input values for a specific test case.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the function parameters have the same names as the string passed to
    the decorator. This is a strict requirement to ensure the correct mapping of input
    values. If the names don't match, an error will be raised during test case collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this implementation, the test_sorting function will be executed four times,
    once for each set of input values specified in the decorator. Now, let''s take
    a look at the output of the test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this run, a total of six test cases were executed, including four from the
    test_sorting function and two dummy functions. As expected, only the dummy test
    case failed.
  prefs: []
  type: TYPE_NORMAL
- en: We can now confidently say that our sorting implementation is correct :)
  prefs: []
  type: TYPE_NORMAL
- en: Fun Practice Task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this article, we have introduced the PyTest module and demonstrated its
    usage by testing a bubble sort implementation with multiple test cases. We covered
    the basic functionality of writing and executing test cases using the command
    line utility. This should be enough to get you started with implementing testing
    for your own code bases. To make your understanding of PyTest better, here''s
    a fun practice task for you:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a function called **validate_password** that takes a password as
    input and checks if it meets the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Contains at least 8 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains at least one uppercase letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains at least one lowercase letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains at least one digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contains at least one special character (e.g., !, @, #, $, %)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write PyTest test cases to validate the correctness of your implementation,
    covering various edge cases. Good Luck!
  prefs: []
  type: TYPE_NORMAL
- en: '**[](https://www.linkedin.com/in/kanwal-mehreen1/)**[Kanwal Mehreen](https://www.linkedin.com/in/kanwal-mehreen1/)****
    Kanwal is a machine learning engineer and a technical writer with a profound passion
    for data science and the intersection of AI with medicine. She co-authored the
    ebook "Maximizing Productivity with ChatGPT". As a Google Generation Scholar 2022
    for APAC, she champions diversity and academic excellence. She''s also recognized
    as a Teradata Diversity in Tech Scholar, Mitacs Globalink Research Scholar, and
    Harvard WeCode Scholar. Kanwal is an ardent advocate for change, having founded
    FEMCodes to empower women in STEM fields.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[How to Make Python Code Run Incredibly Fast](https://www.kdnuggets.com/2021/06/make-python-code-run-incredibly-fast.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Schedule & Run ETLs with Jupysql and GitHub Actions](https://www.kdnuggets.com/2023/05/schedule-run-etls-jupysql-github-actions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distribute and Run LLMs with llamafile in 5 Simple Steps](https://www.kdnuggets.com/distribute-and-run-llms-with-llamafile-in-5-simple-steps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Learn How to Run Alpaca-LoRA on Your Device in Just a Few Steps](https://www.kdnuggets.com/2023/05/learn-run-alpacalora-device-steps.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Run an LLM Locally with LM Studio](https://www.kdnuggets.com/run-an-llm-locally-with-lm-studio)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Started with Python Generators](https://www.kdnuggets.com/2023/02/getting-started-python-generators.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
