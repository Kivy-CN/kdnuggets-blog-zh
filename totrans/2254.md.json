["```py\ndf_critics = pd.read_csv('rotten_tomatoes_critic_reviews_50k.csv')\ndf_critics.head()\n```", "```py\ndf_merged = df_critics.merge(df_movie, how='inner', on=['rotten_tomatoes_link'])\ndf_merged = df_merged[['rotten_tomatoes_link', 'movie_title', 'review_content', 'review_type', 'tomatometer_status']]\ndf_merged.head()\n```", "```py\ndf_merged = df_merged.dropna(subset=['review_content'])\n```", "```py\n# Plot distribution of the review\nax = df_merged.review_type.value_counts().plot(kind='bar', figsize=(12,9))\nax.bar_label(ax.containers[0])\n```", "```py\ndf_merged = df_merged.dropna(subset=['review_content'])\n# Plot distribution of the review\nax = df_merged.review_type.value_counts().plot(kind='bar', figsize=(12,9))\nax.bar_label(ax.containers[0])\n```", "```py\ndf_sub = df_merged[0:5000]\n```", "```py\nreview_type = pd.DataFrame(df_sub.review_type.replace(['Rotten','Fresh'],[0,1]))\n```", "```py\ndf_feature_critics = pd.concat([df_sub[['review_content']]\n                        ,review_type], axis=1).dropna()\ndf_feature_critics.head()\n```", "```py\n# Pick only 5000 entries from the original dataset\ndf_sub = df_merged[0:5000]\n\n# Encode the label\nreview_type = pd.DataFrame(df_sub.review_type.replace(['Rotten','Fresh'],[0,1]))\n\n# Build final DataFrame\ndf_feature_critics = pd.concat([df_sub[['review_content']]\n                        ,review_type], axis=1).dropna()\ndf_feature_critics.head()\n```", "```py\nX_train, X_test, y_train, y_test = train_test_split( df_feature_critics['review_content'], df_feature_critics['review_type'], test_size=0.2, random_state=42)\n```", "```py\n# Instantiate vectorizer class\nvectorizer = CountVectorizer(min_df=1)\n```", "```py\n# Transform our text data into vector\nX_train_vec = vectorizer.fit_transform(X_train).toarray()\n```", "```py\n# Initialize random forest and train it\nrf = RandomForestClassifier(random_state=2)\nrf.fit(X_train_vec, y_train) \n```", "```py\n# Predict and output classification report\ny_predicted = rf.predict(vectorizer.transform(X_test).toarray())\n\nprint(classification_report(y_test, y_predicted))\n```", "```py\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf, vectorizer.transform(X_test).toarray(), y_test, cmap ='cividis', ax=ax\n```", "```py\n# Instantiate vectorizer class\nvectorizer = CountVectorizer(min_df=1)\n\n# Transform our text data into vector\nX_train_vec = vectorizer.fit_transform(X_train).toarray()\n\n# Initialize random forest and train it\nrf = RandomForestClassifier(random_state=2)\nrf.fit(X_train_vec, y_train)\n\n# Predict and output classification report\ny_predicted = rf.predict(vectorizer.transform(X_test).toarray())\n\nprint(classification_report(y_test, y_predicted))\n\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf, vectorizer.transform(X_test).toarray(), y_test, cmap ='cividis', ax=ax\n```", "```py\nclass_weight = compute_class_weight(class_weight= 'balanced', classes= np.unique(df_feature_critics.review_type), \n                      y = df_feature_critics.review_type.values)\n\nclass_weight_dict = dict(zip(range(len(class_weight.tolist())), class_weight.tolist()))\nclass_weight_dict\n```", "```py\nvectorizer = CountVectorizer(min_df=1)\nX_train_vec = vectorizer.fit_transform(X_train).toarray()\n```", "```py\n# Initialize random forest and train it\nrf_weighted = RandomForestClassifier(random_state=2, class_weight=class_weight_dict)\nrf_weighted.fit(X_train_vec, y_train)\n```", "```py\n# Predict and output classification report\ny_predicted = rf_weighted.predict(vectorizer.transform(X_test).toarray())\n\nprint(classification_report(y_test, y_predicted))\n```", "```py\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf_weighted, vectorizer.transform(X_test).toarray(), y_test, cmap ='cividis', ax=ax)\n```", "```py\n# Instantiate vectorizer class\nvectorizer = CountVectorizer(min_df=1)\n\n# Transform our text data into vector\nX_train_vec = vectorizer.fit_transform(X_train).toarray()\n\n# Initialize random forest and train it\nrf_weighted = RandomForestClassifier(random_state=2, class_weight=class_weight_dict)\nrf_weighted.fit(X_train_vec, y_train)\n\n# Predict and output classification report\ny_predicted = rf_weighted.predict(vectorizer.transform(X_test).toarray())\n\nprint(classification_report(y_test, y_predicted))\n\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf_weighted, vectorizer.transform(X_test).toarray(), y_test, cmap ='cividis', ax=ax)\n```", "```py\ndef predict_movie_status(prediction):\n    \"\"\"Assign label (Fresh/Rotten) based on prediction\"\"\"\n    positive_percentage = (prediction == 1).sum()/len(prediction)*100\n\n    prediction = 'Fresh' if positive_percentage >= 60 else 'Rotten'\n\n    print(f'Positive review:{positive_percentage:.2f}%')\n    print(f'Movie status: {prediction}')\n```", "```py\n# Gather all of the reviews of Body of Lies movie\ndf_bol = df_merged.loc[df_merged['movie_title'] == 'Body of Lies']\n\ndf_bol.head()\n```", "```py\ny_predicted_bol = rf_weighted.predict(vectorizer.transform(df_bol['review_content']).toarray())\npredict_movie_status(y_predicted_bol)\n```", "```py\ndf_merged['tomatometer_status'].loc[df_merged['movie_title'] == 'Body of Lies'].unique()\n```", "```py\ndf_ah = df_merged.loc[df_merged['movie_title'] == 'Angel Heart']\ndf_ah.head()\n```", "```py\ny_predicted_ah = rf_weighted.predict(vectorizer.transform(df_ah['review_content']).toarray())\npredict_movie_status(y_predicted_ah)\n```", "```py\ndf_merged['tomatometer_status'].loc[df_merged['movie_title'] == 'Angel Heart'].unique()\n```", "```py\ndf_duchess = df_merged.loc[df_merged['movie_title'] == 'The Duchess']\ndf_duchess.head()\n```", "```py\ny_predicted_duchess = rf_weighted.predict(vectorizer.transform(df_duchess['review_content']).toarray())\npredict_movie_status(y_predicted_duchess)\n```", "```py\ndf_merged['tomatometer_status'].loc[df_merged['movie_title'] == 'The Duchess'].unique()\n```"]