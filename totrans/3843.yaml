- en: 5 Advanced Tips on Python Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2021/11/5-advanced-tips-python-sequences.html](https://www.kdnuggets.com/2021/11/5-advanced-tips-python-sequences.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[comments](#comments)'
  prefs: []
  type: TYPE_NORMAL
- en: '**By [Michael Berk](https://www.linkedin.com/in/michael-berk-48783a146/), Data
    Scientist at Tubi**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a192e1567eb76d4791fcee7218864b73.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [NASA](https://unsplash.com/@nasa?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: “66% of data scientists are applying Python daily.” — [src](https://www.dasca.org/world-of-big-data/article/top-6-programming-languages-for-data-science-in-2021)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you’re in that 66%, this post is for you.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to cover the major takeaways from chapter 2 of [Fluent Python by
    Luciano Ramalho](https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008),
    which covers **sequences** e.g. lists, tuples, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 1 — Lists vs. Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tip: lists should hold the same kind of information whereas tuples can hold
    different kinds of information.**'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the basics, let’s discuss the main difference between lists and
    tuples. Below we can see an example of each — lists are surrounded by square brackets `[]` and
    tuples are surrounded by parentheses `()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the backend, **lists are mutable but tuples are not**. Immutable variables
    often require less memory so try to use tuples when possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a deeper note covered in Fluent Python.
  prefs: []
  type: TYPE_NORMAL
- en: Semantically, it’s best practice to store different *kinds* of data in a tuple
    and the same *kinds* in a list. Note that both tuples and lists support multiple
    python datatypes in the same variable, but we’re talking about the type of variable
    conceptually.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a tuple could be used to store the following information: `(latitude,
    longitude, city_name)`. Not only are these different data types `(float, float,
    str)` , but they’re also different conceptually. Lists, on the other hand, should
    only store latitude, longitude, city name, or a tuple of all three.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To improve the organization of your python code, you should always keep information
    of the same kind in a list. **Tuples are for structure, lists are for sequence.**
  prefs: []
  type: TYPE_NORMAL
- en: 2 — Unpacking Iterables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tip: use **`*****`** and **`**_**`** to improve your unpacking.**'
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking is a very smooth and readable way to access values inside of an iterable.
    They’re quite common in loops, list comprehensions, and function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking is done by assigning a sequence-like datatype to comma separated variable
    names, for example…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, Fluent Python goes into some fancy unpacking methods. One example is
    you can use `*` to unpack “the rest” of the items in a long iterable. **Using
    the asterisk notation is common when you have some items of interest, and other
    items that are less important.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `*` operator can occur in the middle of a set of variables
    and python will assign all unaccounted for values to that variable.
  prefs: []
  type: TYPE_NORMAL
- en: But, we can take the asterisk unpacking operator one step further. You can use `_` to
    unpack and** not save a value**. This convention comes in handy when you’re looking
    to unpack something but, unlike the above example, you don’t need all the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One use case for the underscore `_` unpacking operator is if you’re working
    with dictionaries or builtin methods that return multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, for the cherry on top, we can combine both methods to **unpack
    and not store “the rest” of the values.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 3 — Does the Function Return None?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tip: if a function returns **`**None**`**, it performs in-place operations.**'
  prefs: []
  type: TYPE_NORMAL
- en: Many python data types have two versions of the same function, such as `x.sort()` and `sorted(x)` shown
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the first example using `x.sort()`, we perform an in-place sort which is
    more efficient and requires less memory. But, in the second exampling using `sorted(x)`,
    we are able to retain the original order of the list.
  prefs: []
  type: TYPE_NORMAL
- en: In general, Python maintains this notation. [Dot operators](https://www.askpython.com/python/built-in-methods/dot-notation) like `x.sort()`often
    return `None` and perform in-place mutations. Functions that take the variable
    as a parameter like `sorted(x)` return a **copy **of the mutated variable, but
    leave the original variable unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 4 — GenExps vs. ListComps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tip: use generator expressions if you’re only accessing the variable once.
    If not, use a list comprehension.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[List comprehensions](https://www.w3schools.com/python/python_lists_comprehension.asp) (listcomps)
    and [generator expressions](https://www.python.org/dev/peps/pep-0289/) (genexps)
    are different ways to instantiate a sequence data type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As shown above, the only syntactical difference between list comps and genexps
    are the surrounding bracket type — parentheses `()`are used for genexps and square
    brackets `[]` are used for list comps.
  prefs: []
  type: TYPE_NORMAL
- en: '**List comps are instantiated, which means they are evaluated and saved in
    memory. Genexps are not. **Each time a genexp is needed by the program, it will
    perform the computation to evaluate that expression.'
  prefs: []
  type: TYPE_NORMAL
- en: So that’s why generator expressions are better if you’re only using the variable
    once — they are never actually stored in memory so they’re far more efficient.
    But, if you’re repeatedly accessing a sequence or need list-specific method, it’s
    better to store it in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Fun side note — you can also create dictionaries using the list comprehension
    syntax…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 5 — Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let’s conclude with a quick note on slicing. Unlike with unpacking,
    sometimes we want to access a value in an iterable using the index. Slicing allows
    us to do this by using the following format: `my_list[start:stop:step]`
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who know that `my_list[::-1]` reverses a list order but didn’t
    know why (such as myself), that’s why. By passing a `-1` as our step parameter,
    we step through the list in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: Now most python packages abide by the `[start:stop:index]`syntax. Numpy and
    pandas are some notable examples. Let’s take a look at each parameter in turn…
  prefs: []
  type: TYPE_NORMAL
- en: '`start`: starting index in your slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: not-inclusive ending index in your slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step`: the step size (and direction) within your `start` and `stop` index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, because each of these values are optional, we can do all sorts of cool slicing…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And there you have it! 5 major tips from chapter 2 of Fluent Python. Just one
    more section…
  prefs: []
  type: TYPE_NORMAL
- en: Useful Notes for Data Scientists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Disclaimer, I’m not super qualified to add my opinions to this piece. However,
    these notes should be pretty intuitive. Let me know if you disagree.
  prefs: []
  type: TYPE_NORMAL
- en: '**List comprehensions should almost always replace loops.** If the body of
    the loop is complex, you can create a function that does the operations. By combining
    user-defined functions with list comprehension syntax, you make readable and efficient
    code. And, if you need to iterate over more than one variable, use `[enumerate()](https://realpython.com/python-enumerate/)` or `[zip()](https://www.w3schools.com/python/ref_func_zip.asp)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Being “optimal” in python doesn’t matter. **If you’re writing production-level
    code, it may be different. But, realistically you won’t see major performance
    bumps when using a tuple over a list. Ensuring that your data manipulation steps
    are logical and efficient is 99% of the work. If the 1% matters, then you can
    start worrying about tuple vs. list. Moreover, if you are really in the business
    of efficient code, you’re probably not using python.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Finally, slicing is super cool. **I had always known that `x[::-1]` reverses
    a list, but never knew why until reading this chapter of Fluent Python. And it
    works for numpy and pandas!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Thanks for reading! I’ll be writing 35 more posts that bring academic research
    to the DS industry. Check out my comment for links to the main source for this
    post and some useful resources.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bio: [Michael Berk](https://www.linkedin.com/in/michael-berk-48783a146/)**
    (**[https://michaeldberk.com/](https://michaeldberk.com/)**) is a Data Scientist
    at Tubi.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](https://towardsdatascience.com/5-advanced-tips-on-python-sequences-5b0e09a21a83).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[How to Find Weaknesses in your Machine Learning Models](/2021/09/weaknesses-machine-learning-models.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Simple Text Scraping, Parsing, and Processing with this Python Library](/2021/10/simple-text-scraping-parsing-processing-python-library.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Easy Synthetic Data in Python with Faker](/2021/11/easy-synthetic-data-python-faker.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[5 Free Advanced Python Programming Courses](https://www.kdnuggets.com/5-free-advanced-python-programming-courses)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[25 Advanced SQL Interview Questions for Data Scientists](https://www.kdnuggets.com/2022/10/25-advanced-sql-interview-questions-data-scientists.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 10 Advanced Data Science SQL Interview Questions You Must Know…](https://www.kdnuggets.com/2023/01/top-10-advanced-data-science-sql-interview-questions-must-know-answer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Advanced Feature Selection Techniques for Machine Learning Models](https://www.kdnuggets.com/2023/06/advanced-feature-selection-techniques-machine-learning-models.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Back to Basics Week 4: Advanced Topics and Deployment](https://www.kdnuggets.com/back-to-basics-week-4-advanced-topics-and-deployment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 16 Technical Data Sources for Advanced Data Science Projects](https://www.kdnuggets.com/top-16-technical-data-sources-for-advanced-data-science-projects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
