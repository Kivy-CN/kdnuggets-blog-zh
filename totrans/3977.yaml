- en: 'MarshMallow: The Sweetest Python Library for Data Serialization and Validation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/marshmallow-the-sweetest-python-library-for-data-serialization-and-validation](https://www.kdnuggets.com/marshmallow-the-sweetest-python-library-for-data-serialization-and-validation)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![MarshMallow: The Sweetest Python Library for Data Serialization and Validation](../Images/b6ac43e0310a98ea737b8b8744447f8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author | Leonardo AI & Canva
  prefs: []
  type: TYPE_NORMAL
- en: Data serialization is a basic programming concept with great value in everyday
    programs. It refers to converting complex data objects to an intermediate format
    that can be saved and easily converted back to its original form. However, the
    common data serialization Python libraries like JSON and pickle are very limited
    in their functionality. With structured programs and object-oriented programming,
    we need stronger support to handle data classes.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Marshmallow is one of the most famous data-handling libraries that is widely
    used by Python developers to develop robust software applications. It supports
    data serialization and provides a strong abstract solution for handling data validation
    in an object-oriented paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this article, we use a running example given below to understand how to
    use Marshmallow in existing projects. The code shows three classes representing
    a simple e-commerce model: `Product`, `Customer`, and `Order`. Each class minimally
    defines its parameters. We''ll see how to save an instance of an object and ensure
    its correctness when we try to load it again in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Getting Started with Marshmallow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Marshmallow is available as a Python library at PyPI and can be easily installed
    using pip. To install or upgrade the Marshmallow dependency, run the below command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs the recent stable version of Marshmallow in the active environment.
    If you want the development version of the library with all the latest functionality,
    you can install it using the command below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating Schemas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's start by adding Marshmallow functionality to the `Product` class. We need
    to create a new class that represents a schema an instance of the `Product` class
    must follow. Think of a schema like a blueprint, that defines the variables in
    the `Product` class and the datatype they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down and understand the basic code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We create a new class that inherits from the `Schema` class in Marshmallow.
    Then, we declare the same variable names as our `Product` class and define their
    field types. The fields class in Marshmallow supports various data types; here,
    we use the primitive types Int, String, and Float.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have a schema defined for our object, we can now convert a Python
    class instance into a JSON string or a Python dictionary for serialization. Here''s
    the basic implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We create an object of our `ProductSchema`, which converts a Product object
    to a serializable format like JSON or dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Note the difference between `dump` and `dumps` function results. One returns
    a Python dictionary object that can be saved using pickle, and the other returns
    a string object that follows the JSON format.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Deserialization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To reverse the serialization process, we use deserialization. An object is saved
    so it can be loaded and accessed later, and Marshmallow helps with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Python dictionary can be validated using the load function, which verifies
    the variables and their associated datatypes. The below function shows how it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The schema validates that the dictionary has the correct parameters and data
    types. If the validation fails, a `ValidationError` is raised so it's essential
    to wrap the `load function` in a try-except block. If it is successful, the result
    object is still a dictionary when the original argument is also a dictionary.
    Not so helpful right? What we generally want is to validate the dictionary and
    convert it back to the original object it was serialized from.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we use the `post_load` decorator provided by Marshmallow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We create a function in the schema class with the `post_load` decorator. This
    function takes the validated dictionary and converts it back to a Product object.
    Including `**kwargs` is important as Marshmallow may pass additional necessary
    arguments through the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: This modification to the load functionality ensures that after validation, the
    Python dictionary is passed to the `post_load` function, which creates a `Product`
    object from the dictionary. This makes it possible to deserialize an object using
    Marshmallow.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often, we need additional validation specific to our use case. While data type
    validation is essential, it doesn't cover all the validation we might need. Even
    in this simple example, extra validation is needed for our `Product` object. We
    need to ensure that the price is not below 0\. We can also define more rules,
    such as ensuring that our product name is between 3 and 128 characters. These
    rules help ensure our codebase conforms to a defined database schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see how we can implement this validation using Marshmallow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We modify the `ProductSchema` class to add two new functions. One validates
    the price parameter and the other validates the name parameter. We use the validates
    function decorator and annotate the name of the variable that the function is
    supposed to validate. The implementation of these functions is straightforward:
    if the value is incorrect, we raise a `ValidationError`.'
  prefs: []
  type: TYPE_NORMAL
- en: Nested Schemas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, with the basic `Product` class validation, we have covered all the basic
    functionality provided by the Marshmallow library. Let us now build complexity
    and see how the other two classes will be validated.
  prefs: []
  type: TYPE_NORMAL
- en: The `Customer` class is fairly straightforward as it contains the basic attributes
    and primitive datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, defining the schema for the `Order` class forces us to learn a new
    and required concept of Nested Schemas. An order will be associated with a specific
    customer and the customer can order any number of products. This is defined in
    the class definition, and when we validate the `Order` schema, we also need to
    validate the `Product` and `Customer` objects passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of redefining everything in the `OrderSchema`, we will avoid repetition
    and use nested schemas. The order schema is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Within the `Order` schema, we include the `ProductSchema` and `CustomerSchema`
    definitions. This ensures that the defined validations for these schemas are automatically
    applied, following the **DRY (Don't Repeat Yourself)** principle in programming,
    which allows the reuse of existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this article, we covered the quick start and use case of the Marshmallow
    library, one of the most popular serialization and data validation libraries in
    Python. Although similar to Pydantic, many developers prefer Marshmallow due to
    its schema definition method, which resembles validation libraries in other languages
    like JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Marshmallow is easy to integrate with Python backend frameworks like FastAPI
    and Flask, making it a popular choice for web framework and data validation tasks,
    as well as for ORMs like SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: '**[](https://www.linkedin.com/in/kanwal-mehreen1/)**[Kanwal Mehreen](https://www.linkedin.com/in/kanwal-mehreen1/)****
    Kanwal is a machine learning engineer and a technical writer with a profound passion
    for data science and the intersection of AI with medicine. She co-authored the
    ebook "Maximizing Productivity with ChatGPT". As a Google Generation Scholar 2022
    for APAC, she champions diversity and academic excellence. She''s also recognized
    as a Teradata Diversity in Tech Scholar, Mitacs Globalink Research Scholar, and
    Harvard WeCode Scholar. Kanwal is an ardent advocate for change, having founded
    FEMCodes to empower women in STEM fields.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Pydantic Tutorial: Data Validation in Python Made Simple](https://www.kdnuggets.com/pydantic-tutorial-data-validation-in-python-made-simple)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Data Validation for PySpark Applications using Pandera](https://www.kdnuggets.com/2023/08/data-validation-pyspark-applications-pandera.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why Use k-fold Cross Validation?](https://www.kdnuggets.com/2022/07/kfold-cross-validation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pandas AI: The Generative AI Python Library](https://www.kdnuggets.com/2023/05/pandas-ai-generative-ai-python-library.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing Like a Pro: A Step-by-Step Guide to Python''s Mock Library](https://www.kdnuggets.com/testing-like-a-pro-a-step-by-step-guide-to-pythons-mock-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pip Install YOU: A Beginner''s Guide to Creating Your Python Library](https://www.kdnuggets.com/pip-install-you-a-beginners-guide-to-creating-your-python-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
