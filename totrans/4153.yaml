- en: How to Manage Multiple Inheritance in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2022/03/manage-multiple-inheritance-python.html](https://www.kdnuggets.com/2022/03/manage-multiple-inheritance-python.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![How to Manage Multiple Inheritance in Python](../Images/113c4ec2bfab26d5c9db691de1e5d6ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Hitesh Choudhary](https://unsplash.com/@hiteshchoudhary?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/s/photos/python-code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: High-level [object-oriented programming languages](/2020/12/object-oriented-programming-explained-simply-data-scientists.html)
    such as C# and Java do not support multiple inheritance. For a good reason too.
    It prevents ambiguation and facilitates strong typing and encapsulation. This
    ultimately results in cleaner code and less confusing class/object model structures.
    However, multiple inheritance allows for more flexible design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: It can also be very convenient, allowing programmers to write less code and
    push to production quicker. Nevertheless, when you're working with large, complicated
    applications (especially ones that pertain to machine learning), multiple inheritance
    can be difficult to manage and maintain. In this guide, we'll learn how to use
    multiple inheritance and make it sustainable.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Inheritance in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like C++, classes in Python can be derived from multiple classes (instead
    of just one). The deriving class inherits all the parent classes'' features (variables
    and methods/functions). In actuality, defining a class with multiple inheritances
    is really no different from defining one with single inheritance. Here is an example
    to help illustrate this fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Inheritance**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Multiple Inheritance**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the Child class is derived from two classes, it inherits features from
    both classes. Of course, you can inherit from more than two classes. Theoretically,
    there is no limit to the number of classes you can use to construct a child class.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-level Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most object-oriented programming languages, [Python features multi-level
    inheritance](https://www.educba.com/multilevel-inheritance-in-python/). If your
    child class is derived from a class that inherits its features from another class,
    it will inherit all features from both classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Manage Multiple Inheritance in Python](../Images/23d1cbf53e3b8b7ffe9b841e11e26732.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram 1
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the above diagram, the class lowest on the class hierarchy
    inherits all the functions/methods and variables from the two classes above it.
    Combined with multiple inheritance, multi-level inheritance can offer developers
    flexible design options. They can also increase code reusability. However, they
    can also make class structures more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you're using a feature (method or variable) with an identical
    name and structure to a method in a superclass or base class, which method will
    be called first from the subclass? Your class hierarchy may have functions and
    variables with the same names and signatures. How does Python handle this?
  prefs: []
  type: TYPE_NORMAL
- en: Method Resolution Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, as with most OO programming languages, all classes are derived from a
    singular class. In Python, [this is known](https://www.tutorialspoint.com/python/python_classes_objects.htm)
    as the object class. Thus, by default, every class you create is a child/deriving/subclass
    of the Object class. When we're trying to understand the call order of methods
    and variables in Python, you must always remember this information when trying
    to map out the method call order of your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again because Python features multiple and multi-level inheritance, it requires
    a system to resolve inheritance conflicts where the same property has different
    definitions in multiple base/superclasses. The best way to understand this is
    by looking at a coding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Class A inherits from the Object class (as all classes in Python do). Class
    B uses Class A as a base class. It has no features of its own. However, it does
    inherit the num class object attribute from class A (as well as other features
    from the object class).
  prefs: []
  type: TYPE_NORMAL
- en: 'Class C is also a subclass of Class A and defines a class object attribute
    that shares a name with one defined in Class A. Class D inherits from D and C
    but defines no attributes of its own. The relationship looks a lot like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Manage Multiple Inheritance in Python](../Images/0ca1e3b46acfce3a54a96978ba6ffa86.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram 2
  prefs: []
  type: TYPE_NORMAL
- en: The above diagram illustrates what is [referred to as the diamond problem](https://phioro.com/jeweler/how-diamond-problem-is-handled-in-python.html)
    (or deadly diamond of death) in computing. Method resolution order (MRO) is a
    rule to solve this problem. It uses MRO to organize the method and attribute calls.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: Diagram 2 isn’t a strict dependency chart. Rather, it illustrates the
    flow of inheritance.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a method that references the num attribute inherited by the D class.
    This method should be called outside all of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we run it along with our previous code, it should return the number 1 as
    our output. You may be able to tell that it is the value of the num attribute
    in Class C. But why would it return that specific attribute and value?
  prefs: []
  type: TYPE_NORMAL
- en: 'MRO conducts a property search starting from the current class before moving
    to the parent classes. If there are multiple parent classes, MRO will search them
    from left to right. So in our example the search will be conducted as follows:
    D -> B -> C -> A -> object class.'
  prefs: []
  type: TYPE_NORMAL
- en: While it would be helpful to meticulously construct a dependency graph or class
    diagram as you would a [business plan](https://www.waveapps.com/blog/entrepreneurship/importance-of-a-business-plan),
    it's unnecessary. You can simply use Python’s built-in *mro()* method to find
    the resolution order.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the mro() method on the D class and print out the output (i.e. print(D.mro())),
    the console should display these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[<class ''__main__.D''>, <class ''__main__.B''>, <class ''__main__.C''>, <class
    ''__main__.A''>, <class ''object''>]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, it can be translated as: D -> B -> C -> A -> object class. Nevertheless,
    this is easy to understand for simple diamond problems such as the one above.
    However, what if you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Manage Multiple Inheritance in Python](../Images/5a13f2b6f70969e01118ee4cbea21812.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Diagram 3 (Source: [Wikimedia Commons (CC) license](https://upload.wikimedia.org/wikipedia/commons/4/47/C3_linearization_example.svg))'
  prefs: []
  type: TYPE_NORMAL
- en: MRO uses an algorithm called Depth First Search to resolve all method and attribute
    calls. The latest version of Python revised how MRO works. It's uncertain if Python's
    classpath rules and MRO will be refined in future versions too. Therefore, many
    developers (including) myself advise that you stay away from constructing programs
    or algorithms with too much multiple and multi-level inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: If you're writing code that has a dependency structure similar to the diagram
    above, it can be argued that you've written [bad code](/2019/02/4-reasons-machine-learning-code-probably-bad.html).
    Essentially, the examples in this guide hardly had any real functional code between
    the classes. Yet, the structures were still confusing. Now, imagine if you defined
    methods and attributes with identical structures and began calling them...
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While MRO exists and every Python developer should understand it, your code
    should not be structured like Diagram 3 is. However, as a developer (especially
    one working with machine learning), you're bound to run into class structures
    with complicated dependencies. Using the *mro()* method should help you debug,
    untangle and understand code that you may not have written.
  prefs: []
  type: TYPE_NORMAL
- en: Python's main advantage over other OO programming languages is its flexibility
    and freedom. However, its fluidity can be seen as a disadvantage too. There is
    too much room for error and inefficient code. Thus, programmers, especially those
    working with machine learning and deep learning, should learn and apply the most
    [optimal design patterns](/2020/11/deep-learning-design-patterns.html). Notwithstanding,
    to be safe, you may elect to avoid using multiple inheritance in your code altogether.
    However, if you decide to implement it, do it mindfully and sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Nahla Davies](http://nahlawrites.com/)** is a software developer and tech
    writer. Before devoting her work full time to technical writing, she managed —
    among other intriguing things — to serve as a lead programmer at an Inc. 5,000
    experiential branding organization whose clients include Samsung, Time Warner,
    Netflix, and Sony.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Too Many Python Versions to Manage? Pyenv to the Rescue](https://www.kdnuggets.com/too-many-python-versions-to-manage-pyenv-to-the-rescue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Be prepared to manage the threat with an MS in Cybersecurity from…](https://www.kdnuggets.com/2022/07/baypath-prepared-manage-threat-ms-cybersecurity.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 10 MLOps Tools to Optimize & Manage Machine Learning Lifecycle](https://www.kdnuggets.com/2022/10/top-10-mlops-tools-optimize-manage-machine-learning-lifecycle.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Be prepared to manage the threat with an MS in Cybersecurity from…](https://www.kdnuggets.com/2022/12/baypath-prepared-manage-threat-ms-cybersecurity.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Manage Files and Directories in Bash](https://www.kdnuggets.com/how-to-manage-files-and-directories-in-bash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Manage Your Complex IT Landscape with AIOps](https://www.kdnuggets.com/2022/05/manage-complex-landscape-aiops.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
