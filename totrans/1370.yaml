- en: Software engineering fundamentals for Data Scientists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2020/06/software-engineering-fundamentals-data-scientists.html](https://www.kdnuggets.com/2020/06/software-engineering-fundamentals-data-scientists.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[comments](#comments)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b7d920f619a83d06ea12e871e38b632c.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Source: [Chris Ried](https://unsplash.com/photos/ieic5Tq8YMk) @ unsplash.*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a field, Data Science has caused polemic with other disciplines ever since
    it started to grow in popularity. Statisticians complain about the lack of fundamental
    statistics knowledge that’s often observed by practitioners, mathematicians argue
    against the application of tools without a solid understanding of the principles
    applied, and software engineers point at data scientists’ ignorance of basic principles
    while programming. And to be honest, they all have a point. In terms of statistics
    and maths, it is true that you need to have a solid understanding of concepts
    such as probability, algebra, and calculus. How deep that knowledge needs to be?
    Well, that depends a lot on your role, but the basics are not negotiable. A similar
    thing happens when it comes to programming; if your role implies writing production
    code, then you need to know at least the fundamentals in software engineering.
    Why? The reasons are many, but I reckon they could be summarised in a nutshell
    according to five principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrity **of the code, in terms of how well it is written, resilient to
    errors, catching exceptions, tested and being reviewed by others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explainability **of the code, with a proper documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Velocity **of the code for it to be run in live environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modularity **of your scripts and objects in order to be reusable, avoiding
    repetition and gaining efficiency across classes of your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generosity **with your team, for them to review your code as fast as possible
    and in the future understand any piece of code written why you'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line with these points, in this story we’ll see some of the fundamentals
    that I found useful the most, not being a programmer by nature and coming into
    the field from a completely different background. They have helped to write better
    production code, saving me time, and making the life of my workmates easier when
    implementing my scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of writing clean code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/fe1216b521d448a294432b1746174096.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Source: [Oliver Hale](https://unsplash.com/photos/oTvU7Zmteic) @ unsplash.*'
  prefs: []
  type: TYPE_NORMAL
- en: In theory, almost everything we’ll cover in this story could be considered tools
    or tips for writing cleaner code. However, in this specific section, we’ll focus
    on the strict definition of the word clean. As Robert Martin says in his book [Clean
    Code](https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882),
    even bad code can function, but if code isn’t clean, it can bring a development
    organization to its knees. How? Well, to be honest the possibilities are many,
    but just imagine the waste of time it can take to review badly written code or
    starting out in a new role just to find out that you’ll be dealing with some illegible
    code that was written ages ago. Or even worse, imagine that something breaks off,
    causing a product feature to stop working and that the person who wrote the code
    such a dirty code before you is no longer part of the company.
  prefs: []
  type: TYPE_NORMAL
- en: These are all relatively common situations, but let’s be much less dramatic;
    who never wrote down some code, left it hanging for a while to work on something
    more urgent, and then when coming back to it couldn’t remember how it actually
    worked? I know it happened to me.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are all valid reasons for making an extra effort to write better code.
    So let’s start from the basics and go through some tips for writing cleaner scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Be descriptive with the names **within your code. I never forgot a concept
    I learned ages ago when I took some Java lectures at Uni: aim for your code to
    be*mnemonic*. Mnemonic refers to a system such as a pattern of letters, ideas,
    or associations that assists in remembering something. I.e., it means writing
    self-explanatory names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever possible, **try to imply the type**. For example, for a function returning
    a boolean object, you can prefix it with is_ or has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid abbreviations and especially single letters.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, **avoid long names and lines**. Writing long names doesn’t
    mean being more descriptive, and in terms of the lines’ length, the guideline
    in the [PEP 8 style guide for Python Code](https://www.python.org/dev/peps/pep-0008/)
    recommends lines up to 79 characters approx.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don’t sacrifice clarity for consistency**. If, for example, you’ll have objects
    representing employees and a list containing them all, employee_list and employee_1
    is clearer than employees and employee_1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In regards to blank lines and indentation, **make your code easier to read** separating
    sections with bank likes and using consistent indentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of writing modular code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/13e65db455b071d50666ec8f4d63901a.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Source: [Sharon McCutcheon](https://www.pexels.com/photo/art-materials-art-supplies-blocks-blur-1148496/) @
    pexels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This one I reckon is one of the most important points for data scientists and
    data analysts and a very common source of discussion with software engineerings
    given that we’re very used to code in tools such as Jupyter Notebooks. These tools
    that are amazing for Exploratory Data Analysis, but not meant for writing production
    code. In fact, Python is by nature an object-oriented programming language, it
    is not within this scope to cover in-depth what does that means. But, in short,
    unlike procedural programming, where you code a list of instructions for a script
    to execute, object-oriented programming is about building modules with their own
    characteristics and actions. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a8ede08cba7ff915b06d51bb1e8a7d6e.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Source: image created by the author.*'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, these characteristics are known as attributes, and the actions
    will be methods. In the example above, the objects Computer and Printer would
    be independent classes. A class is a blueprint containing the attributes and methods
    of all the objects of that specific type. I.e., all the Computers and Printers
    that we create would share the same attributes and methods. The concept behind
    this idea is called encapsulation. Encapsulation means that you can combine functions
    and data all into a single entity or module. And when you break a program into
    modules, different modules don’t need to know how something is accomplished if
    they are not responsible for doing it. And why is this useful? Well, not only
    for the code to be reusable, avoiding repetition, and gaining efficiency across
    classes of your code as mentioned before but it also makes it easier to debug
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this might not be relevant if all you’re doing is Exploratory Data Analysis
    within a Jupyter Notebook, but if you’re writing a script that will be part of
    a live environment, and especially as applications grow in size, it makes sense
    to split your code into separate modules. By perfecting each section of the program
    before putting all of the sections together, you not only make it easier to reuse
    individual modules in other programs, you make it easier to fix problems by being
    able to pinpoint the source of the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some further tips for writing modular code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DRY: Don’t Repeat Yourself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functions not only makes it less repetitive but also improves readability
    with descriptive names to understand what each module does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the number of entities (functions, classes, modules, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single Responsibility Principle: The idea that a class should have one-and-only-one
    responsibility. Harder than one might expect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the Open/Closed Principle. I.e., objects should be open for extension
    but closed for modification. The idea is to write code so that you’ll be able
    to add new functionality without changing the existing code, preventing situations
    in which a change to one of your classes also requires you to adapt all depending
    classes. [There are different ways of facing this challenge](https://stackify.com/solid-design-open-closed-principle/),
    though in Python, it’s very common to use inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to use less than three arguments per function. If it has many, maybe split
    it. A similar criterion applies to the length of the function; ideally, a function
    should have between 20 and 50 lines. If it has more, then you might want to break
    it into separate functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mind the length of your classes as well. If a class has more than 300 lines,
    then it should probably be split into smaller classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re already using Python, but have none or little knowledge about object-oriented
    programming, I strongly recommend these two free courses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Object-Oriented Programming in Python](https://www.datacamp.com/courses/object-oriented-programming-in-python) at
    Datacamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Intro to Object-Oriented Programming (OOP) in Python](https://realpython.com/courses/intro-object-oriented-programming-oop-python/) at [https://realpython.com/](https://realpython.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of refactoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/bae4178d7b038c4cc46b8108bbaf8fcc.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Source: [RyanMcGuire](https://pixabay.com/photos/car-repair-car-workshop-repair-shop-362150/) @
    pixabay.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia states the definition of refactoring as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In computer programming and software design, code refactoring is the process
    of restructuring existing computer code without changing its external behaviour.
    Refactoring is intended to improve the design, structure, and/or implementation
    of the software while preserving its functionality. Potential advantages of refactoring
    may include improved code readability and reduced complexity; these can improve
    the source code’s maintainability and create a simpler, cleaner, or more expressive
    internal architecture or object model to improve extensibility.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I reckon that the definition speaks by itself, but apart from it, we could
    add that refactoring gives us a chance to clean and modularize our code after
    we''ve got it working. It gives us as well a chance to improve the efficiency
    of our code. And what I’ve learned so far, is that when a software engineer talks
    about efficient code, they usually refer to either of these:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing run time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reducing space in memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s briefly cover both points…
  prefs: []
  type: TYPE_NORMAL
- en: In my experience,** reducing the run time** of your code is something that you
    learn over time as you write more and more production code. When you’re doing
    some analysis in your Jupyter Notebook, it doesn’t matter if calculating those
    pairwise distances takes you two, five, or ten minutes. You can leave it running,
    answer some Slack messages, go to the bathroom, fill up a cup of coffee, and come
    back to see your code done. However, what happens when there’s a user waiting
    on the other side? You can’t just leave them hanging while your code compiles,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, there are several ways to improve. Let’s quickly cover some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use vector operations to make your computations faster**. For example, when
    checking if elements of one array are within another, instead of writing for loops,
    you can use NumPy''s *intersect1d*. You can also use vectors to search for elements
    according to a condition in order to perform an addition or a similar operation.
    Let’s see a quick example for when we have to **iterate through a list of numbers
    and perform an operation given a condition**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Time: 3.6942789554595947 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Time: 0.06348109245300293 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: More than 58 times faster!
  prefs: []
  type: TYPE_NORMAL
- en: 'I know that Pandas Dataframes are super easy to use, and we all Pythonistas
    love them. However, when writing production code, it is better to simply avoid
    them. Much of the operations we perform with Pandas can be done as well with Numpy.
    Let’s see some other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sum matrix across rows according to condition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, multiplying by a boolean array works because True corresponds
    to 1 and False to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Add a column according to some condition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Prints: (1000000, 21) | The new column has been added.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter the table according to several conditions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Prints: (55183, 21) | 55183 rows match the condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Replace elements if a condition is met**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the code above, another great option for reducing our run time is **parallelization**.
    Parallelization implies writing a script to process data in parallel, using several
    or all the available processors in the machine. Why can this lead us to a massive
    improvement in speed? Because most of the time, our scripts compute data serially:
    they solve one problem, and then the following, and then the following, and so
    on. When we write code in Python, that’s usually what happens, and if we want
    to take advantage of parallelization, we have to be explicit about it. I’ll be
    writing an independent story about this soon, however, if you’re eager for learning
    more about it, among all the libraries available for parallelization, my favourites
    so far are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiprocessing](https://docs.python.org/3/library/multiprocessing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Numba](https://numba.pydata.org/numba-doc/latest/user/5minguide.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In regards to **reducing space in memory**, reducing memory usage in Python
    is difficult, because [Python does not actually release memory back to the operating
    system](http://effbot.org/pyfaq/why-doesnt-python-release-the-memory-when-i-delete-a-large-object.htm).
    If you delete objects, then the memory is available to new Python objects, but
    it won’t be free() back to the system. Moreover, as mentioned before, Pandas is
    a great tool for Exploratory Data Analysis, but apart from being slower for production
    code, it is also quite expensive in terms of memory. However, there a few things
    we can do to keep that memory use under control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First thing first: if possible, **use NumPy arrays instead of Pandas** Even
    a dictionary if possible will take much less memory than a Dataframe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduce the number of Pandas Dataframe**: when we’re modifying dataframes,
    instead of creating a new object, try to modify the dataframe itself using the
    parameter inplace=True, so you don’t create copies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear your history**: each time you make a change on a dataframe (e.g., df
    + 2), Python holds copies of that object in memory. You can clear that history
    by using %reset Out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be aware of your data types**: object and string dtypes are much more expensive
    in terms of memory in comparison with numbers. That’s why it’s always useful to
    examine the data types of your dataframe using df.info() and cast them if possible
    using df[‘column’] = df[‘columns’].astype(type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use sparse matrices**: if you have a matrix with lots of null values or empty
    cells, it would be convenient to use instead a sparse matrix, that usually takes
    much less space in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can do that using *scipy.sparse.csr_matrix(df.values)*
  prefs: []
  type: TYPE_NORMAL
- en: '**Using generators instead of objects**: generators allow you to declare a
    function that behaves like an iterator, but using the word *yield*rather than *return*.
    Instead of creating a new object (i.e., a list or a NumPy array) with all the
    calculations, generators generate a single value that’s held in memory and gets
    updated only when you ask for it. This is known as lazy evaluation. Find more
    about Generators in this great story of [Abhinav Sagar](https://towardsdatascience.com/@abhinav.sagar) in
    Towards Data Science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/b0fac3f71716a374de4c187c387c41f9.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Source: [Pixabay](https://www.pexels.com/photo/red-and-yellow-hatchback-axa-crash-tests-163016/) at
    @ pexels.*'
  prefs: []
  type: TYPE_NORMAL
- en: Tests in Data Science are needed. Other software related areas usually complain
    about the lack of testing in data scientist’s code. While in other kinds of algorithms
    or scripts, the program might just stop working if there’s a mistake, in Data
    Science this is even more dangerous cause the program might actually run, but
    end up with wrong insights and recommendations due to values encoded incorrectly,
    features being used inappropriately or data breaking assumptions that the models
    are actually based on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main concepts worth talking about when we refer to testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the former. **Unit tests** are called that because they cover
    a small unit of code. The goal is to validate that each individual part of our
    code performs as designed. In object-oriented programming languages, such as Python,
    a unit can also be designed for evaluating an entire class but could be an individual
    method or function as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests can be written from scratch. In fact, let’s do that so we can grasp
    a better understanding of how unit tests actually work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I have the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And I want to test that the following inputs return the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 and 2 return 4.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 and 5 return 5.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 and 8 return 9.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could perfectly write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And then simply test our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Prints: *Worked as expected!*
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this can get trickier with more complex functions, and when we want
    to test several functions at once, or even a class, for example. A great tool
    for unit testing without all this faff is [pytest library](https://docs.pytest.org/en/latest/getting-started.html).
    Pytest requires you to create a python script containing the function or functions
    to be tested, along with another set of functions asserting the output. The file
    needs to be saved with the prefix ‘test’, and then it just needs to be run as
    any other Python script. Pytest was originally developed to use from the command
    line, but there’s a hacky way of using it from a Jupyter Notebook if you’re still
    at early stages of a project; you can create and save a .py file using the magic
    command *%%writefile* and then simply run the script using command line statements
    directly from the notebook. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The simply run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And see an output like this if everything ran as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/efa239201e3ca82744ad7f7d84db4362.png)'
  prefs: []
  type: TYPE_IMG
- en: In the future, I’ll write another story to talk about more complex examples
    of unit tests, and how to test an entire class if that’s what you need. But meanwhile,
    this should be more than enough to get you started and test some of your functions.
    Mind that in the examples above, I’m testing the exact number being returned,
    but you could test as well the shape of a dataframe, the length of a NumPy array,
    the type of the object returned, etc.
  prefs: []
  type: TYPE_NORMAL
- en: The other point we mentioned before at the beginning of this chapter was **Test
    Driven Development or TDD**. This approach or methodology for testing consists
    of writing the unit tests to be performed for a piece of code, even before starting
    to develop. Next step, you’ll want to write the simplest and/or quickest piece
    of code you can as to pass the tests you wrote down initially, this will help
    you to ensure quality, by focusing on the requirements before writing your code.
    Also, it will force you to keep the code simple, clean, and testable by breaking
    it down into small chunks of code, in accordance with the test or tests are written
    initially. Once you have a piece of code that actually passes those tests, just
    then, you’ll focus on refactoring for improving the quality or further functionalities
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d9994ecd4b3ba3238aa4cbe5f036c495.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Source: [https://me.me/](https://me.me/)*'
  prefs: []
  type: TYPE_NORMAL
- en: A major benefit of TDD is that if in the future a change is needed in the code
    and you’re no longer working on that project, you moved on to another company
    or perhaps you are simply on holidays, knowing the tests that were written originally
    will help anyone taking the code to be sure that it won’t break anything once
    the change is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some further points worth considering:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notebooks: ideal for exploration, not ideal for TDD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ping pong TDD: one person writes the tests, another the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set both performance and output metrics for your tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of code reviewing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/dd9c380898050c5dcffa3a5a687649f4.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Source: [Charles Deluvio](https://unsplash.com/photos/Lks7vei-eAg) @ unsplash.*'
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews benefit everyone in a team to promote best programming practices
    and prepare code for production. The main goal of code reviews is to catch errors.
    However, they are also helpful for improving readability and check that the standards
    are met among a team, so no dirty or slow code is fed into production. Beyond
    these points, code reviews are also great for sharing knowledge, as members of
    the team get to read pieces of code from people with different backgrounds and
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, the tool that is excellent for code reviewing is the platform GitHub
    with pull requests. A pull request is a solicitude for integrating a change in
    a piece of code or an entirely new script, into a certain code environment. It
    is called pull request because their submission implies precisely requesting someone
    to pull the code you wrote into the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'From [GitHub’s documentation](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests), we
    can see their definition of a pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pull requests let you tell others about changes you’ve pushed to a branch
    in a repository on GitHub. Once a pull request is opened, you can discuss and
    review the potential changes with collaborators and add follow-up commits before
    your changes are merged into the base branch.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pull requests are an art by themselves, and if you’re interested in learning
    more about them, [this story](https://medium.com/@hugooodias/the-anatomy-of-a-perfect-pull-request-567382bb6067) called
    “The anatomy of a perfect pull request” by [Hugo Dias](https://medium.com/@hugooodias) will
    definitely come in handy. However, here there are a few questions that you can
    ask yourself when reviewing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is the code clean and modular? **Look for duplication, whitespaces, readability,
    and modularity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is the code efficient? **Look at loops, objects, functions structure, can
    it use multiprocessing?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is documentation effective? **Look for in-line comments, [docstrings](https://en.wikipedia.org/wiki/Docstring) and
    readme files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Has the code been tested? **Look for unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is the **[**logging**](https://www.quora.com/What-is-Logging-in-programming) **good
    enough?** Look for clarity and right frequency of logging message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Original](https://towardsdatascience.com/software-engineering-fundamentals-for-data-scientists-6c95316d6cc4).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Software Interfaces for Machine Learning Deployment](https://www.kdnuggets.com/2020/03/software-interfaces-machine-learning-deployment.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How To Unit Test Machine Learning Code](https://www.kdnuggets.com/2017/11/unit-test-machine-learning-code.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Coding habits for data scientists](https://www.kdnuggets.com/2020/05/coding-habits-data-scientists.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[5 Free Online Courses to Learn Data Engineering Fundamentals](https://www.kdnuggets.com/5-free-online-courses-to-learn-data-engineering-fundamentals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fundamentals Of Statistics For Data Scientists and Analysts](https://www.kdnuggets.com/2023/08/fundamentals-statistics-data-scientists-analysts.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Software Developer vs Software Engineer](https://www.kdnuggets.com/2022/05/software-developer-software-engineer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News March 16, 2022: Learn Data Science Fundamentals & 5…](https://www.kdnuggets.com/2022/n11.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Long Does It Take to Learn Data Science Fundamentals?](https://www.kdnuggets.com/2022/03/long-take-learn-data-science-fundamentals.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Free Online Courses to Learn Data Science Fundamentals](https://www.kdnuggets.com/5-free-online-courses-to-learn-data-science-fundamentals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
