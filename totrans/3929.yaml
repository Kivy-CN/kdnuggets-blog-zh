- en: Get a 2–6x Speed-up on Your Data Pre-processing with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2018/10/get-speed-up-data-pre-processing-python.html](https://www.kdnuggets.com/2018/10/get-speed-up-data-pre-processing-python.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [comments](#comments)'
  prefs: []
  type: TYPE_IMG
- en: Python is the go-to programming language for all things machine learning. It’s
    easy to use and has many fantastic libraries that make crunching data a breeze!
    But things get a big trickier when we’re dealing with lots of data….
  prefs: []
  type: TYPE_NORMAL
- en: These days, the term “big data” usually refers to a dataset that’s on the order
    of at least hundreds of thousands if not *millions* of data points! At such a
    scale, every little computation adds up and we need to keep efficiency in mind
    when coding each step of the pipeline. One critical step that is often overlooked
    when thinking about our machine learning system’s efficiency is the *pre-processing* stage,
    where we must apply some kind of operation to all of our data points.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Python programs execute as a single process using a single CPU.
    Most modern machines made for machine learning have *at least *2 CPU cores. That
    means, for the example of 2 CPU cores, that 50% or more of your computer’s processing
    power won’t be doing anything by default when you run your pre-processing! The
    situation gets even worse when you get to 4 cores (modern Intel i5) or 6cores
    (modern Intel i7).
  prefs: []
  type: TYPE_NORMAL
- en: But thankfully, there is a somewhat hidden feature in a built-in Python library
    that lets us take advantage of all of our CPU cores! Thanks to Python’s `concurrent.futures` module,
    it only takes 3 lines of code to turn a normal program into one that can process
    data in parallel across the CPU cores.
  prefs: []
  type: TYPE_NORMAL
- en: The standard approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a simple example where we have a dataset of images in a single folder;
    maybe we even have thousands or millions of those images! For the sake of processing
    time we’ll use 1000 here. We would like to resize all images to size 600x600 before
    passing it to our deep neural network. This is what it would look like in some
    pretty standard Python code you would often see on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program follows a simple pattern you’ll often see in data processing scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: You start with a list of files (or other data) that you want to process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You process each piece of data, one at a time, using a `for` loop and then running
    the pre-processing on each loop iteration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s test this program on a folder with 1000 jpeg files and see how long it
    takes to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On my i7–8700k with 6 CPU cores, that gave me a run time of **7.9864 seconds**!
    It seems a bit slow for such a high-end CPU. Let’s see what we can do to speed
    things up.
  prefs: []
  type: TYPE_NORMAL
- en: The fast way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand how we would want Python to process things in parallel, it helps
    to think intuitively about parallel processing itself. Let’s say we have to perform
    the same single task of hitting nails into a piece of wood and that we have 1000
    nails in our bucket. If we say that each nail takes 1 second, then with 1 person
    we would finish the job in 1000 seconds. But if we have 4 people on the team,
    we would divide the bucket into 4 equal piles and then each person on the team
    would work on their own pile of nails. With this method, we would finish in only
    250 seconds!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have Python do something similar for us in our example here with the
    1000 images:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the list of jpg files into 4 smaller groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run 4 separate instances of the Python interpreter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have each instance of Python process one of the 4 smaller groups of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine the results from the 4 processes to get the final list of results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The great part about all this is that Python handles all the hard work for us.
    We just tell it which function we want to run and how many instances of Python
    to use and it does all the rest! We only have to change **3 lines of code**.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'boots up as many Python processes as you have CPU cores, in my case 6\. The
    actually processing line is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **executor.map() **takes as input the function you would like to run and
    a list where each element of the list is a **single input to our function**. Since
    we have 6 cores, we will be processing 6 items from that list at the same time!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we again run our program using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We get a run time of **1.14265 seconds**, a nearly x6 speed-up!
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: There is some overhead in spawning more Python processes and shuffling
    data around between them, so you won’t always get this much of a speed improvement.
    But overall your speed-up will usually be quite significant*'
  prefs: []
  type: TYPE_NORMAL
- en: Is it always super fast?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using Python parallel pools is a great solution when you have a list of data
    to process and you are performing a similar computation on each data point. But,
    it’s not always going to be the perfect solution. The data processed by parallel
    pools won’t be processed in any predictable order. If you need the result from
    the processing to be in a specific order, then this method probably isn’t right
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data you are processing also needs to be a type that Python knows how to
    “pickle”. Luckily, these are quite common. From the official Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`None`, `True`, and `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: integers, floating point numbers, complex numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: strings, bytes, bytearrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuples, lists, sets, and dictionaries containing only picklable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: functions defined at the top level of a module (using `[def](https://docs.python.org/3/reference/compound_stmts.html#def)`,
    not `[lambda](https://docs.python.org/3/reference/expressions.html#lambda)`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: built-in functions defined at the top level of a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: classes that are defined at the top level of a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: instances of such classes whose `[__dict__](https://docs.python.org/3/library/stdtypes.html#object.__dict__)` or
    the result of calling `[__getstate__()](https://docs.python.org/3/library/pickle.html#object.__getstate__)` is
    picklable (see section [Pickling Class Instances](https://docs.python.org/3/library/pickle.html#pickle-inst) for
    details).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like to read about nerd stuff?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Follow me on [twitter](https://twitter.com/GeorgeSeif94) where I post all about
    the latest and greatest AI, Technology, and Science!
  prefs: []
  type: TYPE_NORMAL
- en: '**Bio: [George Seif](https://towardsdatascience.com/@george.seif94)** is a
    Certified Nerd and AI / Machine Learning Engineer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](https://towardsdatascience.com/heres-how-you-can-get-a-2-6x-speed-up-on-your-data-pre-processing-with-python-847887e63be5).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[5 “Clean Code” Tips That Will Dramatically Improve Your Productivity](/2018/10/5-clean-code-tips-dramatically-improve-productivity.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The 5 Clustering Algorithms Data Scientists Need to Know](/2018/06/5-clustering-algorithms-data-scientists-need-know.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Selecting the Best Machine Learning Algorithm for Your Regression Problem](/2018/08/selecting-best-machine-learning-algorithm-regression-problem.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Easy Guide To Data Preprocessing In Python](https://www.kdnuggets.com/2020/07/easy-guide-data-preprocessing-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Learn Data Cleaning and Preprocessing for Data Science with This Free eBook](https://www.kdnuggets.com/2023/08/learn-data-cleaning-preprocessing-data-science-free-ebook.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7 Steps to Mastering Data Cleaning and Preprocessing Techniques](https://www.kdnuggets.com/2023/08/7-steps-mastering-data-cleaning-preprocessing-techniques.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Harnessing ChatGPT for Automated Data Cleaning and Preprocessing](https://www.kdnuggets.com/2023/08/harnessing-chatgpt-automated-data-cleaning-preprocessing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cleaning and Preprocessing Text Data in Pandas for NLP Tasks](https://www.kdnuggets.com/cleaning-and-preprocessing-text-data-in-pandas-for-nlp-tasks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Get Your First Job in Data Science without Any Work Experience](https://www.kdnuggets.com/2021/02/first-job-data-science-without-work-experience.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
