["```py\ndf_movie = pd.read_csv('rotten_tomatoes_movies.csv')\ndf_movie.head()\n```", "```py\ndf_movie.describe()\n```", "```py\nprint(f'Content Rating category: {df_movie.content_rating.unique()}')\n```", "```py\nax = df_movie.content_rating.value_counts().plot(kind='bar', figsize=(12,9))\nax.bar_label(ax.containers[0])\n```", "```py\nprint(f'Content Rating category: {df_movie.content_rating.unique()}')\nax = df_movie.content_rating.value_counts().plot(kind='bar', figsize=(12,9))\nax.bar_label(ax.containers[0])\n```", "```py\ncontent_rating = pd.get_dummies(df_movie.content_rating)\ncontent_rating.head()\n```", "```py\nprint(f'Audience status category: {df_movie.audience_status.unique()}')\n```", "```py\n# Visualize the distribution of each category\nax = df_movie.audience_status.value_counts().plot(kind='bar', figsize=(12,9))\nax.bar_label(ax.containers[0])\n```", "```py\nprint(f'Audience status category: {df_movie.audience_status.unique()}')\n# Visualize the distribution of each category\nax = df_movie.audience_status.value_counts().plot(kind='bar', figsize=(12,9))\nax.bar_label(ax.containers[0])\n```", "```py\n# Encode audience status variable with ordinal encoding\naudience_status = pd.DataFrame(df_movie.audience_status.replace(['Spilled','Upright'],[0,1]))\naudience_status.head()\n```", "```py\n# Encode tomatometer status variable with ordinal encoding\ntomatometer_status = pd.DataFrame(df_movie.tomatometer_status.replace(['Rotten','Fresh','Certified-Fresh'],[0,1,2]))\ntomatometer_status\n```", "```py\ndf_feature = pd.concat([df_movie[['runtime', 'tomatometer_rating', 'tomatometer_count', 'audience_rating', 'audience_count', 'tomatometer_top_critics_count', 'tomatometer_fresh_critics_count', 'tomatometer_rotten_critics_count']], content_rating, audience_status, tomatometer_status], axis=1).dropna()\ndf_feature.head()\n```", "```py\ndf_feature.describe()\n```", "```py\nlen(df)\n```", "```py\nax = df_feature.tomatometer_status.value_counts().plot(kind='bar', figsize=(12,9))\nax.bar_label(ax.containers[0])\n```", "```py\nX_train, X_test, y_train, y_test = train_test_split(df_feature.drop(['tomatometer_status'], axis=1), df_feature.tomatometer_status, test_size= 0.2, random_state=42)\nprint(f'Size of training data is {len(X_train)} and the size of test data is {len(X_test)}')\n```", "```py\ntree_3_leaf = DecisionTreeClassifier(max_leaf_nodes= 3, random_state=2)\n```", "```py\ntree_3_leaf.fit(X_train, y_train)\n```", "```py\ny_predict = tree_3_leaf.predict(X_test)\n```", "```py\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict))\n```", "```py\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(tree_3_leaf, X_test, y_test, cmap='cividis', ax=ax)\n```", "```py\n# Instantiate Decision Tree Classifier with max leaf nodes = 3\ntree_3_leaf = DecisionTreeClassifier(max_leaf_nodes= 3, random_state=2)\n# Train the classifier on the training data\ntree_3_leaf.fit(X_train, y_train)\n# Predict the test data with trained tree classifier\ny_predict = tree_3_leaf.predict(X_test)\n# Print accuracy and classification report on test data\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict))\n# Plot confusion matrix on test data\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(tree_3_leaf, X_test, y_test, cmap ='cividis', ax=ax)\n```", "```py\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_tree(tree_3_leaf, ax= ax)\nplt.show()\n```", "```py\ntree = DecisionTreeClassifier(random_state=2)\n```", "```py\ntree.fit(X_train, y_train)\n```", "```py\ny_predict = tree.predict(X_test)\n```", "```py\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict))\n```", "```py\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(tree, X_test, y_test, cmap ='cividis', ax=ax)\n```", "```py\nfig, ax = plt.subplots(figsize=(12, 9))\n# Instantiate Decision Tree Classifier with default hyperparameter settings\ntree = DecisionTreeClassifier(random_state=2)\n\n# Train the classifier on the training data\ntree.fit(X_train, y_train)\n\n# Predict the test data with trained tree classifier\ny_predict = tree.predict(X_test)\n\n# Print accuracy and classification report on test data\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict))\n\n# Plot confusion matrix on test data\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(tree, X_test, y_test, cmap ='cividis', ax=ax)\n```", "```py\nrf = RandomForestClassifier(random_state=2)\n```", "```py\nrf.fit(X_train, y_train)\n```", "```py\ny_predict = rf.predict(X_test)\n```", "```py\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict)) \n```", "```py\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf, X_test, y_test, cmap ='cividis', ax=ax)\n```", "```py\n# Instantiate Random Forest Classifier\nrf = RandomForestClassifier(random_state=2)\n\n# Train Random Forest Classifier on training data\nrf.fit(X_train, y_train)\n\n# Predict test data with trained model\ny_predict = rf.predict(X_test)\n\n# Print accuracy score and classification report\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict))\n\n# Plot confusion matrix\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf, X_test, y_test, cmap ='cividis', ax=ax)\n```", "```py\n# Get the feature importance\nfeature_importance = rf.feature_importances_\n```", "```py\n# Print feature importance\nfor i, feature in enumerate(X_train.columns):\n    print(f'{feature} = {feature_importance[i]}')\n```", "```py\n# Visualize feature from the most important to the least important\nindices = np.argsort(feature_importance)\n```", "```py\nplt.figure(figsize=(12,9))\nplt.title('Feature Importances')\nplt.barh(range(len(indices)), feature_importance[indices], color='b', align='center')\nplt.yticks(range(len(indices)), [X_train.columns[i] for i in indices])\nplt.xlabel('Relative Importance')\nplt.show()\n```", "```py\n# Get the fature importance\nfeature_importance = rf.feature_importances_\n\n# Print feature importance\nfor i, feature in enumerate(X_train.columns):\n    print(f'{feature} = {feature_importance[i]}')\n\n# Visualize feature from the most important to the least important\nindices = np.argsort(feature_importance)\n\nplt.figure(figsize=(12,9))\nplt.title('Feature Importances')\nplt.barh(range(len(indices)), feature_importance[indices], color='b', align='center')\nplt.yticks(range(len(indices)), [X_train.columns[i] for i in indices])\nplt.xlabel('Relative Importance')\nplt.show()\n```", "```py\n# Get the feature importance\nfeature_importance = rf.feature_importances_\nX_train, X_test, y_train, y_test = train_test_split(df_feature.drop(['tomatometer_status', 'NR', 'runtime', 'PG-13', 'R', 'PG','G', 'NC17'], axis=1),df_feature.tomatometer_status, test_size= 0.2, random_state=42)\nprint(f'Size of training data is {len(X_train)} and the size of test data is {len(X_test)}')\n```", "```py\nrf = RandomForestClassifier(random_state=2)\n\nrf.fit(X_train, y_train)\n```", "```py\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict))\n```", "```py\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf, X_test, y_test, cmap ='cividis', ax=ax)\n```", "```py\n# Initialize Random Forest class\nrf = RandomForestClassifier(random_state=2)\n\n# Train Random Forest on the training data after feature selection\nrf.fit(X_train, y_train)\n\n# Predict the trained model on the test data after feature selection\ny_predict = rf.predict(X_test)\n\n# Print the accuracy score and the classification report\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict))\n\n# Plot the confusion matrix\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf, X_test, y_test, cmap ='cividis', ax=ax)\n```", "```py\nax = df_feature.tomatometer_status.value_counts().plot(kind='bar', figsize=(12,9))\nax.bar_label(ax.containers[0])\n```", "```py\nclass_weight = compute_class_weight(class_weight= 'balanced', classes= np.unique(df_feature.tomatometer_status), \n                      y = df_feature.tomatometer_status.values)\n```", "```py\nclass_weight_dict = dict(zip(range(len(class_weight.tolist())), class_weight.tolist()\n```", "```py\nclass_weight_dict\n```", "```py\nclass_weight = compute_class_weight(class_weight= 'balanced', classes= np.unique(df_feature.tomatometer_status), \n                      y = df_feature.tomatometer_status.values)\n\nclass_weight_dict = dict(zip(range(len(class_weight.tolist())), class_weight.tolist()))\nclass_weight_dict\n```", "```py\n# Initialize Random Forest model with weight information\nrf_weighted = RandomForestClassifier(random_state=2, class_weight=class_weight_dict)\n\n# Train the model on the training data\nrf_weighted.fit(X_train, y_train)\n\n# Predict the test data with the trained model\ny_predict = rf_weighted.predict(X_test)\n\n#Print accuracy score and classification report\nprint(accuracy_score(y_test, y_predict))\nprint(classification_report(y_test, y_predict))\n\n#Plot confusion matrix\nfig, ax = plt.subplots(figsize=(12, 9))\nplot_confusion_matrix(rf_weighted, X_test, y_test, cmap ='cividis', ax=ax)\n```"]