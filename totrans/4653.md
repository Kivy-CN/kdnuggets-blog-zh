# 谁是你的“金鹅”?: 同期分析

> 原文：[https://www.kdnuggets.com/2019/05/golden-goose-cohort-analysis.html](https://www.kdnuggets.com/2019/05/golden-goose-cohort-analysis.html)

![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [评论](/2019/05/golden-goose-cohort-analysis.html/2#comments)

**[由 Jiwon Jeong](https://www.linkedin.com/in/jiwon-jeong/)，延世大学研究生助理**

客户细分是一种根据客户购买模式将客户划分为不同组的技术，以识别哪些是最有利可图的组。在细分客户时，也可以根据市场使用各种标准，例如地理、人口统计特征或行为基础。这种技术假设具有不同特征的群体需要不同的营销方法，并希望找出那些能最大限度提升盈利的群体。

今天，我们将讨论如何使用来自 UCI ML repo 的 [在线零售数据集](https://www.kaggle.com/jihyeseo/online-retail-data-set-from-uci-ml-repo) 进行客户细分分析。此分析将重点关注两个步骤：获取 RFM 值和使用 K-means 算法进行聚类。数据集和完整代码也可以在我的 [Github](https://github.com/jjone36/Cohort/blob/master/Cohort_Anaylsis_Medium.ipynb) 上找到。本笔记的原始资源来自课程 “[Python 中的客户细分分析](https://www.datacamp.com/courses/customer-segmentation-in-python)。”

### 什么是 RFM？

RFM 是近期（Recency）、频率（Frequency）和货币（Monetary）的首字母缩略词。**近期** 指的是客户最后一次订单的时间。这意味着自客户最后一次购买以来的天数。如果是网站或应用程序的情况，这可以解释为最后一次访问日期或最后一次登录时间。

**频率** 指的是在给定时间段内的购买次数。这可以是 3 个月、6 个月或 1 年。因此，我们可以将此值理解为客户使用公司产品的频率或数量。值越大，客户的参与度越高。我们可以称他们为 VIP 吗？不一定。因为我们还必须考虑他们每次购买实际支付了多少，这意味着货币价值。

**货币** 是指客户在给定时间段内花费的总金额。因此，大额消费的客户将与其他客户如 MVP 或 VIP 区分开来。

![图示](../Images/3425b2287bfac7a1cfbe638805f406cb.png)

图片来源于 CleverTap

这三个值是同期分析中常用的可量化因素。由于它们简单直观的概念，它们在其他客户细分方法中也很受欢迎。

### 导入数据

所以今天我们将把 RFM 应用于我们的同期分析。我们将使用的数据集是从 2010 年 1 月到 2011 年 9 月的交易历史数据。由于这是同期分析的教程指南，我将仅使用原始数据集的随机选取部分。

```py
# Import data
online = pd.read_excel('Online Retail.xlsx')
# drop the row missing customer ID 
online = online[online.CustomerID.notnull()]
online = online.sample(frac = .3).reset_index(drop = True)
online.head()

```

![importing rfm data](../Images/82ba67ed2348ffcb5e56742d2640f096.png)

### 计算RFM值

我们首先要计算的是最近值，即自客户最后一次订单以来的天数。我们可以从哪个列中获得这个值？**InvoiceData**。通过这个列，我们可以得到客户的首次购买和最后一次购买的时间。我们将第一次购买称为**CohortDay**。由于**InvoiceDate**还包含附加的时间数据，我们需要提取年、月和日部分。之后，我们将得到**CohortDay**，即**InvoiceDay**的最小值。

```py
# extract year, month and day
online['InvoiceDay'] = online.InvoiceDate.apply(lambda x: dt.datetime(x.year, x.month, x.day))
online.head()
```

![calculating rfm values](../Images/5a33209e8858b432108dd99ae9c19301.png)

由于我们随机选择了数据的子集，我们还需要了解数据的时间周期。如下面所示，我们的数据集的最后一天是2011年12月9日。因此，将12月10日设为我们的基准日期，并从每位客户的最近一次购买向后计算天数。这将是最近值。

```py
 # print the time period
print('Min : {}, Max : {}'.format(min(online.InvoiceDay), max(online.InvoiceDay)))

```

![Figure](../Images/14ab7f9a8d69a837a9d3ac8359fbe2dd.png)

```py
# pin the last date
pin_date = max(online.InvoiceDay) + dt.timedelta(1)

```

在计算最近值之前，让我们先计算另一个值，即每位客户花费的总金额。这是为了计算货币值。我们怎么得到这个值？很简单！将每行的产品价格与订单数量相乘。

```py
# Create total spend dataframe
online['TotalSum'] = online.Quantity * online.UnitPrice
online.head()
```

![total spend dataframe](../Images/fb9408756d1642695f6129e79e9076bd.png)

现在我们准备一次性获取三个RFM值。我将按客户分组数据，并对每个最近、频率和货币值进行汇总。

```py
# calculate RFM values
rfm = online.groupby('CustomerID').agg({
    'InvoiceDate' : lambda x: (pin_date - x.max()).days,
    'InvoiceNo' : 'count', 
    'TotalSum' : 'sum'})
# rename the columns
rfm.rename(columns = {'InvoiceDate' : 'Recency', 
                      'InvoiceNo' : 'Frequency', 
                      'TotalSum' : 'Monetary'}, inplace = True)
rfm.head()

```

![RFM table](../Images/312a3e54cb8f148d479933ff79cf8817.png)

### RFM四分位数

现在我们将基于RFM值对客户进行分组。由于这些是连续值，我们也可以使用分位数值，将其分成4组。

```py
# create labels and assign them to tree percentile groups 
r_labels = range(4, 0, -1)
r_groups = pd.qcut(rfm.Recency, q = 4, labels = r_labels)
f_labels = range(1, 5)
f_groups = pd.qcut(rfm.Frequency, q = 4, labels = f_labels)
m_labels = range(1, 5)
m_groups = pd.qcut(rfm.Monetary, q = 4, labels = m_labels)

```

请特别注意`r_labels`。我按降序给出了标签。为什么呢？因为最近值表示自客户最后一次订单以来经过了多少时间。因此，值越小，客户对品牌的参与度越高。现在，让我们创建一个新列以指示组标签。

```py
# make a new column for group labels
rfm['R'] = r_groups.values
rfm['F'] = f_groups.values
rfm['M'] = m_groups.values
# sum up the three columns
rfm['RFM_Segment'] = rfm.apply(lambda x: str(x['R']) + str(x['F']) + str(x['M']), axis = 1)
rfm['RFM_Score'] = rfm[['R', 'F', 'M']].sum(axis = 1)
rfm.head()

```

![RFM segmentation](../Images/7998d13c65a432e39e4cae794cadebd1.png)

我将所有三个标签附在一个单元格中，称为`RFM_Segment`。这样，我们可以轻松检查客户属于哪个级别或段。`RFM_Score`是这三个值的总和。它不一定非得是总和，均值也是可能的。此外，我们还可以通过以下方式，使用均值或计数值来捕捉进一步的模式。

```py
# calculate average values for each RFM
rfm_agg = rfm.groupby('RFM_Score').agg({
    'Recency' : 'mean',
    'Frequency' : 'mean',
    'Monetary' : ['mean', 'count']
})
rfm_agg.round(1).head()

```

![RFM_score](../Images/066155e851839111bdb97293bdb92917.png)

`RFM_Score`将是客户参与度或忠诚度的总分。将这三个值加在一起，我们最终可以将客户分类为“金”、“银”、“铜”和“绿”。

```py
# assign labels from total score
score_labels = ['Green', 'Bronze', 'Silver', 'Gold']
score_groups = pd.qcut(rfm.RFM_Score, q = 4, labels = score_labels)
rfm['RFM_Level'] = score_groups.values
rfm.head()

```

![cohort analysis with RFM values](../Images/18d7bfac61225ee0d20d57b5a7a7b654.png)

太好了！我们已经完成了一个使用RFM值的群体分析。我们识别了我们的“金鹅”以及需要额外关注的地方。现在为什么不尝试一种不同的方法进行客户细分，并比较这两种结果呢？

* * *

## 我们的前三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业轨道。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌IT支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织的IT需求

* * *

### 更多相关主题

+   [最后呼叫：Stefan Krawcyzk的《掌握MLOps》直播小组](https://www.kdnuggets.com/2022/08/sphere-last-call-stefan-krawcyzk-mastering-mlops.html)

+   [使用聚类分析进行数据细分](https://www.kdnuggets.com/using-cluster-analysis-to-segment-your-data)

+   [文本分类任务的最佳架构：基准测试…](https://www.kdnuggets.com/2023/04/best-architecture-text-classification-task-benchmarking-options.html)

+   [市场数据与新闻：时间序列分析](https://www.kdnuggets.com/2022/06/market-data-news-time-series-analysis.html)

+   [最佳Python课程：分析总结](https://www.kdnuggets.com/2022/01/best-python-courses-analysis-summary.html)

+   [机器学习的甜点：NLP和文档分析中的纯方法](https://www.kdnuggets.com/2022/05/machine-learning-sweet-spot-pure-approaches-nlp-document-analysis.html)
