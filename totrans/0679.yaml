- en: Basic Image Data Analysis Using Python – Part 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2018/10/basic-image-analysis-python-p4.html](https://www.kdnuggets.com/2018/10/basic-image-analysis-python-p4.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [comments](#comments)'
  prefs: []
  type: TYPE_IMG
- en: '![Image data analysis Python fig 1](../Images/d57ffadf2576d47ee22925b301e894d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Previously, we’ve seen some of the very basic image analysis operations in Python.
    In this last part of basic image analysis, we’ll go through some of the following
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following contents is the reflection of my completed academic image processing
    course in the previous term. So, I am not planning on putting anything into production
    sphere. Instead, the aim of this article is to try and realize the fundamentals
    of a few basic image processing techniques. For this reason, I am going to stick
    to using [**SciKit-Image**](https://scikit-image.org/) - [**numpy**](http://www.numpy.org/) mainly
    to perform most of the manipulations, although I will use other libraries now
    and then rather than using most wanted tools like [**OpenCV**](https://opencv.org/) :'
  prefs: []
  type: TYPE_NORMAL
- en: 'I wanted to complete this series into two section but due to fascinating contents
    and its various outcome, I have to split it into four parts. You can find the
    first three here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part 1](https://www.kdnuggets.com/2018/07/basic-image-data-analysis-numpy-opencv-p1.html)
    | [Part 2](https://www.kdnuggets.com/2018/07/image-data-analysis-numpy-opencv-p2.html)
    | [Part 3](https://www.kdnuggets.com/2018/09/image-data-analysis-python-p3.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Thresholding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ostu’s Method**'
  prefs: []
  type: TYPE_NORMAL
- en: Thresholding is a very basic operation in image processing. Converting a greyscale
    image to monochrome is a common image processing task. And, a good algorithm always
    begins with a good basis!
  prefs: []
  type: TYPE_NORMAL
- en: Otsu thresholding is a simple yet effective global automatic thresholding method
    for binarizing grayscale images such as foregrounds and backgrounds. In image
    processing, Otsu’s thresholding method (1979) is used for automatic **binarization** level
    decision, based on the shape of the **histogram**. It is based entirely on computation
    performed on the histogram of an image.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm assumes that the image is composed of two basic classes: **Foreground** and **Background**.
    It then computes an optimal threshold value that minimizes the weighted within
    class variances of these two classes.
  prefs: []
  type: TYPE_NORMAL
- en: Otsu threshold is used in many applications from medical imaging to low-level
    computer vision. It’s many advantages and assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Mathematical Formulation](https://iphton.github.io/iphton.github.io/Image-Processing-in-Python-Part-2/#5-bullet) of
    Otsu method. This will redirect you to my homepage where we explained mathematics
    behind Otsu method.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we incorporate a little math into that simple step-wise algorithm, such
    an explanation evolves:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute histogram and probabilities of each intensity level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up initial wiand μi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step through from threshold **t = 0 **to **t = L-1**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: update: wi and μi
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: compute: σ2b(t)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Desired threshold corresponds to the maximum value of σ2b(t).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Image data analysis Python fig 2](../Images/ea7b345bb043849dbd160e1398ef47ac.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Image data analysis Python fig 3](../Images/16c258ad0b5c430e2605845ba24097a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Nice but not Great. Otsu’s method exhibits the relatively good performance if
    the histogram can be assumed to have **bimodal distribution** and assumed to possess
    a deep and sharp valley between two peaks.
  prefs: []
  type: TYPE_NORMAL
- en: So, now if the object area is small compared with the background area, the histogram
    no longer exhibits bimodality and if the variances of the object and the background
    intensities are large compared to the mean difference, or the image is severely
    corrupted by additive noise, the sharp valley of the gray level histogram is degraded.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the possibly incorrect threshold determined by Otsu’s method results
    in the segmentation error. But we can further [improve Otsu’s method](https://en.wikipedia.org/wiki/Otsu%27s_method#Improvements).
  prefs: []
  type: TYPE_NORMAL
- en: '**KMeans Clustering**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: k-means clustering is a method of [vector quantization](https://en.wikipedia.org/wiki/Vector_quantization),
    originally from signal processing, that is popular for [cluster analysis](https://en.wikipedia.org/wiki/Cluster_analysis) in [data
    mining](https://en.wikipedia.org/wiki/Data_mining).
  prefs: []
  type: TYPE_NORMAL
- en: In Otsu thresholding, we found the threshold which minimized the intra-segment
    pixel variance. So, rather than looking for a threshold from a gray level image,
    we can look for clusters in color space, and by doing so we end up with the [K-means
    clustering](https://en.wikipedia.org/wiki/K-means_clustering) technique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Image data analysis Python fig 4](../Images/e0c6906b53ae59c7e7ccfea9d4ef17b6.png)'
  prefs: []
  type: TYPE_IMG
- en: For clustering the image, we need to convert it into a two-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we use [scikit-learn’s cluster](http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)
    method to create clusters. We pass **n_clusters** as 5 to form five clusters.
    The clusters appear in the resulting image, dividing it into five parts with distinct
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: The clustering number 5 was chosen heuristically for this demonstration. One
    can change the number of clusters to visually validate image with different colors
    and decide that closely matches the required number of clusters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the clusters are formed, we can recreate the image with the cluster centers
    and labels to display the image with grouped patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Image data analysis Python fig 5](../Images/eb3e583500ef6bd783f1481e716410b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Line Detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Hough Transform**'
  prefs: []
  type: TYPE_NORMAL
- en: Hough Transform is a popular technique to detect any shape if we can represent
    that shape in mathematical form. It can detect the shape even if it is broken
    or distorted a little bit. We won’t go too deeper to analyze the mechanism of
    Hough transform rather than giving intuitive mathematical description before implementing
    it on code and also provide some resource to understand it more in details.
  prefs: []
  type: TYPE_NORMAL
- en: '[Mathematical Formulation of Hough Transform](https://iphton.github.io/iphton.github.io/Image-Processing-in-Python-Part-2/#7-bullet).
    This will redirect you to my homepage where we explained mathematics behind Hough
    Transform method.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image data analysis Python fig 6](../Images/268cf721de42490cda25029da2520da4.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: Corner or edge detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ρrange and θ range creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ρ : -Dmax to Dmax'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'θ : -90 to 90'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hough accumulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D array with the number of rows equal to the number of ρvalues and the number
    of columns equal to the number of θ
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Voting in the accumulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each edge point and for each θ value, find the nearest ρvalue and increment
    that index in the accumulator.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Peak finding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local maxima in the accumulator indicate the parameters of the most prominent
    lines in the input image.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Edge Detection**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Edge detection is an image processing technique for finding the boundaries of
    objects within images. It works by detecting discontinuities in brightness. Common
    edge detection algorithms include
  prefs: []
  type: TYPE_NORMAL
- en: Sobel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canny
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prewitt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roberts and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fuzzy logic methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, We’ll cover one of the most popular methods, which is the **Canny Edge
    Detection**.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Canny Edge Detection](https://en.wikipedia.org/wiki/Canny_edge_detector#Process_of_Canny_edge_detection_algorithm)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A multi-stage edge detection operation capable of detecting a wide range of
    edges in images. Now, the Process of Canny edge detection algorithm can be broken
    down into 5 different steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply Gaussian Filter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the intensity gradients
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply non-maximum suppression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply double threshold
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Track edge by hysteresis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s understand each of them intuitively. For a more comprehensive overview,
    please check the given link at the end of this article. However, this article
    is already becoming too big, so we decide not to provide the full implementation
    of code here rather than giving an intuitive overview of an algorithm of that
    code. But one can skip and jump to the [repo](https://github.com/iphton/Image-Data-Analysis-Using-Pythons/tree/gh-pages/Segmentation/Object%20Detection/Canny%20Edge%20Detector) for
    the code :)
  prefs: []
  type: TYPE_NORMAL
- en: '[The process](https://iphton.github.io/iphton.github.io/Image-Processing-in-Python-Part-2/#8-bullet) of
    Canny Edge Detection. . This will redirect you to my homepage where we explained
    mathematics behind Canny Edge method.'
  prefs: []
  type: TYPE_NORMAL
- en: At that ends the 4-part series on Basic Image-Processing in Python. I hope everyone
    was able to follow along, and if you feel that I have done an important mistake,
    please let me know in the comments!
  prefs: []
  type: TYPE_NORMAL
- en: The entire source code is available on : [GitHub.](https://github.com/iphton/Image-Data-Analysis-Using-Pythons)
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Basic Image Data Analysis Using Numpy and OpenCV – Part 1](https://www.kdnuggets.com/2018/07/basic-image-data-analysis-numpy-opencv-p1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Basic Image Processing in Python – Part 2](https://www.kdnuggets.com/2018/07/image-data-analysis-numpy-opencv-p2.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Basic Image Data Analysis Using Python – Part 3](https://www.kdnuggets.com/2018/09/image-data-analysis-python-p3.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[KDnuggets News, June 29: 20 Basic Linux Commands for Data Science…](https://www.kdnuggets.com/2022/n26.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[It''s alive! Build your first robots with Python and some cheap,…](https://www.kdnuggets.com/2023/06/manning-build-first-robots-python-cheap-basic-components.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Guide to Train an Image Classification Model Using Tensorflow](https://www.kdnuggets.com/2022/12/guide-train-image-classification-model-tensorflow.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How I Did Automatic Image Labeling Using Grounding DINO](https://www.kdnuggets.com/2023/05/automatic-image-labeling-grounding-dino.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Implement Agentic RAG Using LangChain: Part 1](https://www.kdnuggets.com/how-to-implement-agentic-rag-using-langchain-part-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The 8 Basic Statistics Concepts for Data Science](https://www.kdnuggets.com/2020/06/8-basic-statistics-concepts.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
