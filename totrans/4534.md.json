["```py\nimport warnings\nwarnings.filterwarnings('ignore')\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nplt.style.use('fivethirtyeight')\n# Above is a special style template for matplotlib, highly useful for visualizing time series data\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 10, 7df = pd.read_csv('/Users/.../.../.../Electric_consumption.csv')\n```", "```py\ndf.columns=['Date', 'Consumption']\ndf=df.dropna()\ndf['Date'] = pd.to_datetime(df['Date'])\ndf.set_index('Date', inplace=True) #set date as index\ndf.head()\n```", "```py\nplt.xlabel(\"Date\")\nplt.ylabel(\"Consumption\")\nplt.title(\"production graph\")\nplt.plot(df)\n```", "```py\ndf.plot(style='k.')\nplt.show()\n```", "```py\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nresult = seasonal_decompose(df, model='multiplicative')\nresult.plot()\nplt.show()\n```", "```py\nfrom statsmodels.tsa.stattools import adfuller\ndef test_stationarity(timeseries):\n    #Determing rolling statistics\n    rolmean = timeseries.rolling(12).mean()\n    rolstd = timeseries.rolling(12).std()\n    #Plot rolling statistics:\n    plt.plot(timeseries, color='blue',label='Original')\n    plt.plot(rolmean, color='red', label='Rolling Mean')\n    plt.plot(rolstd, color='black', label = 'Rolling Std')\n    plt.legend(loc='best')\n    plt.title('Rolling Mean and Standard Deviation')\n    plt.show(block=False)\n\n    #perform dickey fuller test  \n    print(\"Results of dickey fuller test\")\n    adft = adfuller(timeseries['Consumption'],autolag='AIC')\n    # output for dft will give us without defining what the values are.\n    #hence we manually write what values does it explains using a for loop\n    output = pd.Series(adft[0:4],index=['Test Statistics','p-value','No. of lags used','Number of observations used'])\n    for key,values in adft[4].items():\n        output['critical value (%s)'%key] =  values\n    print(output)\n\ntest_stationarity(df)\n```", "```py\ndf_log = np.log(df)\nmoving_avg = df_log.rolling(12).mean()\nstd_dev = df_log.rolling(12).std()\nplt.plot(df_log)\nplt.plot(moving_avg, color=\"red\")\nplt.plot(std_dev, color =\"black\")\nplt.show()\n```", "```py\ndf_log_moving_avg_diff = df_log-moving_avg\ndf_log_moving_avg_diff.dropna(inplace=True)\n```", "```py\ntest_stationarity(df_log_moving_avg_diff)\n```", "```py\nweighted_average = df_log.ewm(halflife=12, min_periods=0,adjust=True).mean()\n```", "```py\nlogScale_weightedMean = df_log-weighted_average\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 10,6\ntest_stationarity(logScale_weightedMean)\n```", "```py\ndf_log_diff = df_log - df_log.shift()\nplt.title(\"Shifted timeseries\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Consumption\")\nplt.plot(df_log_diff)#Let us test the stationarity of our resultant series\ndf_log_diff.dropna(inplace=True)test_stationarity(df_log_diff)\n```", "```py\nfrom chart_studio.plotly import plot_mpl\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nresult = seasonal_decompose(df_log, model='additive', freq = 12)\nresult.plot()\nplt.show()trend = result.trend\ntrend.dropna(inplace=True)seasonality = result.seasonal\nseasonality.dropna(inplace=True)residual = result.resid\nresidual.dropna(inplace=True)test_stationarity(residual)\n```", "```py\nfrom statsmodels.tsa.stattools import acf,pacf\n# we use d value here(data_log_shift)\nacf = acf(df_log_diff, nlags=15)\npacf= pacf(df_log_diff, nlags=15,method='ols')#plot PACF\nplt.subplot(121)\nplt.plot(acf) \nplt.axhline(y=0,linestyle='-',color='blue')\nplt.axhline(y=-1.96/np.sqrt(len(df_log_diff)),linestyle='--',color='black')\nplt.axhline(y=1.96/np.sqrt(len(df_log_diff)),linestyle='--',color='black')\nplt.title('Auto corellation function')\nplt.tight_layout()#plot ACF\nplt.subplot(122)\nplt.plot(pacf) \nplt.axhline(y=0,linestyle='-',color='blue')\nplt.axhline(y=-1.96/np.sqrt(len(df_log_diff)),linestyle='--',color='black')\nplt.axhline(y=1.96/np.sqrt(len(df_log_diff)),linestyle='--',color='black')\nplt.title('Partially auto corellation function')\nplt.tight_layout()\n```", "```py\nfrom statsmodels.tsa.arima_model import ARIMA\nmodel = ARIMA(df_log, order=(3,1,3))\nresult_AR = model.fit(disp = 0)\nplt.plot(df_log_diff)\nplt.plot(result_AR.fittedvalues, color='red')\nplt.title(\"sum of squares of residuals\")\nprint('RSS : %f' %sum((result_AR.fittedvalues-df_log_diff[\"Consumption\"])**2))\n```", "```py\nresult_AR.plot_predict(1,500)\nx=result_AR.forecast(steps=200)\n```"]