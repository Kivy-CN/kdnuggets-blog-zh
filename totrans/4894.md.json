["```py\n1.  import numpy  \n2.    \n3.  def activation_function(inpt):  \n4.      if(inpt > 250):  \n5.          return 250 # clip the result to 250  \n6.      else:  \n7.          return inpt # just return the input  \n8.    \n9.  def prediction_error(desired, expected):  \n10\\.     return numpy.abs(numpy.mean(desired-expected)) # absolute error  \n11\\.   \n12\\. def update_weights(weights, predicted, idx):  \n13\\.     weights = weights + .00001*(desired_output[idx] - predicted)*inputs[idx] # updating weights  \n14\\.     return weights # new updated weights  \n15\\.   \n16\\. weights = numpy.array([0.05, .1]) #bias & weight of input  \n17\\. inputs = numpy.array([60, 40, 100, 300, -50, 310]) # training inputs  \n18\\. desired_output = numpy.array([60, 40, 150, 250, -50, 250]) # training outputs  \n19\\.   \n20\\. def training_loop(inpt, weights):  \n21\\.     error = 1  \n22\\.     idx = 0 # start by the first training sample  \n23\\.     iteration = 0 #loop iteration variable  \n24\\.     while(iteration < 2000 or error >= 0.01): #while(error >= 0.1):  \n25\\.         predicted = activation_function(weights[0]*1+weights[1]*inputs[idx])  \n26\\.         error = prediction_error(desired_output[idx], predicted)  \n27\\.         weights = update_weights(weights, predicted, idx)  \n28\\.         idx = idx + 1 # go to the next sample  \n29\\.         idx = idx % inputs.shape[0] # restricts the index to the range of our samples  \n30\\.         iteration = iteration + 1 # next iteration  \n31\\.     return error, weights  \n32\\.   \n33\\. error, new_weights = training_loop(inputs, weights)  \n34\\. print('--------------Final Results----------------')  \n35\\. print('Learned Weights : ', new_weights)  \n36\\. new_inputs = numpy.array([10, 240, 550, -160])  \n37\\. new_outputs = numpy.array([10, 240, 250, -160])  \n38\\. for i in range(new_inputs.shape[0]):  \n39\\.     print('Sample ', i+1, '. Expected = ', new_outputs[i], ' , \n          Predicted = ', activation_function(new_weights[0]*1+new_weights[1]*new_inputs[i]))  \n\n```", "```py\nweights = weights + (desired_output[idx] - predicted)*inputs[idx]\n\n```", "```py\n(desired_output[idx] - predicted)*inputs[idx]\n\n```"]