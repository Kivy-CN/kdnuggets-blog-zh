["```py\n$ pip install tensorflow, numpy, keras, sklearn, matplotlib\n```", "```py\nfrom numpy import *\nfrom pandas import *\nimport matplotlib.pyplot as plotter\n\n# Split the data into training and testing sets.\nfrom sklearn.model_selection import train_test_split\n\n# Libraries used to evaluate our trained model.\nfrom sklearn.metrics import classification_report, confusion_matrix\nimport keras\n\n# Loading our dataset.\nfrom keras.datasets import cifar10\n\n# Used for data augmentation.\nfrom keras.preprocessing.image import ImageDataGenerator\n\n# Below are some layers used to train convolutional nueral network.\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Activation\nfrom keras.layers import Conv2D, MaxPooling2D, GlobalMaxPooling2D, Flatten\n```", "```py\n# number of classes\nnc = 10\n\n(training_data, training_label), (testing_data, testing_label) = cifar10.load_data()\n(\n    (training_data),\n    (validation_data),\n    (training_label),\n    (validation_label),\n) = train_test_split(training_data, training_label, test_size=0.2, random_state=42)\ntraining_data = training_data.astype(\"float32\")\ntesting_data = testing_data.astype(\"float32\")\nvalidation_data = validation_data.astype(\"float32\")\n```", "```py\n# Normalization\ntraining_data /= 255\ntesting_data /= 255\nvalidation_data /= 255\n\n# One Hot Encoding\ntraining_label = keras.utils.to_categorical(training_label, nc)\ntesting_label = keras.utils.to_categorical(testing_label, nc)\nvalidation_label = keras.utils.to_categorical(validation_label, nc)\n\n# Printing the dataset\nprint(\"Training: \", training_data.shape, len(training_label))\nprint(\"Validation: \", validation_data.shape, len(validation_label))\nprint(\"Testing: \", testing_data.shape, len(testing_label))\n```", "```py\nTraining:  (40000, 32, 32, 3) 40000\nValidation:  (10000, 32, 32, 3) 10000\nTesting:  (10000, 32, 32, 3) 10000\n```", "```py\nmodel = Sequential()\n\nmodel.add(\n    Conv2D(32, (3, 3), padding=\"same\", activation=\"relu\", input_shape=(32, 32, 3))\n)\nmodel.add(Conv2D(32, (3, 3), padding=\"same\", activation=\"relu\"))\nmodel.add(MaxPooling2D((2, 2)))\nmodel.add(Dropout(0.25))\n\nmodel.add(Conv2D(64, (3, 3), padding=\"same\", activation=\"relu\"))\nmodel.add(Conv2D(64, (3, 3), padding=\"same\", activation=\"relu\"))\nmodel.add(MaxPooling2D((2, 2)))\nmodel.add(Dropout(0.25))\n\nmodel.add(Conv2D(96, (3, 3), padding=\"same\", activation=\"relu\"))\nmodel.add(Conv2D(96, (3, 3), padding=\"same\", activation=\"relu\"))\nmodel.add(MaxPooling2D((2, 2)))\n\nmodel.add(Flatten())\nmodel.add(Dropout(0.4))\nmodel.add(Dense(256, activation=\"relu\"))\nmodel.add(Dropout(0.4))\nmodel.add(Dense(128, activation=\"relu\"))\nmodel.add(Dropout(0.4))\nmodel.add(Dense(nc, activation=\"softmax\"))\n```", "```py\n# initiate Adam optimizer\nopt = keras.optimizers.Adam(lr=0.0001)\n\nmodel.compile(loss=\"categorical_crossentropy\", optimizer=opt, metrics=[\"accuracy\"])\n# obtaining the summary of the model\nmodel.summary()\n```", "```py\naugmentor = ImageDataGenerator(\n    width_shift_range=0.4,\n    height_shift_range=0.4,\n    horizontal_flip=False,\n    vertical_flip=True,\n)\n\n# fitting in augmentor\naugmentor.fit(training_data)\n\n# obtaining the history\nhistory = model.fit(\n    augmentor.flow(training_data, training_label, batch_size=32),\n    epochs=100,\n    validation_data=(validation_data, validation_label),\n)\n```", "```py\nmodel.evaluate(testing_data, testing_label)\n```", "```py\n313/313 [==============================] - 2s 5ms/step - loss: 0.8554 - accuracy: 0.7545\n[0.8554493188858032, 0.7545000195503235]\n```", "```py\ndef acc_loss_curves(result, epochs):\n    acc = result.history[\"accuracy\"]\n    # obtaining loss and accuracy\n    loss = result.history[\"loss\"]\n    # declaring values of loss and accuracy\n    val_acc = result.history[\"val_accuracy\"]\n    val_loss = result.history[\"val_loss\"]\n    # plotting the figure\n    plotter.figure(figsize=(15, 5))\n    plotter.subplot(121)\n    plotter.plot(range(1, epochs), acc[1:], label=\"Train_acc\")\n    plotter.plot(range(1, epochs), val_acc[1:], label=\"Val_acc\")\n    # giving title to plot\n    plotter.title(\"Accuracy over \" + str(epochs) + \" Epochs\", size=15)\n    plotter.legend()\n    plotter.grid(True)\n    # passing value 122\n    plotter.subplot(122)\n    # using train loss\n    plotter.plot(range(1, epochs), loss[1:], label=\"Train_loss\")\n    plotter.plot(range(1, epochs), val_loss[1:], label=\"Val_loss\")\n    # using ephocs\n    plotter.title(\"Loss over \" + str(epochs) + \" Epochs\", size=15)\n    plotter.legend()\n    # passing true values\n    plotter.grid(True)\n    # printing the graph\n    plotter.show()\n\nacc_loss_curves(history, 100)\n```"]