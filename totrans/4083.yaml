- en: Getting Started with Python Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2023/02/getting-started-python-generators.html](https://www.kdnuggets.com/2023/02/getting-started-python-generators.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Getting Started with Python Generators](../Images/becf600d7f768a14d0dbe4156ec7bdeb.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to work with Python generators can help you write more Pythonic
    and efficient code. Using generators can be especially useful when you need to
    work with large sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, you’ll learn how to use generators in Python by defining generator
    functions and generator expressions. You’ll then learn how using generators can
    be a memory-efficient choice.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Generator Functions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how a generator function is different from a normal Python function,
    let's start with a regular Python function and then rewrite it as a generator
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function `get_cubes()`. It takes in a number `num` as
    the argument and returns the list of cubes of the numbers 0, 1, 2 up to num -1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above function works by looping through the list of numbers 0, 1, 2, up
    to num -1 and appending the cube of each number to the `cubes` list. Finally,
    it returns the `cubes` list.
  prefs: []
  type: TYPE_NORMAL
- en: You can already tell this is not the recommended Pythonic way to create a new
    list. Instead of looping through using a for loop and using the `append()` method,
    you can use a [**list comprehension**](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the equivalent of the function `get_cubes()` that uses list comprehension
    instead of an explicit for loop and the `append()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let’s rewrite this function as a generator function. The following code
    snippet shows how the `get_cubes()` function can be rewritten as a generator function
    `get_cubes_gen()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From the function definition, you can tell the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: We have the *yield* keyword instead of the return keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are *not* returning a sequence or populating an iterable such as a Python
    list to get the sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So how does the generator function work? To understand, let’s call the above-defined
    functions and take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Function Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us call the `get_cubes()` and `get_cubes_gen()` functions and see the differences
    in the respective function calls.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `get_cubes()` function  with the number 6 as the argument,
    we get the list of cubes as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now call the generator the function with the same number 6 as the argument and
    see what happens. You can call the generator function `get_cubes_gen()` just the
    way you would call a normal Python function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you print out the value of `cubes_gen()`, you’ll get a generator object as
    opposed to the entire resultant list that contains the cube of each of the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**So how do you access the elements of the sequence?** To code along, start
    a Python REPL and import the generator function. Here, I have my code in the *gen_example.py*
    file, so I’m importing the `get_cubes_gen()` function from the `get_cubes_gen()`
    module.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can call `next()` with the generator object as the argument. Doing so returns
    0, the first element in the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now when you call `next()` again, you’ll get the next element in the sequence,
    which is 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the subsequent elements in the sequence, you can continue to call
    `next()`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For `num = 6`, the resultant sequence is the cube of the numbers 0, 1, 2, 3,
    4, and 5\. Now that we’ve reached 125, the cube of 5, what happens when you call
    next again?
  prefs: []
  type: TYPE_NORMAL
- en: We see that a **StopIteration** exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the generator function executes until the execution reaches
    the *yield* statement, and the control returns to the call site. However, unlike
    a normal Python function that returns control to the call site once the *return*
    statement, a generator function suspends execution temporarily. And it keeps track
    of its state that helps us get the subsequent elements by calling `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also loop through the generator object using a for loop. The control
    exits the loop when the **StopIteration** exception is raised (that’s how for
    loops work under the hood).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Generator Expressions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common way to use generators is using **generator expressions**. Here’s 
    the generator expression equivalent of the `get_cubes_gen()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The above generator expression may look similar to list comprehension, except
    for the use of () in place of []. However, as discussed, the following key differences
    hold:'
  prefs: []
  type: TYPE_NORMAL
- en: A list comprehension expression generates the entire list and stores it in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generator expression, on the other hand, yields the elements of the sequence
    on demand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python Generators vs. Lists: Understanding Performance Improvements'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sample function call in the previous section, we generated a sequence
    of cubes of the numbers zero through five. For such small sequences, using a generator
    may not give you significant performance gains. However, generators are certainly
    a memory-efficient choice when you work with longer sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, generate the sequence of cubes for value of `num` in
    a  wider range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us print out the size of the size in memory of the static list and
    the generator object for the when `num` changes (as in the snippet above):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we see that the generator object has a constant memory footprint
    unlike a list where the memory grows with `num`.This is because a generator performs
    *lazy evaluation* and *yields* the subsequent values in the sequence on demand.
    It does not compute all the values ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a better idea of how the sizes of the static list and generator change
    with change in the value of num, we can plot the values of `num` and the sizes
    of the list and the generators, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting Started with Python Generators](../Images/6904c75748fc0fcdd820c52c9c3a5653.png)'
  prefs: []
  type: TYPE_IMG
- en: In the graph above, we see that when `num` increases, the size of the generator
    is constant, whereas the size of the list is prohibitively large.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this tutorial, you’ve learned how generators work in Python. The next time
    you need to work with a large file or dataset, you can consider using generators
    to iterate efficiently over it. When you use generators, you can iterate over
    the generator object, read in a line or a small chunk, process it or apply transformations
    as needed—without having to store the original dataset in memory. However, keep
    in mind that you cannot store such values in memory for processing at a later
    time. If you need to, you’ll have to use lists.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Bala Priya C](https://twitter.com/balawc27)** is a technical writer who
    enjoys creating long-form content. Her areas of interest include math, programming,
    and data science. She shares her learning with the developer community by authoring
    tutorials, how-to guides, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Getting Started with Python Data Structures in 5 Steps](https://www.kdnuggets.com/5-steps-getting-started-python-data-structures)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Started with Python for Data Science](https://www.kdnuggets.com/getting-started-with-python-for-data-science)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Started with PyTest: Effortlessly Write and Run Tests in Python](https://www.kdnuggets.com/getting-started-with-pytest-effortlessly-write-and-run-tests-in-python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Started with Automated Text Summarization](https://www.kdnuggets.com/2019/11/getting-started-automated-text-summarization.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Started Cleaning Data](https://www.kdnuggets.com/2022/01/getting-started-cleaning-data.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Started with SQL Cheatsheet](https://www.kdnuggets.com/2022/08/getting-started-sql-cheatsheet.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
