- en: Artificial Neural Networks Optimization using Genetic Algorithm with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html](https://www.kdnuggets.com/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [comments](/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html?page=2#comments)![practical-computer-vision-applications-deepl-learning](../Images/2d2eba3f4293703bd96266e9008105f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a previous tutorial titled "**Artificial Neural Network Implementation using
    NumPy and Classification of the Fruits360 Image Dataset**" available in my LinkedIn
    profile at this link [https://www.linkedin.com/pulse/artificial-neural-network-implementation-using-numpy-fruits360-gad](https://www.linkedin.com/pulse/artificial-neural-network-implementation-using-numpy-fruits360-gad),
    an artificial neural network (ANN) is created for classifying 4 classes of the
    Fruits360 image dataset. The source code used in this tutorial is available in
    my GitHub page here: [https://github.com/ahmedfgad/NumPyANN](https://github.com/ahmedfgad/NumPyANN)'
  prefs: []
  type: TYPE_NORMAL
- en: A quick summary of this tutorial is extracting the feature vector (360 bins
    hue channel histogram) and reducing it to just 102 element by using a filter-based
    technique using the standard deviation. Later, the ANN is built from scratch using
    NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The ANN was not completely created as just the forward pass was made ready but
    there is no backward pass for updating the network weights. This is why the accuracy
    is very low and not exceeds 45%. The solution to this problem is using an optimization
    technique for updating the network weights. This tutorial extends the previous
    one to use the genetic algorithm (GA) for optimizing the network weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth-mentioning that both the previous and this tutorial are based on
    my 2018 book cited as "**Ahmed Fawzy Gad ''Practical Computer Vision Applications
    Using Deep Learning with CNNs''. Dec. 2018, Apress, 978-1-4842-4167-7** ". The
    book is available at Springer at this link: [https://springer.com/us/book/9781484241660](https://springer.com/us/book/9781484241660).
    You can find all details within this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code used in this tutorial is available in my GitHub page here:
    [https://github.com/ahmedfgad/NeuralGenetic](https://github.com/ahmedfgad/NeuralGenetic)'
  prefs: []
  type: TYPE_NORMAL
- en: Read More about Genetic Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before starting this tutorial, I recommended reading about how the genetic
    algorithm works and its implementation in Python using NumPy from scratch based
    on my previous tutorials found at these links:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Optimization with Genetic Algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/](https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.kdnuggets.com/2018/03/introduction-optimization-with-genetic-algorithm.html](/2018/03/introduction-optimization-with-genetic-algorithm.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b](https://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.springer.com/us/book/9781484241660](https://www.springer.com/us/book/9781484241660)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Genetic Algorithm (GA) Optimization - Step-by-Step Example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.slideshare.net/AhmedGadFCIT/genetic-algorithm-ga-optimization-stepbystep-example](https://www.slideshare.net/AhmedGadFCIT/genetic-algorithm-ga-optimization-stepbystep-example)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Genetic Algorithm Implementation in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/](https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[/2018/07/genetic-algorithm-implementation-python.html](/2018/07/genetic-algorithm-implementation-python.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6](https://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/ahmedfgad/GeneticAlgorithmPython](https://github.com/ahmedfgad/GeneticAlgorithmPython)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After understanding how GA works based on numerical examples in addition to
    implementation using Python, we can start using GA to optimize the ANN by updating
    its weights (parameters).
  prefs: []
  type: TYPE_NORMAL
- en: Using GA with ANN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GA creates multiple solutions to a given problem and evolves them through a
    number of generations. Each solution holds all parameters that might help to enhance
    the results. For ANN, weights in all layers help achieve high accuracy. Thus,
    a single solution in GA will contain all weights in the ANN. According to the
    network structure discussed in the previous tutorial and given in the figure below,
    the ANN has 4 layers (1 input, 2 hidden, and 1 output). Any weight in any layer
    will be part of the same solution. A single solution to such network will contain
    a total number of weights equal to 102x150+150x60+60x4=24,540\. If the population
    has 8 solutions with 24,540 parameters per solution, then the total number of
    parameters in the entire population is 24,540x8=196,320.
  prefs: []
  type: TYPE_NORMAL
- en: '![artificial-neural-network](../Images/d3ee8682d9b41f4e59bad5b79e948a75.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the above figure, the parameters of the network are in matrix form
    because this makes calculations of ANN much easier. For each layer, there is an
    associated weights matrix. Just multiply the inputs matrix by the parameters matrix
    of a given layer to return the outputs in such layer. Chromosomes in GA are 1D
    vectors and thus we have to convert the weights matrices into 1D vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Because matrix multiplication is a good option to work with ANN, we will still
    represent the ANN parameters in the matrix form when using the ANN. Thus, matrix
    form is used when working with ANN and vector form is used when working with GA.
    This makes us need to convert the matrix to vector and vice versa. The next figure
    summarizes the steps of using
  prefs: []
  type: TYPE_NORMAL
- en: GA with ANN. This figure is referred to as the **main figure**.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure-name](../Images/57ce8711167885fdd567d24b6587d7b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Weights Matrices to 1D Vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each solution in the population will have two representations. First is a 1D
    vector for working with GA and second is a matrix to work with ANN. Because there
    are 3 weights matrices for the 3 layers (2 hidden + 1 output), there will be 3
    vectors, one for each matrix. Because a solution in GA is represented as a single
    1D vector, such 3 individual 1D vectors will be concatenated into a single 1D
    vector. Each solution will be represented as a vector of length 24,540\. The next
    Python code creates a function named **mat_to_vector()** that converts the parameters
    of all solutions within the population from matrix to vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The function accepts an argument representing the population of all solutions
    in order to loop through them and return their vector representation. At the beginning
    of the function, an empty list variable named **pop_weights_vector** is created
    to hold the result (vectors of all solutions). For each solution in matrix form,
    there is an inner loop that loops through its three matrices. For each matrix,
    it is converted into a vector using the **numpy.reshape()** function which accepts
    the input matrix and the output size to which the matrix will be reshaped. The
    variable **curr_vector** accepts all vectors for a single solution. After all
    vectors are generated, they get appended into the **pop_weights_vector** variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used the **numpy.extend()** function for vectors belonging to the
    same solution and **numpy.append()** for vectors belonging to different solutions.
    The reason is that **numpy.extend()** takes the numbers within the 3 vectors belonging
    to the same solution and concatenate them together. In other words, calling this
    function for two lists returns a new single list with numbers from both lists.
    This is suitable in order to create just a 1D chromosome for each solution. But
    **numpy.append()** will return three lists for each solution. Calling it for two
    lists, it returns a new list which is split into two sub-lists. This is not our
    objective. Finally, the function **mat_to_vector()** returns the population solutions
    as a NumPy array for easy manipulation later.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GA Steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After converting all solutions from matrices to vectors and concatenated together,
    we are ready to go through the GA steps discussed in the tutorial titled **"Introduction
    to Optimization with Genetic Algorithm"**. The steps are presented in the **main
    figure** and also summarized in the next figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![genetic-algorithm-steps](../Images/6ab6d32f52e77336c2e67f65d9e0058b.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that GA uses a fitness function to returns a fitness value for each
    solution. The higher the fitness value the better the solution. The best solutions
    are returned as parents in the **parents selection** step.
  prefs: []
  type: TYPE_NORMAL
- en: One of the common fitness functions for a classifier such as ANN is the accuracy.
    It is the ratio between the correctly classified samples and the total number
    of samples. It is calculated according to the next equation. The classification
    accuracy of each solution is calculated according to steps in the **main figure**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Equation](../Images/e8768f7eb7deeb08cb4bd8ca72e54f27.png)'
  prefs: []
  type: TYPE_IMG
- en: The single 1D vector of each solution is converted back into 3 matrices, one
    matrix for each layer (2 hidden and 1 output). Conversion takes place using a
    function called **vector_to_mat()**. It is defined in the next code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It reverses the work done previously. But there is an important question. If
    the vector of a given solution is just one piece, how we can split into three
    different parts, each part represents a matrix? The size of the first parameters
    matrix between the input layer and the hidden layer is 102x150\. When being converted
    into a vector, its length will be 15,300\. Because it is the first vector to be
    inserted in the **curr_vector** variable according to the **mat_to_vector()**
    function, then its indices start from index 0 and end at index 15,299\. The **mat_pop_weights**
    is used as an argument for the **vector_to_mat()** function in order to know the
    size of each matrix. We are not interested in using the weights from the **mat_pop_weights**
    variable but just the matrices sizes are used from it.
  prefs: []
  type: TYPE_NORMAL
- en: For the second vector in the same solution, it will be the result of converting
    a matrix of size 150x60\. Thus the vector length is 9,000\. Such a vector is inserted
    into the **curr_vector** variable just before the previous vector of length 15,300\.
    As a result, it will start from index 15,300 and ends at index 15,300+9,000-1=24,299\.
    The -1 is used because Python starts indexing at 0\. For the last vector created
    from the parameters matrix of size 60x4, its length is 240\. Because it is added
    into the **curr_vector** variable exactly after the previous vector of length
    9,000, then its index will start after it. That is its start index is 24,300 and
    its end index is 24,300+240-1=24,539\. So, we can successfully restore the vector
    into the original 3 matrices.
  prefs: []
  type: TYPE_NORMAL
- en: The matrices returned for each solution are used to predict the class label
    for each of the 1,962 samples in the used dataset to calculate the accuracy. This
    is done using 2 functions which are **predict_outputs()** and **fitness()** according
    to the next code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **predict_outputs()** function accepts the weights of a single solution,
    inputs, and outputs of the training data, and an optional parameter that specifies
    which activation function to use. It returns the accuracy of just one solution
    not all solutions within the population. It order to return the fitness value
    (i.e. accuracy) of all solutions within the population, the **fitness()** function
    loops through each solution, pass it to the **predict_outputs()** function, store
    the accuracy of all solutions into the **accuracy** array, and finally return
    such an array.
  prefs: []
  type: TYPE_NORMAL
- en: After calculating the fitness value (i.e. accuracy) for all solutions, the remaining
    steps of GA in the main figure are applied the same way done previously. The best
    parents are selected, based on their accuracy, into the mating pool. Then mutation
    and crossover variants are applied in order to produce the offspring. The population
    of the new generation is created using both offspring and parents. These steps
    are repeated for a number of generations.
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Write Clean Python Code Using Pipes](https://www.kdnuggets.com/2021/12/write-clean-python-code-pipes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building a solid data team](https://www.kdnuggets.com/2021/12/build-solid-data-team.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Makes Python An Ideal Programming Language For Startups](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Three R Libraries Every Data Scientist Should Know (Even if You Use Python)](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stop Learning Data Science to Find Purpose and Find Purpose to…](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Key Skills Needed To Become a Great Data Scientist](https://www.kdnuggets.com/2021/12/5-key-skills-needed-become-great-data-scientist.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
