- en: Software engineering fundamentals for Data Scientists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据科学家的软件工程基础
- en: 原文：[https://www.kdnuggets.com/2020/06/software-engineering-fundamentals-data-scientists.html](https://www.kdnuggets.com/2020/06/software-engineering-fundamentals-data-scientists.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2020/06/software-engineering-fundamentals-data-scientists.html](https://www.kdnuggets.com/2020/06/software-engineering-fundamentals-data-scientists.html)
- en: '[comments](#comments)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](#comments)'
- en: '![](../Images/b7d920f619a83d06ea12e871e38b632c.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b7d920f619a83d06ea12e871e38b632c.png)'
- en: '*Source: [Chris Ried](https://unsplash.com/photos/ieic5Tq8YMk) @ unsplash.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源： [Chris Ried](https://unsplash.com/photos/ieic5Tq8YMk) @ unsplash。*'
- en: '* * *'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our Top 3 Course Recommendations
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的前三个课程推荐
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity)
    - 快速进入网络安全职业轨道。'
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics)
    - 提升你的数据分析技能'
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌IT支持专业证书](https://www.kdnuggets.com/google-itsupport)
    - 支持你的组织的IT工作'
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'As a field, Data Science has caused polemic with other disciplines ever since
    it started to grow in popularity. Statisticians complain about the lack of fundamental
    statistics knowledge that’s often observed by practitioners, mathematicians argue
    against the application of tools without a solid understanding of the principles
    applied, and software engineers point at data scientists’ ignorance of basic principles
    while programming. And to be honest, they all have a point. In terms of statistics
    and maths, it is true that you need to have a solid understanding of concepts
    such as probability, algebra, and calculus. How deep that knowledge needs to be?
    Well, that depends a lot on your role, but the basics are not negotiable. A similar
    thing happens when it comes to programming; if your role implies writing production
    code, then you need to know at least the fundamentals in software engineering.
    Why? The reasons are many, but I reckon they could be summarised in a nutshell
    according to five principles:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学作为一个领域，自从它开始流行以来，就与其他学科发生了争论。统计学家抱怨从业者经常缺乏基本的统计知识，数学家则对在没有扎实理解所应用原理的情况下使用工具提出异议，而软件工程师指出数据科学家在编程时忽视基本原理。说实话，他们都有道理。在统计学和数学方面，确实需要对概率、代数和微积分等概念有扎实的理解。这些知识需要多深？这很大程度上取决于你的角色，但基本知识是不可妥协的。在编程方面也是类似的；如果你的角色涉及编写生产代码，那么你至少需要了解软件工程的基本知识。为什么？原因有很多，但我认为可以根据五个原则总结如下：
- en: '**Integrity **of the code, in terms of how well it is written, resilient to
    errors, catching exceptions, tested and being reviewed by others.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码的完整性**，包括代码编写质量、对错误的韧性、异常捕获、测试以及其他人的审查。'
- en: '**Explainability **of the code, with a proper documentation.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码的可解释性**，需附有适当的文档。'
- en: '**Velocity **of the code for it to be run in live environments.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码的速度**，以便在实时环境中运行。'
- en: '**Modularity **of your scripts and objects in order to be reusable, avoiding
    repetition and gaining efficiency across classes of your code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本和对象的模块化**以便重用，避免重复，并在你的代码类中提高效率。'
- en: '**Generosity **with your team, for them to review your code as fast as possible
    and in the future understand any piece of code written why you'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与团队的慷慨**，让他们尽快审查你的代码，并在未来理解你编写的任何代码。'
- en: In line with these points, in this story we’ll see some of the fundamentals
    that I found useful the most, not being a programmer by nature and coming into
    the field from a completely different background. They have helped to write better
    production code, saving me time, and making the life of my workmates easier when
    implementing my scripts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些要点，在这个故事中我们将看到一些我认为最有用的基础知识，作为一个天生不是程序员的人，我从完全不同的背景进入这个领域。这些知识帮助我编写更好的生产代码，为我节省了时间，并使我的同事在实现我的脚本时更轻松。
- en: The importance of writing clean code
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写干净代码的重要性
- en: '![](../Images/fe1216b521d448a294432b1746174096.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fe1216b521d448a294432b1746174096.png)'
- en: '*Source: [Oliver Hale](https://unsplash.com/photos/oTvU7Zmteic) @ unsplash.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源：[Oliver Hale](https://unsplash.com/photos/oTvU7Zmteic) @ unsplash.*'
- en: In theory, almost everything we’ll cover in this story could be considered tools
    or tips for writing cleaner code. However, in this specific section, we’ll focus
    on the strict definition of the word clean. As Robert Martin says in his book [Clean
    Code](https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882),
    even bad code can function, but if code isn’t clean, it can bring a development
    organization to its knees. How? Well, to be honest the possibilities are many,
    but just imagine the waste of time it can take to review badly written code or
    starting out in a new role just to find out that you’ll be dealing with some illegible
    code that was written ages ago. Or even worse, imagine that something breaks off,
    causing a product feature to stop working and that the person who wrote the code
    such a dirty code before you is no longer part of the company.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，我们将在这个故事中讨论的几乎所有内容都可以被视为编写更干净代码的工具或技巧。然而，在本节中，我们将重点关注“干净”一词的严格定义。正如罗伯特·马丁在他的书籍[《代码整洁之道》](https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)中所说，即使糟糕的代码也能正常运行，但如果代码不够干净，它可以让一个开发组织陷入困境。怎么做到呢？说实话，可能性有很多，但只要想象一下审查写得糟糕的代码所浪费的时间，或者在新角色中发现你需要处理一些几乎无法辨认的旧代码，都会令人感到沮丧。更糟的是，想象一下某个功能失效，导致产品特性停止工作，而在你之前写下这些脏代码的人已经不在公司了。
- en: These are all relatively common situations, but let’s be much less dramatic;
    who never wrote down some code, left it hanging for a while to work on something
    more urgent, and then when coming back to it couldn’t remember how it actually
    worked? I know it happened to me.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是相对常见的情况，但我们要少一点戏剧化；谁没有写过一些代码，然后因为更紧急的任务将它搁置一段时间，再回来时却不记得它是如何工作的呢？我知道这曾经发生在我身上。
- en: 'These are all valid reasons for making an extra effort to write better code.
    So let’s start from the basics and go through some tips for writing cleaner scripts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是让我们多花些心思编写更好代码的有效理由。因此，让我们从基础开始，了解一些编写更清洁脚本的技巧：
- en: '**Be descriptive with the names **within your code. I never forgot a concept
    I learned ages ago when I took some Java lectures at Uni: aim for your code to
    be*mnemonic*. Mnemonic refers to a system such as a pattern of letters, ideas,
    or associations that assists in remembering something. I.e., it means writing
    self-explanatory names.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在你的代码中使用描述性的名称**。我从大学学习Java课程时学到的一个概念就是：让你的代码具有*助记性*。助记性指的是一种帮助记忆的系统，比如字母、思想或关联的模式。也就是说，编写自解释的名称。'
- en: Whenever possible, **try to imply the type**. For example, for a function returning
    a boolean object, you can prefix it with is_ or has.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能**尝试隐含类型**。例如，对于返回布尔对象的函数，你可以用 is_ 或 has 前缀它。
- en: '**Avoid abbreviations and especially single letters.**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免缩写，尤其是单个字母。**'
- en: On the other hand, **avoid long names and lines**. Writing long names doesn’t
    mean being more descriptive, and in terms of the lines’ length, the guideline
    in the [PEP 8 style guide for Python Code](https://www.python.org/dev/peps/pep-0008/)
    recommends lines up to 79 characters approx.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，**避免长名称和长行**。编写长名称并不意味着更具描述性，在行长度方面，[PEP 8 Python代码风格指南](https://www.python.org/dev/peps/pep-0008/)建议每行长度最多为约79个字符。
- en: '**Don’t sacrifice clarity for consistency**. If, for example, you’ll have objects
    representing employees and a list containing them all, employee_list and employee_1
    is clearer than employees and employee_1'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要为了保持一致性而牺牲清晰性**。例如，如果你有表示员工的对象和一个包含所有员工的列表，employee_list 和 employee_1 比
    employees 和 employee_1 更加清晰。'
- en: In regards to blank lines and indentation, **make your code easier to read** separating
    sections with bank likes and using consistent indentation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于空行和缩进，**使你的代码更易读**，通过用空行分隔不同部分并使用一致的缩进来实现。
- en: The importance of writing modular code
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写模块化代码的重要性
- en: '![](../Images/13e65db455b071d50666ec8f4d63901a.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13e65db455b071d50666ec8f4d63901a.png)'
- en: '*Source: [Sharon McCutcheon](https://www.pexels.com/photo/art-materials-art-supplies-blocks-blur-1148496/) @
    pexels.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源：[Sharon McCutcheon](https://www.pexels.com/photo/art-materials-art-supplies-blocks-blur-1148496/)
    @ pexels.*'
- en: 'This one I reckon is one of the most important points for data scientists and
    data analysts and a very common source of discussion with software engineerings
    given that we’re very used to code in tools such as Jupyter Notebooks. These tools
    that are amazing for Exploratory Data Analysis, but not meant for writing production
    code. In fact, Python is by nature an object-oriented programming language, it
    is not within this scope to cover in-depth what does that means. But, in short,
    unlike procedural programming, where you code a list of instructions for a script
    to execute, object-oriented programming is about building modules with their own
    characteristics and actions. Take the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这一点对于数据科学家和数据分析师来说是最重要的，并且常常与软件工程师讨论，因为我们习惯于在 Jupyter Notebooks 等工具中编码。这些工具非常适合探索性数据分析，但不适合编写生产代码。事实上，Python
    本质上是一种面向对象的编程语言，讨论其详细含义超出了本讨论范围。但简而言之，与程序化编程不同，后者是编写一系列指令让脚本执行，面向对象编程则是构建具有自身特性和操作的模块。以下是一个例子：
- en: '![](../Images/a8ede08cba7ff915b06d51bb1e8a7d6e.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a8ede08cba7ff915b06d51bb1e8a7d6e.png)'
- en: '*Source: image created by the author.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源：由作者创建的图像。*'
- en: In practice, these characteristics are known as attributes, and the actions
    will be methods. In the example above, the objects Computer and Printer would
    be independent classes. A class is a blueprint containing the attributes and methods
    of all the objects of that specific type. I.e., all the Computers and Printers
    that we create would share the same attributes and methods. The concept behind
    this idea is called encapsulation. Encapsulation means that you can combine functions
    and data all into a single entity or module. And when you break a program into
    modules, different modules don’t need to know how something is accomplished if
    they are not responsible for doing it. And why is this useful? Well, not only
    for the code to be reusable, avoiding repetition, and gaining efficiency across
    classes of your code as mentioned before but it also makes it easier to debug
    if needed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些特性称为属性，操作称为方法。在上面的例子中，计算机和打印机将是独立的类。一个类是一个包含所有该特定类型对象的属性和方法的蓝图。即，我们创建的所有计算机和打印机都将共享相同的属性和方法。这个想法的概念叫做封装。封装意味着你可以将函数和数据组合成一个单一的实体或模块。当你将程序拆分成模块时，不同的模块无需了解如何实现某些功能，只要它们不负责执行这些功能。为什么这有用？不仅是为了代码的可重用性，避免重复，并提高代码类的效率，还使调试变得更容易。
- en: Again, this might not be relevant if all you’re doing is Exploratory Data Analysis
    within a Jupyter Notebook, but if you’re writing a script that will be part of
    a live environment, and especially as applications grow in size, it makes sense
    to split your code into separate modules. By perfecting each section of the program
    before putting all of the sections together, you not only make it easier to reuse
    individual modules in other programs, you make it easier to fix problems by being
    able to pinpoint the source of the error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你只是在 Jupyter Notebook 中进行探索性数据分析，这可能并不重要，但如果你在编写将成为实时环境的一部分的脚本，特别是随着应用程序的增长，将代码拆分成不同的模块是有意义的。在将程序的所有部分合并之前完善每个部分，不仅使在其他程序中重用单个模块变得更容易，还通过能够准确定位错误来源来更容易修复问题。
- en: 'Some further tips for writing modular code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编写模块化代码的一些进一步提示：
- en: 'DRY: Don’t Repeat Yourself'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRY：不要重复自己
- en: Using functions not only makes it less repetitive but also improves readability
    with descriptive names to understand what each module does
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数不仅减少了重复，还通过描述性名称提高了可读性，使理解每个模块的功能变得更容易。
- en: Minimize the number of entities (functions, classes, modules, etc.)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化实体的数量（函数、类、模块等）
- en: 'Single Responsibility Principle: The idea that a class should have one-and-only-one
    responsibility. Harder than one might expect.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则：一个类应该有唯一的责任。这比预期的要难。
- en: Follow the Open/Closed Principle. I.e., objects should be open for extension
    but closed for modification. The idea is to write code so that you’ll be able
    to add new functionality without changing the existing code, preventing situations
    in which a change to one of your classes also requires you to adapt all depending
    classes. [There are different ways of facing this challenge](https://stackify.com/solid-design-open-closed-principle/),
    though in Python, it’s very common to use inheritance.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循开闭原则，即对象应该对扩展开放，对修改关闭。这个理念是编写代码时，使得你能在不改变现有代码的情况下添加新功能，避免在一个类的变更同时需要调整所有依赖类的情况。[应对这一挑战的方式有很多](https://stackify.com/solid-design-open-closed-principle/)，不过在Python中，使用继承是非常常见的。
- en: Try to use less than three arguments per function. If it has many, maybe split
    it. A similar criterion applies to the length of the function; ideally, a function
    should have between 20 and 50 lines. If it has more, then you might want to break
    it into separate functions
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量每个函数使用不超过三个参数。如果参数较多，可以考虑拆分它。对函数长度也有类似标准；理想情况下，一个函数应包含20到50行代码。如果超出这个范围，可能需要将其拆分为多个函数。
- en: Mind the length of your classes as well. If a class has more than 300 lines,
    then it should probably be split into smaller classes.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样要注意类的长度。如果一个类有超过300行代码，那么它可能需要被拆分成更小的类。
- en: 'If you’re already using Python, but have none or little knowledge about object-oriented
    programming, I strongly recommend these two free courses:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在使用Python，但对面向对象编程没有或只有很少的了解，我强烈推荐这两个免费的课程：
- en: '[Object-Oriented Programming in Python](https://www.datacamp.com/courses/object-oriented-programming-in-python) at
    Datacamp'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python中的面向对象编程](https://www.datacamp.com/courses/object-oriented-programming-in-python)
    见 Datacamp'
- en: '[Intro to Object-Oriented Programming (OOP) in Python](https://realpython.com/courses/intro-object-oriented-programming-oop-python/) at [https://realpython.com/](https://realpython.com/)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python中的面向对象编程（OOP）简介](https://realpython.com/courses/intro-object-oriented-programming-oop-python/)
    见 [https://realpython.com/](https://realpython.com/)'
- en: The importance of refactoring
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构的重要性
- en: '![](../Images/bae4178d7b038c4cc46b8108bbaf8fcc.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bae4178d7b038c4cc46b8108bbaf8fcc.png)'
- en: '*Source: [RyanMcGuire](https://pixabay.com/photos/car-repair-car-workshop-repair-shop-362150/) @
    pixabay.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源： [RyanMcGuire](https://pixabay.com/photos/car-repair-car-workshop-repair-shop-362150/) @
    pixabay。*'
- en: 'Wikipedia states the definition of refactoring as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科对重构的定义如下：
- en: '*In computer programming and software design, code refactoring is the process
    of restructuring existing computer code without changing its external behaviour.
    Refactoring is intended to improve the design, structure, and/or implementation
    of the software while preserving its functionality. Potential advantages of refactoring
    may include improved code readability and reduced complexity; these can improve
    the source code’s maintainability and create a simpler, cleaner, or more expressive
    internal architecture or object model to improve extensibility.*'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在计算机编程和软件设计中，代码重构是指在不改变其外部行为的情况下重构现有计算机代码的过程。重构旨在改善软件的设计、结构和/或实现，同时保持其功能。重构的潜在优点包括提高代码可读性和减少复杂性；这些都可以提高源代码的可维护性，并创建一个更简单、更清晰或更具表现力的内部架构或对象模型，从而改善可扩展性。*'
- en: 'I reckon that the definition speaks by itself, but apart from it, we could
    add that refactoring gives us a chance to clean and modularize our code after
    we''ve got it working. It gives us as well a chance to improve the efficiency
    of our code. And what I’ve learned so far, is that when a software engineer talks
    about efficient code, they usually refer to either of these:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为定义本身就很清楚，但除此之外，我们可以补充一点：重构给我们一个机会，在代码运行后清理和模块化我们的代码。它也给了我们一个提高代码效率的机会。而我到目前为止学到的是，当一个软件工程师谈到高效代码时，他们通常指的是以下其中之一：
- en: Reducing run time
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少运行时间
- en: Reducing space in memory
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少内存占用
- en: Let’s briefly cover both points…
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论这两个要点……
- en: In my experience,** reducing the run time** of your code is something that you
    learn over time as you write more and more production code. When you’re doing
    some analysis in your Jupyter Notebook, it doesn’t matter if calculating those
    pairwise distances takes you two, five, or ten minutes. You can leave it running,
    answer some Slack messages, go to the bathroom, fill up a cup of coffee, and come
    back to see your code done. However, what happens when there’s a user waiting
    on the other side? You can’t just leave them hanging while your code compiles,
    right?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，**减少代码运行时间** 是你在编写越来越多生产代码的过程中逐渐学会的。当你在 Jupyter Notebook 中进行一些分析时，不论计算这些配对距离花费你两分钟、五分钟还是十分钟都无所谓。你可以让它运行，回答一些
    Slack 消息，去洗手间，倒杯咖啡，然后回来查看你的代码是否完成。然而，当有用户在等待时，你不能让他们一直等待你的代码编译，对吧？
- en: 'In Python, there are several ways to improve. Let’s quickly cover some of them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，有几种方法可以提高性能。我们快速回顾一下其中一些：
- en: '**Use vector operations to make your computations faster**. For example, when
    checking if elements of one array are within another, instead of writing for loops,
    you can use NumPy''s *intersect1d*. You can also use vectors to search for elements
    according to a condition in order to perform an addition or a similar operation.
    Let’s see a quick example for when we have to **iterate through a list of numbers
    and perform an operation given a condition**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用向量操作来加快计算速度**。例如，当检查一个数组的元素是否在另一个数组内时，不必编写 for 循环，你可以使用 NumPy 的 *intersect1d*。你还可以使用向量根据条件搜索元素以执行加法或类似操作。我们来看看一个快速示例，当我们需要
    **遍历一个数字列表并根据条件执行操作** 时：'
- en: 'Instead of using something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用这种方式：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Time: 3.6942789554595947 seconds'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 时间：3.6942789554595947 秒
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Time: 0.06348109245300293 seconds'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 时间：0.06348109245300293 秒
- en: More than 58 times faster!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 比之前快了 58 倍以上！
- en: 'I know that Pandas Dataframes are super easy to use, and we all Pythonistas
    love them. However, when writing production code, it is better to simply avoid
    them. Much of the operations we perform with Pandas can be done as well with Numpy.
    Let’s see some other examples:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道 Pandas Dataframes 使用起来非常方便，我们所有 Python 爱好者都喜欢它们。然而，在编写生产代码时，最好还是避免使用它们。我们用
    Pandas 执行的大部分操作也可以用 Numpy 完成。我们来看一些其他的例子：
- en: '**Sum matrix across rows according to condition**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据条件对矩阵的行进行求和**'
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code above, multiplying by a boolean array works because True corresponds
    to 1 and False to 0.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，乘以布尔数组之所以有效，是因为 True 对应 1，False 对应 0。
- en: '**Add a column according to some condition**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据某些条件添加列**'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Prints: (1000000, 21) | The new column has been added.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 打印：（1000000，21）| 新列已添加。
- en: '**Filter the table according to several conditions**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据多个条件筛选表格**'
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Prints: (55183, 21) | 55183 rows match the condition.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打印：（55183，21）| 55183 行符合条件。
- en: '**Replace elements if a condition is met**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果满足条件则替换元素**'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Apart from the code above, another great option for reducing our run time is **parallelization**.
    Parallelization implies writing a script to process data in parallel, using several
    or all the available processors in the machine. Why can this lead us to a massive
    improvement in speed? Because most of the time, our scripts compute data serially:
    they solve one problem, and then the following, and then the following, and so
    on. When we write code in Python, that’s usually what happens, and if we want
    to take advantage of parallelization, we have to be explicit about it. I’ll be
    writing an independent story about this soon, however, if you’re eager for learning
    more about it, among all the libraries available for parallelization, my favourites
    so far are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述代码，减少运行时间的另一个好方法是 **并行化**。并行化意味着编写一个脚本来并行处理数据，使用机器上的多个或所有可用处理器。这为何能显著提升速度？因为大多数情况下，我们的脚本是串行计算数据：它们解决一个问题，然后是下一个问题，如此循环。当我们用
    Python 编写代码时，通常就是这样。如果我们希望利用并行化，就必须明确这样做。我将很快写一个关于这个主题的独立故事，但如果你迫切想了解更多，在所有可用的并行化库中，到目前为止我最喜欢的是：
- en: '[Multiprocessing](https://docs.python.org/3/library/multiprocessing.html)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Multiprocessing](https://docs.python.org/3/library/multiprocessing.html)'
- en: '[Numba](https://numba.pydata.org/numba-doc/latest/user/5minguide.html)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Numba](https://numba.pydata.org/numba-doc/latest/user/5minguide.html)'
- en: 'In regards to **reducing space in memory**, reducing memory usage in Python
    is difficult, because [Python does not actually release memory back to the operating
    system](http://effbot.org/pyfaq/why-doesnt-python-release-the-memory-when-i-delete-a-large-object.htm).
    If you delete objects, then the memory is available to new Python objects, but
    it won’t be free() back to the system. Moreover, as mentioned before, Pandas is
    a great tool for Exploratory Data Analysis, but apart from being slower for production
    code, it is also quite expensive in terms of memory. However, there a few things
    we can do to keep that memory use under control:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **减少内存占用**，在 Python 中减少内存使用是困难的，因为 [Python 实际上不会将内存释放回操作系统](http://effbot.org/pyfaq/why-doesnt-python-release-the-memory-when-i-delete-a-large-object.htm)。如果你删除对象，那么内存会被新
    Python 对象使用，但不会被释放回系统。此外，正如前面提到的，Pandas 是进行探索性数据分析的好工具，但除了在生产代码中较慢之外，它在内存方面也相当昂贵。然而，我们可以做一些事情来控制内存使用：
- en: 'First thing first: if possible, **use NumPy arrays instead of Pandas** Even
    a dictionary if possible will take much less memory than a Dataframe'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先：如果可能，**使用 NumPy 数组而非 Pandas**。即使是字典，如果可能的话，也会比 Dataframe 占用更少的内存。
- en: '**Reduce the number of Pandas Dataframe**: when we’re modifying dataframes,
    instead of creating a new object, try to modify the dataframe itself using the
    parameter inplace=True, so you don’t create copies.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少 Pandas Dataframe 的数量**：在修改数据框时，尝试使用参数 inplace=True 修改数据框本身，而不是创建一个新对象，以避免生成副本。'
- en: '**Clear your history**: each time you make a change on a dataframe (e.g., df
    + 2), Python holds copies of that object in memory. You can clear that history
    by using %reset Out'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除历史记录**：每次对数据框进行更改（例如，df + 2）时，Python 会在内存中保存该对象的副本。你可以使用 %reset Out 清除这些历史记录。'
- en: '**Be aware of your data types**: object and string dtypes are much more expensive
    in terms of memory in comparison with numbers. That’s why it’s always useful to
    examine the data types of your dataframe using df.info() and cast them if possible
    using df[‘column’] = df[‘columns’].astype(type)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意数据类型**：与数字相比，object 和 string 数据类型在内存方面的开销要大得多。这就是为什么使用 df.info() 检查数据框的数据类型并在可能的情况下使用
    df[‘column’] = df[‘columns’].astype(type) 进行类型转换总是很有用的原因。'
- en: '**Use sparse matrices**: if you have a matrix with lots of null values or empty
    cells, it would be convenient to use instead a sparse matrix, that usually takes
    much less space in memory.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用稀疏矩阵**：如果你有一个包含大量空值或空单元格的矩阵，使用稀疏矩阵会更方便，它通常在内存中占用的空间要少得多。'
- en: You can do that using *scipy.sparse.csr_matrix(df.values)*
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *scipy.sparse.csr_matrix(df.values)* 来实现这一点。
- en: '**Using generators instead of objects**: generators allow you to declare a
    function that behaves like an iterator, but using the word *yield*rather than *return*.
    Instead of creating a new object (i.e., a list or a NumPy array) with all the
    calculations, generators generate a single value that’s held in memory and gets
    updated only when you ask for it. This is known as lazy evaluation. Find more
    about Generators in this great story of [Abhinav Sagar](https://towardsdatascience.com/@abhinav.sagar) in
    Towards Data Science.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用生成器而非对象**：生成器允许你声明一个像迭代器一样行为的函数，但使用 *yield* 关键字而不是 *return*。生成器不会创建一个包含所有计算的新对象（即列表或
    NumPy 数组），而是生成一个存储在内存中的单一值，并且只有在你请求时才会更新。这被称为惰性求值。更多关于生成器的信息可以在 [Abhinav Sagar](https://towardsdatascience.com/@abhinav.sagar)
    在 Towards Data Science 上的精彩文章中找到。'
- en: The importance of testing
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: '![](../Images/b0fac3f71716a374de4c187c387c41f9.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b0fac3f71716a374de4c187c387c41f9.png)'
- en: '*Source: [Pixabay](https://www.pexels.com/photo/red-and-yellow-hatchback-axa-crash-tests-163016/) at
    @ pexels.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源： [Pixabay](https://www.pexels.com/photo/red-and-yellow-hatchback-axa-crash-tests-163016/)
    在 @ pexels。*'
- en: Tests in Data Science are needed. Other software related areas usually complain
    about the lack of testing in data scientist’s code. While in other kinds of algorithms
    or scripts, the program might just stop working if there’s a mistake, in Data
    Science this is even more dangerous cause the program might actually run, but
    end up with wrong insights and recommendations due to values encoded incorrectly,
    features being used inappropriately or data breaking assumptions that the models
    are actually based on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学中的测试是必要的。其他软件相关领域通常抱怨数据科学家的代码缺乏测试。在其他算法或脚本中，如果出现错误，程序可能会停止工作，但在数据科学中，这更危险，因为程序可能会运行，但由于值编码不正确、特征使用不当或数据破坏了模型实际依赖的假设，最终可能导致错误的洞察和建议。
- en: 'There are two main concepts worth talking about when we refer to testing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到测试时，有两个主要概念值得讨论：
- en: Unit tests
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Test driven development
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Let’s start with the former. **Unit tests** are called that because they cover
    a small unit of code. The goal is to validate that each individual part of our
    code performs as designed. In object-oriented programming languages, such as Python,
    a unit can also be designed for evaluating an entire class but could be an individual
    method or function as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从前者开始。**单元测试**之所以称为单元测试，是因为它们覆盖了代码的一个小单元。目标是验证代码的每个单独部分是否按设计执行。在面向对象编程语言中，例如
    Python，单元测试也可以设计用于评估整个类，但也可以是单个方法或函数。
- en: 'Unit tests can be written from scratch. In fact, let’s do that so we can grasp
    a better understanding of how unit tests actually work:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以从头编写。实际上，让我们这样做，以便更好地理解单元测试实际是如何工作的：
- en: 'Suppose I have the following function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有以下函数：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And I want to test that the following inputs return the expected output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我想测试以下输入是否返回预期的输出：
- en: 4 and 2 return 4.5
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 和 2 返回 4.5
- en: 5 and 5 return 5.5
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 和 5 返回 5.5
- en: 4 and 8 return 9.0
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 和 8 返回 9.0
- en: 'We could perfectly write something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以完全写出这样的代码：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And then simply test our function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后简单地测试我们的函数：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Prints: *Worked as expected!*
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打印：*按预期工作！*
- en: 'However, this can get trickier with more complex functions, and when we want
    to test several functions at once, or even a class, for example. A great tool
    for unit testing without all this faff is [pytest library](https://docs.pytest.org/en/latest/getting-started.html).
    Pytest requires you to create a python script containing the function or functions
    to be tested, along with another set of functions asserting the output. The file
    needs to be saved with the prefix ‘test’, and then it just needs to be run as
    any other Python script. Pytest was originally developed to use from the command
    line, but there’s a hacky way of using it from a Jupyter Notebook if you’re still
    at early stages of a project; you can create and save a .py file using the magic
    command *%%writefile* and then simply run the script using command line statements
    directly from the notebook. Let’s see an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当函数变得更加复杂时，尤其是当我们想一次测试多个函数，甚至是一个类时，这会变得更加棘手。一个优秀的单元测试工具是[pytest library](https://docs.pytest.org/en/latest/getting-started.html)。Pytest
    要求你创建一个包含要测试的函数的 Python 脚本，并且还有另一组函数来断言输出。文件需要以“test”作为前缀保存，然后像运行其他 Python 脚本一样运行它。Pytest
    最初是为了从命令行使用而开发的，但如果你仍处于项目的早期阶段，可以使用 Jupyter Notebook 中的 hacky 方法；你可以使用魔法命令*%%writefile*
    创建并保存一个 .py 文件，然后直接从笔记本运行命令行语句来运行脚本。让我们来看一个示例：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The simply run the script:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行脚本：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And see an output like this if everything ran as expected:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期运行，你会看到这样的输出：
- en: '![](../Images/efa239201e3ca82744ad7f7d84db4362.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/efa239201e3ca82744ad7f7d84db4362.png)'
- en: In the future, I’ll write another story to talk about more complex examples
    of unit tests, and how to test an entire class if that’s what you need. But meanwhile,
    this should be more than enough to get you started and test some of your functions.
    Mind that in the examples above, I’m testing the exact number being returned,
    but you could test as well the shape of a dataframe, the length of a NumPy array,
    the type of the object returned, etc.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，我会写另一个故事来讨论更复杂的单元测试示例，以及如何测试整个类（如果这是你需要的）。但与此同时，这些示例应该足以帮助你入门并测试一些函数。请注意，在上面的示例中，我测试的是返回的确切数字，但你也可以测试数据框的形状、NumPy
    数组的长度、返回对象的类型等。
- en: The other point we mentioned before at the beginning of this chapter was **Test
    Driven Development or TDD**. This approach or methodology for testing consists
    of writing the unit tests to be performed for a piece of code, even before starting
    to develop. Next step, you’ll want to write the simplest and/or quickest piece
    of code you can as to pass the tests you wrote down initially, this will help
    you to ensure quality, by focusing on the requirements before writing your code.
    Also, it will force you to keep the code simple, clean, and testable by breaking
    it down into small chunks of code, in accordance with the test or tests are written
    initially. Once you have a piece of code that actually passes those tests, just
    then, you’ll focus on refactoring for improving the quality or further functionalities
    of your code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时提到的另一个重点是 **测试驱动开发（TDD）**。这种测试方法或方法论包括在开始开发之前编写单元测试。接下来，你将编写尽可能简单和/或快速的代码，以通过最初编写的测试，这将帮助你通过在编写代码之前专注于需求来确保质量。此外，它将强迫你保持代码简单、干净，并可测试，通过将其拆分为与最初编写的测试相符的小块代码。一旦你有了一段实际通过测试的代码，你就可以专注于重构，以提高代码质量或实现更多功能。
- en: '![](../Images/d9994ecd4b3ba3238aa4cbe5f036c495.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d9994ecd4b3ba3238aa4cbe5f036c495.png)'
- en: '*Source: [https://me.me/](https://me.me/)*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源：[https://me.me/](https://me.me/)*'
- en: A major benefit of TDD is that if in the future a change is needed in the code
    and you’re no longer working on that project, you moved on to another company
    or perhaps you are simply on holidays, knowing the tests that were written originally
    will help anyone taking the code to be sure that it won’t break anything once
    the change is done.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 的一个主要好处是，如果将来需要对代码进行更改而你不再参与该项目，可能是你转到另一家公司或只是度假，了解最初编写的测试将帮助任何接手代码的人确保更改后不会破坏任何东西。
- en: 'Some further points worth considering:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得考虑的进一步点：
- en: 'Notebooks: ideal for exploration, not ideal for TDD.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本：理想用于探索，但不适合 TDD。
- en: 'Ping pong TDD: one person writes the tests, another the code.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乒乓 TDD：一个人编写测试，另一个人编写代码。
- en: Set both performance and output metrics for your tests.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的测试设置性能和输出指标。
- en: The importance of code reviewing
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码审查的重要性
- en: '![](../Images/dd9c380898050c5dcffa3a5a687649f4.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dd9c380898050c5dcffa3a5a687649f4.png)'
- en: '*Source: [Charles Deluvio](https://unsplash.com/photos/Lks7vei-eAg) @ unsplash.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*来源： [Charles Deluvio](https://unsplash.com/photos/Lks7vei-eAg) @ unsplash。*'
- en: Code reviews benefit everyone in a team to promote best programming practices
    and prepare code for production. The main goal of code reviews is to catch errors.
    However, they are also helpful for improving readability and check that the standards
    are met among a team, so no dirty or slow code is fed into production. Beyond
    these points, code reviews are also great for sharing knowledge, as members of
    the team get to read pieces of code from people with different backgrounds and
    styles.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查对团队中的每个人都有益，以促进最佳编程实践并为生产准备代码。代码审查的主要目标是捕捉错误。然而，它们也有助于提高可读性，并检查团队中的标准是否得到遵守，以便没有肮脏或慢速的代码进入生产。除此之外，代码审查还非常适合分享知识，因为团队成员可以阅读来自不同背景和风格的人的代码片段。
- en: Nowadays, the tool that is excellent for code reviewing is the platform GitHub
    with pull requests. A pull request is a solicitude for integrating a change in
    a piece of code or an entirely new script, into a certain code environment. It
    is called pull request because their submission implies precisely requesting someone
    to pull the code you wrote into the repository.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现如今，用于代码审查的优秀工具是 GitHub 平台的拉取请求。拉取请求是将代码或全新脚本集成到某个代码环境中的请求。之所以称之为拉取请求，是因为提交时意味着要求某人将你编写的代码拉入仓库。
- en: 'From [GitHub’s documentation](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests), we
    can see their definition of a pull request:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [GitHub 的文档](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests)
    中，我们可以看到对拉取请求的定义：
- en: '*Pull requests let you tell others about changes you’ve pushed to a branch
    in a repository on GitHub. Once a pull request is opened, you can discuss and
    review the potential changes with collaborators and add follow-up commits before
    your changes are merged into the base branch.*'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*拉取请求让你能够告诉他人你已推送到 GitHub 上一个仓库分支的更改。一旦打开拉取请求，你可以与协作者讨论和审查潜在更改，并在更改合并到主分支之前添加后续提交。*'
- en: 'Pull requests are an art by themselves, and if you’re interested in learning
    more about them, [this story](https://medium.com/@hugooodias/the-anatomy-of-a-perfect-pull-request-567382bb6067) called
    “The anatomy of a perfect pull request” by [Hugo Dias](https://medium.com/@hugooodias) will
    definitely come in handy. However, here there are a few questions that you can
    ask yourself when reviewing code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求本身就是一门艺术，如果你有兴趣了解更多，可以参考 [Hugo Dias](https://medium.com/@hugooodias) 的 [这篇文章](https://medium.com/@hugooodias/the-anatomy-of-a-perfect-pull-request-567382bb6067)，标题为《完美拉取请求的解剖》。不过，在审查代码时，你可以问自己以下几个问题：
- en: '**Is the code clean and modular? **Look for duplication, whitespaces, readability,
    and modularity.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码是否干净且模块化？** 查找重复、空白、可读性和模块化。'
- en: '**Is the code efficient? **Look at loops, objects, functions structure, can
    it use multiprocessing?'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码是否高效？** 查看循环、对象、函数结构，是否可以使用多进程？'
- en: '**Is documentation effective? **Look for in-line comments, [docstrings](https://en.wikipedia.org/wiki/Docstring) and
    readme files.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档是否有效？** 查找内联注释、[docstrings](https://en.wikipedia.org/wiki/Docstring) 和
    readme 文件。'
- en: '**Has the code been tested? **Look for unit tests.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码是否经过测试？** 查找单元测试。'
- en: '**Is the **[**logging**](https://www.quora.com/What-is-Logging-in-programming) **good
    enough?** Look for clarity and right frequency of logging message.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[**日志记录**](https://www.quora.com/What-is-Logging-in-programming) **是否足够好？**
    查找日志消息的清晰度和适当频率。'
- en: '[Original](https://towardsdatascience.com/software-engineering-fundamentals-for-data-scientists-6c95316d6cc4).
    Reposted with permission.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[原文](https://towardsdatascience.com/software-engineering-fundamentals-for-data-scientists-6c95316d6cc4)。经允许转载。'
- en: '**Related:**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关内容：**'
- en: '[Software Interfaces for Machine Learning Deployment](https://www.kdnuggets.com/2020/03/software-interfaces-machine-learning-deployment.html)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[机器学习部署的软件接口](https://www.kdnuggets.com/2020/03/software-interfaces-machine-learning-deployment.html)'
- en: '[How To Unit Test Machine Learning Code](https://www.kdnuggets.com/2017/11/unit-test-machine-learning-code.html)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何对机器学习代码进行单元测试](https://www.kdnuggets.com/2017/11/unit-test-machine-learning-code.html)'
- en: '[Coding habits for data scientists](https://www.kdnuggets.com/2020/05/coding-habits-data-scientists.html)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学家的编码习惯](https://www.kdnuggets.com/2020/05/coding-habits-data-scientists.html)'
- en: More On This Topic
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多相关话题
- en: '[5 Free Online Courses to Learn Data Engineering Fundamentals](https://www.kdnuggets.com/5-free-online-courses-to-learn-data-engineering-fundamentals)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5 门免费在线课程学习数据工程基础](https://www.kdnuggets.com/5-free-online-courses-to-learn-data-engineering-fundamentals)'
- en: '[Fundamentals Of Statistics For Data Scientists and Analysts](https://www.kdnuggets.com/2023/08/fundamentals-statistics-data-scientists-analysts.html)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据科学家和分析师的统计学基础](https://www.kdnuggets.com/2023/08/fundamentals-statistics-data-scientists-analysts.html)'
- en: '[Software Developer vs Software Engineer](https://www.kdnuggets.com/2022/05/software-developer-software-engineer.html)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[软件开发者与软件工程师](https://www.kdnuggets.com/2022/05/software-developer-software-engineer.html)'
- en: '[KDnuggets News March 16, 2022: Learn Data Science Fundamentals & 5…](https://www.kdnuggets.com/2022/n11.html)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[KDnuggets 新闻 2022 年 3 月 16 日：学习数据科学基础 & 5…](https://www.kdnuggets.com/2022/n11.html)'
- en: '[How Long Does It Take to Learn Data Science Fundamentals?](https://www.kdnuggets.com/2022/03/long-take-learn-data-science-fundamentals.html)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[学习数据科学基础需要多长时间？](https://www.kdnuggets.com/2022/03/long-take-learn-data-science-fundamentals.html)'
- en: '[5 Free Online Courses to Learn Data Science Fundamentals](https://www.kdnuggets.com/5-free-online-courses-to-learn-data-science-fundamentals)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5 门免费在线课程学习数据科学基础](https://www.kdnuggets.com/5-free-online-courses-to-learn-data-science-fundamentals)'
