- en: 'SQL For Data Science: Understanding and Leveraging Joins'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 数据科学：理解和利用连接
- en: 原文：[https://www.kdnuggets.com/2023/08/sql-data-science-understanding-leveraging-joins.html](https://www.kdnuggets.com/2023/08/sql-data-science-understanding-leveraging-joins.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.kdnuggets.com/2023/08/sql-data-science-understanding-leveraging-joins.html](https://www.kdnuggets.com/2023/08/sql-data-science-understanding-leveraging-joins.html)
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/86deadfbec258a1269997f42cd07dad7.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 数据科学：理解和利用连接](../Images/86deadfbec258a1269997f42cd07dad7.png)'
- en: Image by Author
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: Data science is an interdisciplinary field that relies heavily on extracting
    insights and making informed decisions from vast amounts of data. One of the fundamental
    tools in a data scientist's toolbox is SQL (Structured Query Language), a programming
    language designed for managing and manipulating relational databases.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学是一个跨学科领域，极大依赖从大量数据中提取见解和做出明智决策。数据科学家工具箱中的基本工具之一是 SQL（结构化查询语言），这是一种用于管理和操作关系型数据库的编程语言。
- en: '* * *'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our Top 3 Course Recommendations
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的前三大课程推荐
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity)
    - 快速进入网络安全职业。'
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics)
    - 提升你的数据分析技能'
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport)
    - 支持你的组织的 IT'
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'In this article, I will focus on one of the most powerful features of SQL:
    joins.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我将重点讲解 SQL 的一个强大功能：连接。
- en: What Are Joins in SQL?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 SQL 连接？
- en: SQL Joins allow you to combine data from multiple database tables based on common
    columns. That way, you can merge information together and create meaningful connections
    between related datasets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 连接允许你基于公共列合并多个数据库表中的数据。这样，你可以将信息汇集在一起，并在相关数据集之间创建有意义的联系。
- en: Types of Joins in SQL
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 中的连接类型
- en: 'There are several [types of SQL joins](https://www.stratascratch.com/blog/different-types-of-sql-joins-that-you-must-know/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种 [SQL 连接类型](https://www.stratascratch.com/blog/different-types-of-sql-joins-that-you-must-know/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)：
- en: Inner join
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内连接
- en: Left outer join
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左外连接
- en: Right outer join
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右外连接
- en: Full outer join
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全外连接
- en: Cross join
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉连接
- en: Let’s explain each type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一解释每种类型。
- en: SQL Inner Join
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 内连接
- en: An inner join returns only the rows where there is a match in both tables being
    joined. It combines rows from two tables based on a shared key or column, discarding
    non-matching rows.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内连接仅返回两个连接表中都有匹配的行。它根据共享的键或列组合来自两个表的行，丢弃不匹配的行。
- en: We visualize this in the following way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下方式可视化它。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/44d24b263f1f47b1285c60cc487cdfe3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 数据科学：理解和利用连接](../Images/44d24b263f1f47b1285c60cc487cdfe3.png)'
- en: Image by Author
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: In SQL, this type of join is performed using the keywords JOIN or INNER JOIN.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，这种类型的连接使用关键字 JOIN 或 INNER JOIN 执行。
- en: SQL Left Outer Join
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 左外连接
- en: A left outer join returns all the rows from the left (or first) table and the
    matched rows from the right (or second) table. If there is no match, it returns
    NULL values for the columns from the right table.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 左外连接返回来自左（或第一个）表的所有行以及来自右（或第二个）表的匹配行。如果没有匹配，则返回右表中列的 NULL 值。
- en: We can visualize it like this.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样可视化它。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/24697b8483d2b05b9ad49a9b2438a346.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 数据科学：理解和利用连接](../Images/24697b8483d2b05b9ad49a9b2438a346.png)'
- en: Image by Author
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: When wanting to use this join in SQL, you can do that by using LEFT OUTER JOIN
    or LEFT JOIN keywords. Here’s an article that talks about [left join vs left outer
    join](https://www.stratascratch.com/blog/similarities-and-differences-left-join-vs-left-outer-join/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在 SQL 中使用这种连接时，你可以使用 LEFT OUTER JOIN 或 LEFT JOIN 关键字。这里有一篇文章讨论了 [左连接与左外连接](https://www.stratascratch.com/blog/similarities-and-differences-left-join-vs-left-outer-join/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)。
- en: SQL Right Outer Join
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 右外连接
- en: A right join is the opposite of a left join. It returns all the rows from the
    right table and the matched rows from the left table. If there is no match, it
    returns NULL values for the columns from the left table.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 右连接是左连接的反向操作。它返回右表中的所有行和左表中匹配的行。如果没有匹配，它会返回左表中列的 NULL 值。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/b14a0d784cea5dc2682df16e97553195.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 数据科学：理解和利用连接](../Images/b14a0d784cea5dc2682df16e97553195.png)'
- en: Image by Author
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: In SQL, this join type is performed using the keywords RIGHT OUTER JOIN or RIGHT
    JOIN.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，这种连接类型是通过 RIGHT OUTER JOIN 或 RIGHT JOIN 关键字实现的。
- en: SQL Full Outer Join
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 全外连接
- en: A full outer join returns all the rows from both tables, matching rows where
    possible and filling in NULL values for non-matching rows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 全外连接返回两个表中的所有行，尽可能匹配行，并为不匹配的行填充 NULL 值。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/8ece26dd3f0c639286ddc64df5ae448e.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 数据科学：理解和利用连接](../Images/8ece26dd3f0c639286ddc64df5ae448e.png)'
- en: Image by Author
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: The keywords in SQL for this join are FULL OUTER JOIN or FULL JOIN.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，此连接的关键字是 FULL OUTER JOIN 或 FULL JOIN。
- en: SQL Cross Join
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 交叉连接
- en: This type of join combines all the rows from one table with all the rows from
    the second table. In other words, it returns the Cartesian product, i.e., all
    possible combinations of the two tables’ rows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连接类型将一个表中的所有行与第二个表中的所有行组合在一起。换句话说，它返回笛卡尔积，即两个表的所有可能组合。
- en: Here’s the visualization that will make it easier to understand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将帮助你更容易理解的可视化图。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/8b9fe0b7a1fb44e74c1f71edd99cdb6c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 数据科学：理解和利用连接](../Images/8b9fe0b7a1fb44e74c1f71edd99cdb6c.png)'
- en: Image by Author
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: When cross-joining in SQL, the keyword is CROSS JOIN.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中进行交叉连接时，关键字是 CROSS JOIN。
- en: Understanding SQL Join Syntax
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 SQL 连接语法
- en: 'To perform a join in SQL, you need to specify the tables we want to join, the
    columns used for matching, and the type of join we want to perform. The basic
    syntax for joining tables in SQL is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SQL 中执行连接，你需要指定我们要连接的表、用于匹配的列以及我们要执行的连接类型。SQL 中连接表的基本语法如下：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example shows how to use JOIN.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何使用 JOIN。
- en: You reference the first (or left) table in the FROM clause. Then you follow
    it with JOIN and reference the second (or right) table.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 FROM 子句中引用第一个（或左边）表。然后使用 JOIN 并引用第二个（或右边）表。
- en: Then comes the joining condition in the ON clause. This is where you specify
    which columns you’ll use to join the two tables. Usually, it’s a shared column
    that’s a primary key in one table and the foreign key in the second table.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 ON 子句中的连接条件。在这里你指定将用哪些列来连接两个表。通常，这是一列共享的列，在一个表中是主键，在第二个表中是外键。
- en: '**Note: A primary key is a unique identifier for each record in a table. A
    foreign key establishes a link between two tables, i.e., it’s a column in the
    second table that references the first table.** We’ll show you in the examples
    what that means.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：主键是表中每条记录的唯一标识符。外键在两个表之间建立了联系，即它是第二个表中引用第一个表的列。** 我们将在示例中展示这意味着什么。'
- en: If you want to use LEFT JOIN, RIGHT JOIN, or FULL JOIN, you just use these keywords
    instead of JOIN – everything else in the code is exactly the same!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 LEFT JOIN、RIGHT JOIN 或 FULL JOIN，你只需使用这些关键字代替 JOIN——代码中的其他部分完全相同！
- en: Things are a little different with the CROSS JOIN. In its nature is to join
    all the rows’ combinations from both tables. That’s why the ON clause is not needed,
    and the syntax looks like this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CROSS JOIN 的情况稍有不同。它的本质是将两个表中的所有行组合在一起。因此，ON 子句是不需要的，语法如下所示。
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In other words, you simply reference one table in FROM and the second in CROSS
    JOIN.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你只需在 FROM 中引用一个表，在 CROSS JOIN 中引用第二个表。
- en: Alternatively, you can reference both tables in FROM and separate them with
    a comma – this is a shorthand for CROSS JOIN.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以在 FROM 中引用两个表，并用逗号分隔它们——这是一种 CROSS JOIN 的简写方式。
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Self Join: A Special Type of Join in SQL'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自连接：SQL 中的一种特殊连接类型
- en: There’s also one specific way of joining the tables – joining the table with
    itself. This is also called self joining the table.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种特定的连接方式——将表与自身连接。这也被称为自连接表。
- en: It’s not exactly a distinct type of join, as any of the earlier-mentioned join
    types can also be used for self joining.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这不完全是一个独特的连接类型，因为之前提到的任何连接类型也可以用于自连接。
- en: The syntax for self joining is similar to what I showed you earlier. The main
    difference is the same table is referenced in FROM and JOIN.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 自连接的语法类似于我之前展示的。主要区别在于 FROM 和 JOIN 中引用的是相同的表。
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also, you need to give the table two aliases to distinguish between them. What
    you’re doing is joining the table with itself and treating it as two tables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要给表两个别名以区分它们。你所做的是将表与自身连接，并将其视为两个表。
- en: I just wanted to mention this here, but I won’t be going into further detail.
    If you’re interested in self join, please see this illustrated guide on [self
    join in SQL](https://www.stratascratch.com/blog/illustrated-guide-about-self-join-in-sql/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里提一下，但不会详细说明。如果你对自连接感兴趣，请查看 [SQL 中的自连接插图指南](https://www.stratascratch.com/blog/illustrated-guide-about-self-join-in-sql/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)。
- en: SQL Join Examples
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 连接示例
- en: It’s time to show you how everything I mentioned works in practice. I’ll use
    [SQL JOIN interview questions](https://www.stratascratch.com/blog/sql-join-interview-questions/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    from StrataScratch to showcase each distinct type of join in SQL.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是展示我提到的内容如何在实际中运作的时候了。我将使用 [StrataScratch 的 SQL JOIN 面试题](https://www.stratascratch.com/blog/sql-join-interview-questions/?utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    来展示 SQL 中每种不同类型的连接。
- en: 1\. JOIN Example
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 连接示例
- en: '[This question by Microsoft](https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    wants you to list each project and calculate the project’s budget by the employee.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[微软的这个问题](https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    希望你列出每个项目并按员工计算项目预算。'
- en: '***Expensive Projects***'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '***昂贵的项目***'
- en: '**“Given a list of projects and employees mapped to each project, calculate
    by the amount of project budget allocated to each employee . The output should
    include the project title and the project budget rounded to the closest integer.
    Order your list by projects with the highest budget per employee first.”*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**“给定一个项目和员工列表，并映射到每个项目，根据分配给每个员工的项目预算来计算。输出应包括项目标题和预算，预算应四舍五入到最接近的整数。按每个员工的预算从高到低排序项目列表。”**'
- en: Data
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据
- en: The question gives two tables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 问题给出了两个表。
- en: '**ms_projects**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**ms_projects**'
- en: '| id: | int |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| id: | int |'
- en: '| title: | varchar |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| title: | varchar |'
- en: '| budget: | int |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| budget: | int |'
- en: '**ms_emp_projects**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**ms_emp_projects**'
- en: '| emp_id: | int |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| emp_id: | int |'
- en: '| project_id: | int |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| project_id: | int |'
- en: 'Now, the column id in the table **ms_projects** is the table’s primary key.
    The same column can be found in the table **ms_emp_projects**, albeit with a different
    name: project_id. This is the table’s foreign key, referencing the first table.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，表 **ms_projects** 中的列 id 是表的主键。相同的列可以在表 **ms_emp_projects** 中找到，尽管名字不同：project_id。这是表的外键，引用了第一个表。
- en: I’ll use these two columns to join the tables in my solution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在我的解决方案中使用这两列来连接表。
- en: Code
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I joined the two tables using JOIN. The table **ms_projects** is referenced
    in FROM, while **ms_emp_projects** is referenced after JOIN. I’ve given both tables
    an alias, allowing me not to use the table’s long names later on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 JOIN 连接了这两个表。表 **ms_projects** 在 FROM 中被引用，而 **ms_emp_projects** 在 JOIN
    后被引用。我给两个表都起了别名，这样我以后就不需要使用表的长名称。
- en: Now, I need to specify the columns on which I want to join the tables. I already
    mentioned which columns are the primary key in one table and the foreign key in
    another table, so I’ll use them here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我需要指定要在其上连接表的列。我已经提到哪些列是一个表中的主键，另一个表中的外键，所以我将在这里使用它们。
- en: I equal these two columns because I want to get all the data where the project
    ID is the same. I also used the tables’ aliases in front of each column.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这两列设置为相等，因为我想获取所有项目 ID 相同的数据。我还在每列前面使用了表的别名。
- en: Now that I have access to data in both tables, I can list columns in SELECT.
    The first column is the project name, and the second column is calculated.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以访问两个表的数据，因此可以在SELECT中列出列。第一列是项目名称，第二列是计算得出的结果。
- en: This calculation uses the COUNT() function to count the number of employees
    by each project. Then I divide each project’s budget by the number of employees.
    I also convert the result to decimal values and round it to zero decimal places.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算使用COUNT()函数按每个项目计算员工数量。然后我将每个项目的预算除以员工数量。我还将结果转换为十进制值并四舍五入到零位小数。
- en: Output
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: Here’s what the query returns.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查询返回的结果。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/6bd7c952f4590be4964d1b451fde8193.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/6bd7c952f4590be4964d1b451fde8193.png)'
- en: 2\. LEFT JOIN Example
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. LEFT JOIN 示例
- en: Let’s practice this join on the [Airbnb interview question](https://platform.stratascratch.com/coding/9908-customer-orders-and-details?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins).
    It wants you to find the number of orders, the number of customers, and the total
    cost of orders for each city.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来在[Airbnb 面试题](https://platform.stratascratch.com/coding/9908-customer-orders-and-details?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)上练习这个连接。题目要求找出每个城市的订单数量、顾客数量和订单总成本。
- en: '***Customer Orders and Details***'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***顾客订单和详情***'
- en: '**“Find the number of orders, the number of customers, and the total cost of
    orders for each city. Only include cities that have made at least 5 orders and
    count all customers in each city even if they did not place an order.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**“找出每个城市的订单数量、顾客数量和订单总成本。仅包括至少有5个订单的城市，并计算每个城市中的所有顾客，即使他们没有下订单。”**'
- en: '**Output each calculation along with the corresponding city name.”*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**“输出每个计算结果及其对应的城市名称。”**'
- en: Data
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据
- en: You’re given the tables **customers,** and **orders**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的表是**customers**和**orders**。
- en: '**customers**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**customers**'
- en: '| id: | int |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| id: | int |'
- en: '| first_name: | varchar |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| first_name: | varchar |'
- en: '| last_name: | varchar |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| last_name: | varchar |'
- en: '| city: | varchar |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| city: | varchar |'
- en: '| address: | varchar |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| address: | varchar |'
- en: '| phone_number: | varchar |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| phone_number: | varchar |'
- en: '**orders**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**orders**'
- en: '| id: | int |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| id: | int |'
- en: '| cust_id: | int |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| cust_id: | int |'
- en: '| order_date: | datetime |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| order_date: | datetime |'
- en: '| order_details: | varchar |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| order_details: | varchar |'
- en: '| total_order_cost: | int |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| total_order_cost: | int |'
- en: The shared columns are id from the table **customers** and cust_id from the
    table **orders**. I’ll use these columns to join the tables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的列是**customers**表中的id和**orders**表中的cust_id。我将使用这些列来连接表。
- en: Code
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码
- en: Here’s how to solve this question using LEFT JOIN.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用LEFT JOIN解决这个问题的方法。
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I reference the table **customers** in FROM (this is our left table) and LEFT
    JOIN it with **orders** on the customer ID columns.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我在FROM中引用表**customers**（这是我们的左表），并通过客户ID列将其与**orders**表进行LEFT JOIN。
- en: Now I can select the city, use COUNT() to get the number of orders and customers
    by city, and use SUM() to calculate the total orders cost by city.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以选择城市，使用COUNT()按城市获取订单和顾客数量，并使用SUM()按城市计算订单总成本。
- en: To get all these calculations by city, I group the output by city.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按城市获取所有这些计算结果，我按城市对输出进行分组。
- en: 'There’s one extra request in the question: “Only include cities that have made
    at least 5 orders…” I use HAVING to show only cities with five or more orders
    to achieve that.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 问题中还有一个额外的要求：“仅包括至少有5个订单的城市…” 我使用HAVING来仅显示订单数量为五个或更多的城市。
- en: '**The question is, why did I use** **LEFT JOIN** **and not** **JOIN****?**
    The clue is in the question:”...and count all customers in each city even if they
    did not place an order.” It’s possible that not all customers have placed orders.
    This means I want to show all customers from the table **customers**, which perfectly
    fits the definition of the LEFT JOIN.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题是，我为什么使用了** **LEFT JOIN** **而不是** **JOIN** **呢？** 提示在问题中：“…并计算每个城市中的所有顾客，即使他们没有下订单。”
    这意味着可能不是所有顾客都有下订单。因此，我想展示来自**customers**表中的所有顾客，这正好符合LEFT JOIN的定义。'
- en: Had I used JOIN, the result would’ve been wrong, as I would’ve missed the customers
    that didn’t place any orders.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用JOIN，结果会出错，因为我会遗漏那些没有下订单的顾客。
- en: '**Note: The complexity of joins in SQL isn’t reflected in their syntax but
    in their semantics!** As you saw, each join is written the same way, only the
    keyword changes. However, each join works differently and, therefore, can output
    different results depending on the data. Because of that, it’s crucial that you
    fully understand what each join does and choose the one that will return exactly
    what you want!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：SQL 中连接的复杂性并不体现在它们的语法上，而是在于它们的语义！** 如你所见，每个连接的写法都是一样的，只有关键字不同。然而，每个连接的工作方式不同，因此可能会根据数据输出不同的结果。因此，你必须完全理解每个连接的作用，并选择能返回你所需结果的连接！'
- en: Output
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: Now, let’s have a look at the output.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看输出结果。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/f25478b07ca19c239ea6224e1259a9a3.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 数据科学：理解和利用连接](../Images/f25478b07ca19c239ea6224e1259a9a3.png)'
- en: 3\. RIGHT JOIN Example
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. RIGHT JOIN 示例
- en: The RIGHT JOIN is the mirror image of LEFT JOIN. That’s why I could’ve easily
    solved the previous problem using RIGHT JOIN. Let me show you how to do it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: RIGHT JOIN是LEFT JOIN的镜像。这就是为什么我可以很容易地用RIGHT JOIN解决之前的问题。让我给你演示一下怎么做。
- en: Data
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据
- en: The tables stay the same; I’ll just use a different type of join.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表格保持不变；我将使用不同类型的连接。
- en: Code
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here’s what’s changed. As I’m using RIGHT JOIN, I switched the order of the
    tables. Now the table **orders** becomes the left one, and the table **customers**
    the right one. The joining condition stays the same. I just switched the order
    of the columns to reflect the order of the tables, but it’s not necessary to do
    it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是变化的地方。由于我使用了 RIGHT JOIN，所以我调换了表的顺序。现在表 **orders** 成为左表，表 **customers** 成为右表。连接条件保持不变。我只是调换了列的顺序以反映表的顺序，但这不是必须的。
- en: By switching the order of the tables and using RIGHT JOIN, I again will output
    all the customers, even if they haven’t placed any orders.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调换表的顺序并使用 RIGHT JOIN，我将再次输出所有客户，即使他们没有下任何订单。
- en: The rest of the query is the same as in the previous example. The same goes
    for the output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的查询与之前的示例相同。输出也是如此。
- en: '**Note: In practice,** **RIGHT JOIN** **is relatively rarely used.** The LEFT
    JOIN seems more natural to SQL users, so they use it much more often. Anything
    that can be done with RIGHT JOIN can also be done with LEFT JOIN. Because of that,
    there’s no specific situation where RIGHT JOIN might be preferred.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：实际上，** **RIGHT JOIN** **相对较少使用。** LEFT JOIN 对 SQL 用户来说似乎更自然，因此使用得更多。任何可以用
    RIGHT JOIN 做的事情，也可以用 LEFT JOIN 做。因此，没有特定的情况需要偏好 RIGHT JOIN。'
- en: Output
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/f25478b07ca19c239ea6224e1259a9a3.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![SQL 数据科学：理解和利用连接](../Images/f25478b07ca19c239ea6224e1259a9a3.png)'
- en: 4\. FULL JOIN Example
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4\. FULL JOIN 示例
- en: '[The question by Salesforce and Tesla](https://platform.stratascratch.com/coding/10318-new-products?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    wants you to count the net difference between the number of products companies
    launched in 2020 with the number of products companies launched in the previous
    year.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[Salesforce 和 Tesla 的问题](https://platform.stratascratch.com/coding/10318-new-products?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)要求你计算2020年公司发布的产品数量与前一年公司发布的产品数量之间的净差异。'
- en: '***New Products***'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '***新产品***'
- en: '*“You are given a table of product launches by company by year. Write a query
    to count the net difference between the number of products companies launched
    in 2020 with the number of products companies launched in the previous year. Output
    the name of the companies and a net difference of net products released for 2020
    compared to the previous year.”*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*“你将获得一个按公司和年份划分的产品发布表。编写一个查询，计算2020年公司发布的产品数量与前一年公司发布的产品数量之间的净差异。输出公司的名称以及2020年与前一年发布的产品净差异。”*'
- en: Data
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据
- en: The question provides one table with the following columns.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 问题提供了一个具有以下列的表格。
- en: '**car_launches**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**car_launches**'
- en: '| year: | int |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| year: | int |'
- en: '| company_name: | varchar |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| company_name: | varchar |'
- en: '| product_name: | varchar |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| product_name: | varchar |'
- en: How the hell will I join tables when there’s only one table? Hmm, let’s see
    that, too!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个表时，我该如何连接表？嗯，让我们看看！
- en: Code
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码
- en: This query is a little more complicated, so I’ll reveal it gradually.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询有点复杂，所以我会逐步展示。
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first SELECT statement finds the company and the product name in 2020\.
    This query will later be turned into a subquery.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 SELECT 语句找出2020年的公司和产品名称。这个查询稍后将转化为子查询。
- en: The question wants you to find the difference between 2020 and 2019\. So let’s
    write the same query but for 2019.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 问题要求你找出2020年和2019年之间的差异。所以我们来写一个相同的查询，但针对2019年。
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I’ll now make these queries into subqueries and join them using the FULL OUTER
    JOIN.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我将现在将这些查询变成子查询，并使用FULL OUTER JOIN连接它们。
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Subqueries can be treated as tables and, therefore, can be joined. I gave the
    first subquery an alias, and I placed it in the FROM clause. Then I use FULL OUTER
    JOIN to join it with the second subquery on the company name column.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询可以视作表，因此可以连接。我给第一个子查询一个别名，并将其放在FROM子句中。然后，我使用FULL OUTER JOIN将其与第二个子查询通过公司名称列连接。
- en: By using this type of SQL join, I’ll get all the companies and products in 2020
    merged with all the companies and products in 2019.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种类型的SQL连接，我将获得2020年所有公司和产品与2019年所有公司和产品的合并。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/e93b4f2c0f0fd8ad0a49de95cf97bcd5.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/e93b4f2c0f0fd8ad0a49de95cf97bcd5.png)'
- en: Now I can finalize my query. Let’s select the company name. Also, I’ll use the
    COUNT() function to find the number of products launched in each year and then
    subtract it to get the difference. Finally, I’ll group the output by company and
    sort it also by company alphabetically.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以完成我的查询了。我们选择公司名称。同时，我将使用COUNT()函数来查找每年发布的产品数量，然后计算差异。最后，我将按公司对输出进行分组，并按公司字母顺序排序。
- en: Here’s the whole query.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的查询。
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Output
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: Here’s the list of companies and the launched products difference between 2020
    and 2019.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是2020年和2019年之间公司及发布产品差异的列表。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/437525d5348f8d14247ef258e2bf80cd.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/437525d5348f8d14247ef258e2bf80cd.png)'
- en: 5\. CROSS JOIN Example
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5\. CROSS JOIN 示例
- en: '[This question by Deloitte](https://platform.stratascratch.com/coding/2101-maximum-of-two-numbers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)
    is great for showing how CROSS JOIN works.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[这道Deloitte的问题](https://platform.stratascratch.com/coding/2101-maximum-of-two-numbers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdn+sql+joins)非常适合展示CROSS
    JOIN的工作原理。'
- en: '***Maximum of Two Numbers***'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '***两个数字的最大值***'
- en: '**“Given a single column of numbers, consider all possible permutations of
    two numbers assuming that pairs of numbers (x,y) and (y,x) are two different permutations.
    Then, for each permutation, find the maximum of the two numbers.*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**“给定一个单列数字，考虑所有可能的两个数字的排列，假设数字对(x,y)和(y,x)是两个不同的排列。然后，对于每个排列，找出两个数字中的最大值。”**'
- en: '**Output three columns: the first number, the second number and the maximum
    of the two.”*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出三列：第一个数字、第二个数字和两个数字中的最大值。”**'
- en: The question wants you to find all possible permutations of two numbers assuming
    that pairs of numbers (x,y) and (y,x) are two different permutations. Then, we
    need to find the maximum of the numbers for each permutation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 问题要求你找出两个数字的所有可能排列，假设数字对(x,y)和(y,x)是两个不同的排列。然后，我们需要找到每个排列中的最大值。
- en: Data
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据
- en: The question gives us one table with one column.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 问题给了我们一个具有一列的表。
- en: '**deloitte_numbers**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**deloitte_numbers**'
- en: '| number: | int |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| number: | int |'
- en: Code
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码
- en: This code is an example of CROSS JOIN, but also of self join.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是CROSS JOIN的一个示例，同时也是自连接的示例。
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I reference the table in FROM and give it one alias. Then I CROSS JOIN it with
    itself by referencing it after CROSS JOIN and giving the table another alias.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我在FROM中引用了表，并给它一个别名。然后，我通过在CROSS JOIN后引用它并给表另一个别名，将其与自身进行CROSS JOIN。
- en: Now it’s possible to use one table as they’re two. I select the column number
    from each table. Then I use the CASE statement to set a condition that will show
    the maximum number of the two numbers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将一个表视作两个表来使用。我从每个表中选择列number。然后，我使用CASE语句设置一个条件来显示两个数字中的最大值。
- en: Why is CROSS JOIN used here? Remember, it’s a type of SQL join that will show
    all combinations of all rows from all tables. That’s exactly what the question
    is asking!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这里使用CROSS JOIN？请记住，这是一种SQL连接类型，将显示所有表中所有行的所有组合。这正是问题所要求的！
- en: Output
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: Here’s the snapshot of all the combinations and the higher number of the two.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有组合及两个数字中较大者的快照。
- en: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/0dbd17281afe1d66e06d7000a7662d7f.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![SQL For Data Science: Understanding and Leveraging Joins](../Images/0dbd17281afe1d66e06d7000a7662d7f.png)'
- en: Utilizing SQL Joins for Data Science
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用SQL连接进行数据科学
- en: Now that you know how to use SQL joins, the question is how to utilize that
    knowledge in data science.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用SQL连接，问题是如何在数据科学中利用这些知识。
- en: SQL Joins play a crucial role in data science tasks such as data exploration,
    data cleaning, and feature engineering.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 连接在数据科学任务中扮演着至关重要的角色，如数据探索、数据清理和特征工程。
- en: 'Here are a few examples of how SQL joins can be leveraged:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些如何利用 SQL 连接的示例：
- en: '**Combining Data:** Joining tables allows you to bring together different sources
    of data, enabling you to analyze relationships and correlations across multiple
    datasets. For example, joining a customer table with a transaction table can provide
    insights into customer behavior and purchasing patterns.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据结合：** 连接表格允许你汇聚不同的数据源，使你能够分析多个数据集之间的关系和相关性。例如，将客户表与交易表连接可以提供有关客户行为和购买模式的洞察。'
- en: '**Data Validation:** Joins can be used to validate data quality and integrity.
    By comparing data from different tables, you can identify inconsistencies, missing
    values, or outliers. This helps you in data cleaning and ensures that the data
    used for analysis is accurate and reliable.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据验证：** 连接操作可用于验证数据质量和完整性。通过比较来自不同表格的数据，你可以识别不一致、缺失值或异常值。这有助于数据清理，并确保用于分析的数据是准确和可靠的。'
- en: '**Feature Engineering:** Joins can be instrumental in creating new features
    for machine learning models. By merging relevant tables, you can extract meaningful
    information and generate features that capture important relationships within
    the data. This can enhance the predictive power of your models.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**特征工程：** 连接操作在创建机器学习模型的新特征时非常有用。通过合并相关的表格，你可以提取有意义的信息并生成捕捉数据中重要关系的特征。这可以增强模型的预测能力。'
- en: '**Aggregation and Analysis:** Joins enable you to perform complex aggregations
    and analyses across multiple tables. By combining data from various sources, you
    can gain a comprehensive view of the data and derive valuable insights. For example,
    joining a sales table with a product table can help you analyze sales performance
    by product category or region.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**聚合与分析：** 连接操作使你能够在多个表格之间执行复杂的聚合和分析。通过结合来自不同来源的数据，你可以获得数据的全面视图并得出有价值的洞察。例如，将销售表与产品表连接可以帮助你按产品类别或地区分析销售表现。'
- en: Best Practices for SQL Joins
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 连接的最佳实践
- en: As I already mentioned, the complexity of joins doesn’t show in their syntax.
    You saw that syntax is relatively straightforward.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，连接的复杂性并不体现在其语法上。你会发现语法相对简单明了。
- en: The best practices for joins also reflect that, as they are not concerned with
    coding itself but what join does and how it performs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的最佳实践也反映了这一点，因为它们并不关注代码本身，而是连接操作的作用及其表现。
- en: To make the most out of joins in SQL, consider the following best practices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化利用 SQL 中的连接操作，请考虑以下最佳实践。
- en: '**Understand Your Data:** Familiarize yourself with the structure and relationships
    within your data. This will help you choose the appropriate type of join and select
    the right columns for matching.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**了解你的数据：** 熟悉数据的结构和关系。这将帮助你选择合适的连接类型，并选择匹配的正确列。'
- en: '**Use Indexes:** If your tables are large or frequently joined, consider adding
    indexes on the columns used for joining. Indexes can significantly improve query
    performance.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用索引：** 如果你的表格很大或经常被连接，考虑在用于连接的列上添加索引。索引可以显著提高查询性能。'
- en: '**Be Mindful of Performance:** Joining large tables or multiple tables can
    be computationally expensive. Optimize your queries by filtering data, using appropriate
    join types, and considering the use of temporary tables or subqueries.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注意性能：** 连接大型表格或多个表格可能会消耗大量计算资源。通过过滤数据、使用适当的连接类型以及考虑使用临时表或子查询来优化查询。'
- en: '**Test and Validate:** Always validate your join results to ensure correctness.
    Perform sanity checks and verify that the joined data aligns with your expectations
    and business logic.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试和验证：** 始终验证你的连接结果以确保正确性。执行合理性检查，并验证连接的数据是否符合你的期望和业务逻辑。'
- en: Conclusion
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: SQL Joins are a fundamental concept that empowers you as a data scientist to
    merge and analyze data from multiple sources. By understanding the different types
    of SQL joins, mastering their syntax, and leveraging them effectively, data scientists
    can unlock valuable insights, validate data quality, and drive data-driven decision-making.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 连接是一个基本概念，使你作为数据科学家能够合并和分析来自多个来源的数据。通过理解不同类型的 SQL 连接，掌握其语法并有效利用它们，数据科学家可以发现有价值的洞察，验证数据质量，并推动数据驱动的决策。
- en: I showed you how to do it in five examples. Now it’s up to you to harness the
    power of SQL and joins for your data science projects and achieve better results.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过五个示例向你展示了如何操作。现在，利用 SQL 和连接来提升你的数据科学项目，并实现更好的结果，就全靠你了。
- en: '**[Nate Rosidi](https://www.stratascratch.com)** is a data scientist and in
    product strategy. He''s also an adjunct professor teaching analytics, and is the
    founder of [StrataScratch](https://www.stratascratch.com/), a platform helping
    data scientists prepare for their interviews with real interview questions from
    top companies. Connect with him on [Twitter: StrataScratch](https://twitter.com/StrataScratch)
    or [LinkedIn](https://www.linkedin.com/in/nathanrosidi/).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**[内特·罗西迪](https://www.stratascratch.com)** 是一名数据科学家和产品战略专家。他还是一名兼职教授，教授分析学，并且是
    [StrataScratch](https://www.stratascratch.com/) 的创始人，该平台帮助数据科学家准备面试，提供来自顶级公司的真实面试问题。通过
    [Twitter: StrataScratch](https://twitter.com/StrataScratch) 或 [LinkedIn](https://www.linkedin.com/in/nathanrosidi/)
    与他联系。'
- en: More On This Topic
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多相关内容
- en: '[In-Database Analytics: Leveraging SQL''s Analytic Functions](https://www.kdnuggets.com/2023/07/indatabase-analytics-leveraging-sql-analytic-functions.html)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库内分析：利用 SQL 的分析功能](https://www.kdnuggets.com/2023/07/indatabase-analytics-leveraging-sql-analytic-functions.html)'
- en: '[Leveraging GPT Models to Transform Natural Language to SQL Queries](https://www.kdnuggets.com/leveraging-gpt-models-to-transform-natural-language-to-sql-queries)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用 GPT 模型将自然语言转换为 SQL 查询](https://www.kdnuggets.com/leveraging-gpt-models-to-transform-natural-language-to-sql-queries)'
- en: '[Leveraging AI to Design Fair and Equitable EV Charging Grids](https://www.kdnuggets.com/leveraging-ai-to-design-fair-and-equitable-ev-charging-grids)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用人工智能设计公平和公正的电动汽车充电网络](https://www.kdnuggets.com/leveraging-ai-to-design-fair-and-equitable-ev-charging-grids)'
- en: '[Leveraging Geospatial Data in Python with GeoPandas](https://www.kdnuggets.com/leveraging-geospatial-data-in-python-with-geopandas)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用 GeoPandas 在 Python 中处理地理空间数据](https://www.kdnuggets.com/leveraging-geospatial-data-in-python-with-geopandas)'
- en: '[Leveraging XGBoost for Time-Series Forecasting](https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用 XGBoost 进行时间序列预测](https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html)'
- en: '[Leveraging the Power of GPUs with CuPy in Python](https://www.kdnuggets.com/leveraging-the-power-of-gpus-with-cupy-in-python)*****'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用 CuPy 在 Python 中发挥 GPU 的强大功能](https://www.kdnuggets.com/leveraging-the-power-of-gpus-with-cupy-in-python)*****'
