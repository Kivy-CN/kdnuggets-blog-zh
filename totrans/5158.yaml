- en: 24 SQL Questions You Might See on Your Next Interview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2022/06/24-sql-questions-might-see-next-interview.html](https://www.kdnuggets.com/2022/06/24-sql-questions-might-see-next-interview.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![24 SQL Questions You Might See on Your Next Interview](../Images/d697b944ff0af5e67e057054a1e211c1.png)'
  prefs: []
  type: TYPE_IMG
- en: When talking about the [SQL interview questions](https://www.stratascratch.com/blog/sql-interview-questions-you-must-prepare-the-ultimate-guide/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    that come up most often at job interviews, I’m not talking about giving you the
    specific question. That would be an impossible task because there are thousands
    and thousands of them.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are not so many SQL concepts tested by these questions. It doesn’t
    mean you should solve only the interview questions I’m about to show or know only
    the selected topics.
  prefs: []
  type: TYPE_NORMAL
- en: But if you focus on the most common topics, the chance is you’ll be covering
    most of the concepts tested in the interviews. Of course, the questions can be
    of different difficulty, which will require more or less knowledge about a specific
    topic. Still, the concepts are often the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these topics can be seen as magnificent (especially if you’re an SQL
    nerd!), I prefer to call them “The Unavoidable Seven”:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating, Grouping, and Sorting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOINs & Set Operators
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subqueries & CTEs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CASE Statement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Window Functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text & Date Manipulation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These topics are usually tested in the coding SQL questions, but they can also
    appear in the non-coding types of questions.
  prefs: []
  type: TYPE_NORMAL
- en: Coding SQL Interview Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The coding questions are precisely what their name suggests: they test your
    ability to write a code using the SQL concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Aggregating, Grouping, and Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Aggregating, Grouping, and Sorting](../Images/2f1c6477f63ecdb76e5cf30618c0a600.png)'
  prefs: []
  type: TYPE_IMG
- en: Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [SQL aggregate functions](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-aggregate-functions/?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)
    are the functions that perform calculations on multiple rows and return one value.
    The most commonly used aggregate functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aggregate Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| COUNT() | Counts the number of rows. |'
  prefs: []
  type: TYPE_TB
- en: '| SUM() | Returns the sum of the rows. |'
  prefs: []
  type: TYPE_TB
- en: '| AVG() | Calculates the average of the rows’ values.  |'
  prefs: []
  type: TYPE_TB
- en: '| MIN() | Returns the lowest value. |'
  prefs: []
  type: TYPE_TB
- en: '| MAX() | Returns the highest value.  |'
  prefs: []
  type: TYPE_TB
- en: When used alone, these functions will return only one value. Admittedly, this
    isn’t very sophisticated.
  prefs: []
  type: TYPE_NORMAL
- en: The aggregate functions become more valuable for data scientists when used with
    the GROUP BY and ORDER BY clauses.
  prefs: []
  type: TYPE_NORMAL
- en: GROUP BY is used for grouping data from one or more columns into groups based
    on the rows’ values. Every different value (or a combination of values for grouping
    by multiple columns) will form a separate data group. That way, it becomes possible
    to show additional info on data that is being aggregated.
  prefs: []
  type: TYPE_NORMAL
- en: The ORDER BY serves for sorting the query’s output. Data can be sorted in ascending
    or descending order. Also, you can sort by one or more columns.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate functions used with these two clauses become a stepping stone for
    creating reports, calculating metrics, and tidying data. They allow you to perform
    mathematical operations on data and show your finding in a clear and presentable
    way.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Interview Question #1: Finding Updated Records'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“We have a table with employees and their salaries, however, some of the records
    are old and contain outdated salary information. Find the current salary of each
    employee, assuming that salaries increase each year. Output their id, first name,
    last name, department ID, and current salary. Order your list by employee ID in
    ascending order.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10299-finding-updated-records?code_type=1](https://platform.stratascratch.com/coding/10299-finding-updated-records?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This question gives you one table: ms_employee_salary'
  prefs: []
  type: TYPE_NORMAL
- en: '| id | int |'
  prefs: []
  type: TYPE_TB
- en: '| first_name | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| last_name | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| salary | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| department_id | int |'
  prefs: []
  type: TYPE_TB
- en: The sample of the data from the table is given below.
  prefs: []
  type: TYPE_NORMAL
- en: '![data from the table](../Images/58dd583b7dcfe9b7fc0c404eac1e2c27.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Solution Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: If the salary is increasing every year, then the latest salary is also the highest
    salary. To fetch it, use the MAX() aggregate function. Group the data by the employee
    and department. You should also show the output sorted by the employee ID in ascending
    order; use the ORDER BY clause for that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding Updated Records](../Images/c94879daa40b49a7477e560d63822d16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #2: Order All Countries by the Year They First Participated
    in the Olympics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find the average distance traveled in each hour.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the hour along with the corresponding average traveled distance.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sort records by the hour in ascending order.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10006-find-the-average-distance-traveled-in-each-hour?code_type=1](https://platform.stratascratch.com/coding/10006-find-the-average-distance-traveled-in-each-hour?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: To find the average distance, use the AVG() function, then group and order the
    output by the column hour.
  prefs: []
  type: TYPE_NORMAL
- en: If you write the correct solution, this is what you’ll get.
  prefs: []
  type: TYPE_NORMAL
- en: '![Order All Countries by the Year They First Participated in the Olympics correct
    solution ](../Images/955a3288b7becc8e344aeac00c348f5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #3: Order All Countries by the Year They First Participated
    in the Olympics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Order all countries by the year they first participated in the Olympics.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the National Olympics Committee (NOC) name along with the desired year.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sort records by the year and the NOC in ascending order.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10184-order-all-countries-by-the-year-they-first-participated-in-the-olympics?code_type=1](https://platform.stratascratch.com/coding/10184-order-all-countries-by-the-year-they-first-participated-in-the-olympics?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: The code needs to group data by the column noc and uses the MIN() aggregate
    function for finding the first year of participation. To sort the output adequately,
    use the ORDER BY.
  prefs: []
  type: TYPE_NORMAL
- en: If you get this result, then you did everything right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Order All Countries by the Year They First Participated in the Olympics](../Images/a7050f00aedfe975d8806178beea63c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 2\. Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Filtering](../Images/3285180204dc5403a0f96bdf56f452fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If data filtering is defined as selecting a subset of data, then there are many
    ways of data filtering. Even the ones people usually don’t see as such, for example,
    the SELECT statement and JOINs. But they are; they select only part of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When thinking about filtering data, usually two keywords come to mind (or three
    when you’re using PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: WHERE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HAVING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (LIMIT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WHERE clause’s purpose is to filter data before it is aggregated. The syntax
    reflects that in a way that it must be written before the GROUP BY clause.
  prefs: []
  type: TYPE_NORMAL
- en: When filtering data using the WHERE clause, there are many operators to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| = | Is equal |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal |'
  prefs: []
  type: TYPE_TB
- en: '| >=  | Is greater than or equal |'
  prefs: []
  type: TYPE_TB
- en: '| <> | Does not equal |'
  prefs: []
  type: TYPE_TB
- en: '| BETWEEN  | Between the specified range |'
  prefs: []
  type: TYPE_TB
- en: '| LIKE | Looking for a pattern |'
  prefs: []
  type: TYPE_TB
- en: '| IN | Equals the values listed in the parentheses |'
  prefs: []
  type: TYPE_TB
- en: The HAVING clause does the same thing as the WHERE clause, except it filters
    data after the aggregation. Naturally, it can be used only after the GROUP BY
    clause in the SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: All the operators in the WHERE clause are also allowed in the HAVING clause.
  prefs: []
  type: TYPE_NORMAL
- en: Both clauses allow filtering on one or multiple conditions by using the AND/OR
    logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Using these two clauses adds another dimension to your calculations. Basic use
    makes it possible to show only the data you’re interested in and not the bulk
    of the data. This means not only do you get the choose the columns you want but
    also the rows you want, based on their values. Use it with the aggregate function,
    and you get to perform calculations on even more detailed subsets of data by filtering
    the input for the aggregate functions and, if you wish, their output, too. This
    increases the complexity of the calculations at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the examples of how [WHERE](https://towardsdatascience.com/data-science-lesson-3-filtering-data-using-sql-45d90986487f)
    and [HAVING](https://www.sqlservertutorial.net/sql-server-basics/sql-server-having/)
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '[The LIMIT clause](https://www.geeksforgeeks.org/sql-limit-clause/#:~:text=The%20LIMIT%20clause%20is%20used,be%20a%20non-negative%20integer.)
    simply specifies the number of rows you wish to see as output. The integer value
    in the clause equals the number of rows shown as a result. This is especially
    useful when you want to rank data, e.g., show the top N sales, employees, salaries,
    etc.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Interview Question #4: Find the Year That Uber Acquired More Than 2000
    Customers Through Celebrities'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find the year that Uber acquired more than 2000 customers through advertising
    using celebrities.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10000-find-the-year-that-uber-acquired-more-than-2000-customers-through-celebrities?code_type=1](https://platform.stratascratch.com/coding/10000-find-the-year-that-uber-acquired-more-than-2000-customers-through-celebrities?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**'
  prefs: []
  type: TYPE_NORMAL
- en: The table uber_advertising has four columns.
  prefs: []
  type: TYPE_NORMAL
- en: '| year | int |'
  prefs: []
  type: TYPE_TB
- en: '| advertising_channel | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| money_spent | int |'
  prefs: []
  type: TYPE_TB
- en: '| customers_acquired | int |'
  prefs: []
  type: TYPE_TB
- en: Here’s the table preview.
  prefs: []
  type: TYPE_NORMAL
- en: '![data preview](../Images/48515f96c36832410d25c9e853351712.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Solution Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is a simple SELECT statement with one column. However, you don’t
    need all the years. The question asks you to output only those where the advertising
    channel was through celebrities, and there were more than 2,000 customers acquired.
    To do that, put these two conditions into the WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Find the Year That Uber Acquired More Than 2000 Customers Through Celebrities](../Images/ad13f186bafd3351f13553f33199bebc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the code, and it will output only one year that satisfies the criteria:
    2018.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Interview Question #5: Find All Businesses Whose Lowest and Highest Inspection
    Scores Are Different'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find all businesses whose lowest and highest inspection scores are different.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the corresponding business name and the lowest and highest scores of
    each business.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Order the result based on the business name in ascending order.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9731-find-all-businesses-whose-lowest-and-highest-inspection-scores-are-different?code_type=1](https://platform.stratascratch.com/coding/9731-find-all-businesses-whose-lowest-and-highest-inspection-scores-are-different?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: To answer the question, use the MIN() and MAX() functions to find the highest
    and lowest inspection scores and group the data by business. Then use the HAVING
    clause to show only businesses whose highest and lowest scores are not equal.
    Finally, sort the output by the business name alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: Your output should be this one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Find All Businesses Whose Lowest and Highest Inspection Scores Are Different](../Images/ca62f2fdc9c7ada86155cc20731538cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #6: Find the Top 3 Jobs With the Highest Overtime Pay
    Rate'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “Find the top 3 jobs with the highest overtime pay rate.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Output the job title of selected records.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sort records based on the overtime pay in descending order.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9988-find-the-top-3-jobs-with-the-highest-overtime-pay-rate?code_type=1](https://platform.stratascratch.com/coding/9988-find-the-top-3-jobs-with-the-highest-overtime-pay-rate?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This question asks you to use both WHERE and LIMIT clause. Use WHERE to find
    the job titles whose overtime pay isn’t NULL and isn’t 0\. Order the data from
    the highest to the lowest overtime pay. Then, simply limit the output to the first
    three rows, and there you have it: the top 3 jobs with the highest overtime pay
    rate.'
  prefs: []
  type: TYPE_NORMAL
- en: As the output shows, there are only three such jobs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Find the Top 3 Jobs With the Highest Overtime Pay Rate](../Images/109c14f76bb3f0c0b725e1c884eaa8c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 3\. JOINs & Set Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![JOINs & Set Operators](../Images/aa499db5adf469793d17ff1762652136.png)'
  prefs: []
  type: TYPE_IMG
- en: Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you’ve been condemned to use only one table. Unfortunately, not one
    respectable database is comprised of only one table. To fully use the available
    data, you need to know how to combine data from two or more tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'JOINs are the SQL feature you’re looking for: it makes it possible to join
    tables on the common column.'
  prefs: []
  type: TYPE_NORMAL
- en: There are five distinct JOIN types in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: '| **JOIN Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| (INNER) JOIN | Returns only the matching rows from both tables. |'
  prefs: []
  type: TYPE_TB
- en: '| LEFT (OUTER) JOIN | Returns all the data from the left table and only the
    matching rows from the right.  |'
  prefs: []
  type: TYPE_TB
- en: '| RIGHT (OUTER) JOIN | Returns all the data from the right table and only the
    matching rows from the left.  |'
  prefs: []
  type: TYPE_TB
- en: '| FULL OUTER JOIN | Returns all the rows from both tables.  |'
  prefs: []
  type: TYPE_TB
- en: '| CROSS JOIN | Combines all the rows from one table with every from the second
    table.  |'
  prefs: []
  type: TYPE_TB
- en: When I mention the matching rows, I mean the rows or values that are the same
    in both tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[The first four joins](https://learnsql.com/blog/sql-joins-types-explained/)
    are used most often, but [CROSS JOIN](https://www.sqlshack.com/sql-cross-join-with-examples/)
    can also be used sometimes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One additional way of joining tables is a self-join. It isn’t a distinct type
    of join: any JOIN type can be used for self-joining, which simply means that you
    join the table with itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The set operators](https://towardsdatascience.com/how-to-use-set-operations-in-sql-53d57c4f7b77)
    are used to combine the output of two or more queries.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Set Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| UNION | Combines the unique rows resulting from the queries.  |'
  prefs: []
  type: TYPE_TB
- en: '| UNION ALL | Combines all the rows resulting from the queries, including the
    duplicates. |'
  prefs: []
  type: TYPE_TB
- en: '| INTERSECT | Returns only the rows that appear in both queries’ output. |'
  prefs: []
  type: TYPE_TB
- en: '| EXCEPT | Returns unique rows from one query and only those that appear in
    the second query’s output.   |'
  prefs: []
  type: TYPE_TB
- en: SQL Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Interview Question #7: Expensive Projects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Given a list of projects and employees mapped to each project, calculate
    by the amount of project budget allocated to each employee. The output should
    include the project title and the project budget per employee rounded to the closest
    integer. Order your list by projects with the highest budget per employee first.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1](https://platform.stratascratch.com/coding/10301-expensive-projects?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data **'
  prefs: []
  type: TYPE_NORMAL
- en: The question gives you two tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: ms_projects'
  prefs: []
  type: TYPE_NORMAL
- en: '| id | int |'
  prefs: []
  type: TYPE_TB
- en: '| title | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| budget | int |'
  prefs: []
  type: TYPE_TB
- en: Here’s the table preview.
  prefs: []
  type: TYPE_NORMAL
- en: '![the table preview](../Images/57c59a16f75089de3f6e2607accf2aec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table: ms_emp_projects'
  prefs: []
  type: TYPE_NORMAL
- en: '| emp_id | int |'
  prefs: []
  type: TYPE_TB
- en: '| project_id | int |'
  prefs: []
  type: TYPE_TB
- en: The data example is given below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Expensive Projects](../Images/a7db7674b91845e896d69dcb3e4112d9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Solution Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to calculate the project budget by the employee. This
    looks more complicated than it is: simply divide the column budget with the number
    of employees, which you get using the COUNT() function. Then, cast the result
    to a float data type to get the decimal places. This calculation is done inside
    the ROUND() functions used to round the numbers. In this case, the result of division
    is cast to the numeric data type and rounded with no decimal places.'
  prefs: []
  type: TYPE_NORMAL
- en: The SELECT statement uses the columns from both tables. This is possible because
    the tables are joined using the INNER JOIN in the FROM clause. They are joined
    where the column id equals the column project_id.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the result is grouped by the project and its budget, while the output
    is sorted by the ratio in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![project budget](../Images/7b77de8a426bb8f34b42acead7efd058.png)'
  prefs: []
  type: TYPE_IMG
- en: The code output should look like this, shown partially below.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Interview Question #8: Find How Many Logins Spanish Speakers Made by Country'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find how many logins Spanish speakers made by the country.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the country along with the corresponding number of logins.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Order records by the number of logins in descending order.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9889-find-how-many-logins-spanish-speakers-made-by-country?code_type=1](https://platform.stratascratch.com/coding/9889-find-how-many-logins-spanish-speakers-made-by-country?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: In the solution, use the COUNT() function to calculate the number of logins.
    Since the required data is found in two tables, joining them would be necessary.
    Use the INNER JOIN for that purpose. Join the tables on the column user_id and
    where the event is ‘login’, while the user’s language is ‘spanish’. Group data
    by the location and sort it from the highest to the lowest count of logins.
  prefs: []
  type: TYPE_NORMAL
- en: The correct code will return three countries with the following number of logins.
  prefs: []
  type: TYPE_NORMAL
- en: '![number of logins](../Images/23d5763ce25ffe05af70cdf45ffb9224.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #9: Sum Of Numbers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find the sum of numbers whose index is less than 5 and the sum of numbers
    whose index is greater than 5\. Output each result on a separate row.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10008-sum-of-numbers?code_type=1](https://platform.stratascratch.com/coding/10008-sum-of-numbers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: The code you’ll have to write consists of two SELECT statements. One will find
    the sum of numbers where the index is less than 5, the other will do the same
    for the indexes higher than 5.
  prefs: []
  type: TYPE_NORMAL
- en: All you have to do is put UNION ALL between these two statements to get the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '![UNION ALL between these two statements to get the output](../Images/cbd4fdfda330043dfea6c2e862baecde.png)'
  prefs: []
  type: TYPE_IMG
- en: 4\. Subqueries & CTEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Subqueries & CTEs](../Images/6245626ccd798ded44f79da553133be1.png)'
  prefs: []
  type: TYPE_IMG
- en: Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The subqueries and CTEs add flexibility to your code. They are both used for
    more complex calculations with several steps, and their result is used in the
    main calculation.
  prefs: []
  type: TYPE_NORMAL
- en: There are specific keywords where you can use the [subqueries](https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php).
  prefs: []
  type: TYPE_NORMAL
- en: SELECT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FROM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WHERE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HAVING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INSERT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UPDATE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are most often used for filtering data in the WHERE or HAVING clause but
    also as tables in the FROM clause when the query result acts as a table. Generally,
    they allow performing complex calculations within one query.
  prefs: []
  type: TYPE_NORMAL
- en: As for the CTEs or Common Table Expressions, they have the same purpose. The
    difference is that they are closer to the human logic of calculation steps, so
    they make a tidier code. Usually, a CTE requires writing less code, and it’s more
    readable than the same calculation written in subqueries.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main parts of a CTE: a CTE and a query referencing the CTE.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general CTE syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The CTE is called using the WITH keyword. After giving your CTE, a name comes
    AS and then a CTE definition in the parentheses. This definition is a SELECT statement
    that gives instructions to CTE.
  prefs: []
  type: TYPE_NORMAL
- en: The main query is again a SELECT statement, but this one references the CTE.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a reason they have a word table in the name: a CTE is a temporary result
    that can be accessed only when a CTE is run, so it is similar to a temporary table.
    That’s why you can use it in the FROM clause like any other table.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Interview Question #10: Income By Title and Gender'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find the average total compensation based on employee titles and gender.
    Total compensation is calculated by adding both the salary and bonus of each employee.
    However, not every employee receives a bonus, so disregard employees without bonuses
    in your calculation. An employee can receive more than one bonus.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the employee title, gender (i.e., sex), along with the average total
    compensation.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10077-income-by-title-and-gender?code_type=1](https://platform.stratascratch.com/coding/10077-income-by-title-and-gender?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**'
  prefs: []
  type: TYPE_NORMAL
- en: The first table used in the question is sf_employee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: sf_employee'
  prefs: []
  type: TYPE_NORMAL
- en: '| id | int |'
  prefs: []
  type: TYPE_TB
- en: '| first_name | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| last_name | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| age | int |'
  prefs: []
  type: TYPE_TB
- en: '| sex | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| employee_title | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| department | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| salary | int |'
  prefs: []
  type: TYPE_TB
- en: '| target | int |'
  prefs: []
  type: TYPE_TB
- en: '| email | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| city | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| address | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| manager_id | int |'
  prefs: []
  type: TYPE_TB
- en: The data in the table looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![data in the table](../Images/4bc11f82a38c125bbef2745baed6bcba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table: sf_bonus'
  prefs: []
  type: TYPE_NORMAL
- en: '| worker_ref_id | int |'
  prefs: []
  type: TYPE_TB
- en: '| bonus | int |'
  prefs: []
  type: TYPE_TB
- en: '| bonus_date | datetime |'
  prefs: []
  type: TYPE_TB
- en: Here’s the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![worker bonus data](../Images/57290c659fab786ef724e6f342ede800.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Solution Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: The main SELECT statement in this code uses the table sf_employee and subquery
    data. The subquery calculates the total bonuses for the employee using the SUM()
    function; that’s why it also groups data by the worker ID. The subquery is joined
    with the table sf_employee like any other table. In this case, it’s using the
    INNER JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: The main query will then use the subquery’s data to calculate the average total
    compensation, comprised of the salary and the total bonuses received.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the result is grouped by the employee and sex.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: The solution will return four rows as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '![average compensation](../Images/17ec6bd9173d4b0f065df7c2d8e042b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #11: Cheapest Neighborhoods With Real Beds And Internet'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find neighborhoods where you can sleep on a real bed in a villa with internet
    while paying the lowest price possible.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9636-cheapest-neighborhoods-with-real-beds-and-internet?code_type=1](https://platform.stratascratch.com/coding/9636-cheapest-neighborhoods-with-real-beds-and-internet?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: For solving the question, use the subquery in the WHERE clause to get the price
    that satisfies certain criteria. The MIN() function will be used to find the lowest
    price for a real bed in a villa with the internet. Use the equals sign for two
    conditions and ILIKE with the wild card character (%) on both sides of the condition.
  prefs: []
  type: TYPE_NORMAL
- en: Then the same criteria (real bed, villa, the internet) will be used in the main
    query.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one neighborhood that satisfies the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: '![neighborhood](../Images/55babde4ff6c7fb89b4b17f35c5037fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #12: Advertising Channel Effectiveness'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find the average effectiveness of each advertising channel in the period
    from 2017 to 2018 (both included). The effectiveness is calculated as the ratio
    of total money spent to total customers acquired. *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the advertising channel along with corresponding average effectiveness.
    Sort records by the average effectiveness in ascending order.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10012-advertising-channel-effectiveness?code_type=1](https://platform.stratascratch.com/coding/10012-advertising-channel-effectiveness?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: Every CTE starts with the keyword WITH, after which follows the name of the
    CTE. This is then followed by AS, and in the parentheses, you define the body
    of CTE, i.e., the SELECT statement, which you’ll call on in the outer query.
  prefs: []
  type: TYPE_NORMAL
- en: You should use the CTE in this example to sum the money spent and the acquired
    customers. You do all that for the years 2017 and 2018 by setting this condition
    in the WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: In the outer query, select the advertising channel and then divide the total
    money spent with the total number of customers acquired, which will give you the
    average effectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Sort the output by the effectiveness in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: '![advertising output](../Images/468f635202c80dc37c8ce120de174b37.png)'
  prefs: []
  type: TYPE_IMG
- en: 5\. CASE Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![CASE Statement](../Images/91dd159a682c52f33c22786f84de8f7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a conditional statement, an SQL version of an IF-THEN-ELSE logic. It
    instructs the code to go through a set of conditions that define which result
    should be returned depending on whether the data satisfies the condition or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CASE statement’s syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It also allows setting the multiple conditions, not only one.
  prefs: []
  type: TYPE_NORMAL
- en: '[The case statement](https://mode.com/sql-tutorial/sql-case/) is most commonly
    used when labeling data or with aggregate functions when the calculations are
    performed based on specific criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Interview Question #13: Bookings vs. Non-Bookings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Display the average number of times a user performed a search which led to
    a successful booking and the average number of times a user performed a search
    but did not lead to a booking. The output should have a column named action with
    values ''does not book'' and ''books'' as well as a 2nd column named average_searches
    with the average number of searches per action. Consider that the booking did
    not happen if the booking date is null. Be aware that search is connected to the
    booking only if their check-in dates match.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10124-bookings-vs-non-bookings?code_type=1](https://platform.stratascratch.com/coding/10124-bookings-vs-non-bookings?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll have to use both tables the question provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: airbnb_contacts'
  prefs: []
  type: TYPE_NORMAL
- en: '| id_guest | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| id_host | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| id_listing | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| ts_contact_at | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| ts_reply_at | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| ts_accepted_at | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| ts_booking_at | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| ds_checkin | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| ds_checkout | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| n_guests | int |'
  prefs: []
  type: TYPE_TB
- en: '| n_messages | int |'
  prefs: []
  type: TYPE_TB
- en: Here’s the data preview.
  prefs: []
  type: TYPE_NORMAL
- en: '![airbnb_contacts](../Images/5d545f421fa528aae8f364e53f3f2a42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table: airbnb_searches'
  prefs: []
  type: TYPE_NORMAL
- en: '| ds | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| id_user | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| ds_checkin | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| ds_checkout | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| n_searches | int |'
  prefs: []
  type: TYPE_TB
- en: '| n_nights | float |'
  prefs: []
  type: TYPE_TB
- en: '| n_guests_min | int |'
  prefs: []
  type: TYPE_TB
- en: '| n_guests_max | int |'
  prefs: []
  type: TYPE_TB
- en: '| origin_country | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| filter_price_min | float |'
  prefs: []
  type: TYPE_TB
- en: '| filter_price_max | float |'
  prefs: []
  type: TYPE_TB
- en: '| filter_room_types | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| filter_neighborhoods | datetime |'
  prefs: []
  type: TYPE_TB
- en: The first few rows from the table are shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![airbnb_searches](../Images/bc7dbc314a3d88d8cbc7550d325c7d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Solution Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: The solution uses the CASE statement in the SELECT statement to label data.
    When there is no-NULL value in the column ts_booking_at, it will get the label
    “books”. If it is NULL, it will become “does not book”. This CASE statement will
    show its results in the new column action.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there is an AVG() function in the SELECT statement for finding the average
    number of searches.
  prefs: []
  type: TYPE_NORMAL
- en: Data is fetched from both tables using the LEFT JOIN. In the end, the output
    is grouped by the data label.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: The above query returns the required output.
  prefs: []
  type: TYPE_NORMAL
- en: '![output](../Images/f9ee300607e00b134ab471984b057a34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #14: Churn Rate Of Lyft Drivers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find the global churn rate of Lyft drivers across all years. Output the rate
    as a ratio.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10016-churn-rate-of-lyft-drivers?code_type=1](https://platform.stratascratch.com/coding/10016-churn-rate-of-lyft-drivers?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: This question asks you to use the CASE statement in the aggregate function;
    COUNT(), to be precise. Use it to count the drivers that left, which are those
    whose end date is not NULL. Divide the result by the total number of drivers,
    and cast this into the decimal numbers.
  prefs: []
  type: TYPE_NORMAL
- en: If you do everything right, you should get the churn rate.
  prefs: []
  type: TYPE_NORMAL
- en: '![global churn rate](../Images/db6e606670b2a402b7b6fba8aa175769.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #15: Find the Number of Employees Who Received the Bonus
    and Who Didn’t'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find the number of employees who received the bonus and who didn''t.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output an indication of whether the bonus was received or not along with the
    corresponding number of employees.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*    ex: if the bonus was received: 1, if not: 0.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10081-find-the-number-of-employees-who-received-the-bonus-and-who-didnt?code_type=1](https://platform.stratascratch.com/coding/10081-find-the-number-of-employees-who-received-the-bonus-and-who-didnt?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a subquery in this solution. The subquery uses the CASE statement to
    determine the employees who did receive the bonus and who didn’t. It’s done based
    on the bonus date and whether the value is NULL or not. To do that, you will need
    to join both tables from the question using the LEFT JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: The main query will use this result to count the number of employees with and
    without the bonus.
  prefs: []
  type: TYPE_NORMAL
- en: '![has bouns](../Images/37fc510f5fb718ce8b9ce2f8ef42a2f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 6\. Window Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Window Functions](../Images/25a0a565eed279c056d4ffa562363be4.png)'
  prefs: []
  type: TYPE_IMG
- en: Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [SQL window functions](https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-window-functions/)
    are similar to the aggregate functions. The difference is that the window functions
    aggregate data in a way that makes it possible to show both individual rows and
    aggregated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, there are three distinct types of window functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate Window Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranking Window Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value Window Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Aggregate Window Functions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| COUNT() | Counts the number of rows. |'
  prefs: []
  type: TYPE_TB
- en: '| SUM() | Sums the values. |'
  prefs: []
  type: TYPE_TB
- en: '| AVG() | Returns the average value. |'
  prefs: []
  type: TYPE_TB
- en: '| MIN() | Returns the minimum value. |'
  prefs: []
  type: TYPE_TB
- en: '| MAX() | Returns the maximum value. |'
  prefs: []
  type: TYPE_TB
- en: '| **Ranking Window Functions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| ROW_NUMBER() | Ranks rows sequentially without skipping the row number and
    gives the same rank to the rows with the same values. |'
  prefs: []
  type: TYPE_TB
- en: '| RANK() | Used for ranking, with the same values given the same ranking and
    the next rank being skipped. |'
  prefs: []
  type: TYPE_TB
- en: '| DENSE_RANK() | Used for ranking, with the same values given the same ranking
    and the next rank not being skipped. |'
  prefs: []
  type: TYPE_TB
- en: '| PERCENT_RANK() | Ranks the values in a percent value.  |'
  prefs: []
  type: TYPE_TB
- en: '| NTILE() | Divides rows into a number of equally sized groups. |'
  prefs: []
  type: TYPE_TB
- en: '| **Value Window Functions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| LAG() | Allows accessing data from the defined number of preceding rows.
    |'
  prefs: []
  type: TYPE_TB
- en: '| LEAD() | Allows accessing data from the defined number of the following rows.
    |'
  prefs: []
  type: TYPE_TB
- en: '| FIRST_VALUE() | Returns the first value from the data. |'
  prefs: []
  type: TYPE_TB
- en: '| LAST_VALUE() | Returns the last value from the data. |'
  prefs: []
  type: TYPE_TB
- en: '| NTH_VALUE() | Returns the value from the defined (nth) row.  |'
  prefs: []
  type: TYPE_TB
- en: The window functions are called that for a reason. They do calculations over
    the rows that are related to the current row. The current row and all related
    rows are called a window frame.
  prefs: []
  type: TYPE_NORMAL
- en: There are five clauses important for using the window functions.
  prefs: []
  type: TYPE_NORMAL
- en: OVER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PARTITION BY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORDER BY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RANGE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OVER clause is mandatory, and its purpose is to call the window function.
    Without it, there are no window functions.
  prefs: []
  type: TYPE_NORMAL
- en: The PARTITION BY is used for partitioning data. By specifying the column(s)
    in it, you’re instructing the window function on which subset of data the calculation
    should be performed. When the PARTITION BY is omitted, the window function takes
    the whole table as a data set.
  prefs: []
  type: TYPE_NORMAL
- en: The ORDER BY clause is also an optional clause. It specifies the logical order
    within each data set. In other words, it’s not used for sorting the output but
    for setting the direction in which the window function will work. Data can be
    ordered in ascending or descending order.
  prefs: []
  type: TYPE_NORMAL
- en: Within the partition, you can additionally limit the rows that will be included
    in the window function’s calculation. This is called defining a window frame.
  prefs: []
  type: TYPE_NORMAL
- en: The ROWS clause defines a fixed number of rows preceding and following the current
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The RANGE does the same, except not based on the number of rows but their value
    compared to the current row.
  prefs: []
  type: TYPE_NORMAL
- en: The window functions increase the analytical possibilities of SQL. By using
    them, you can show aggregated and non-aggregated data side by side, aggregate
    on multiple levels, rank data, and do a number of other operations that are not
    possible with only the aggregate functions.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Interview Question #16: Average Salaries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Compare each employee''s salary with the average salary of the corresponding
    department.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the department, first name, and salary of employees along with the
    average salary of that department.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9917-average-salaries?code_type=1](https://platform.stratascratch.com/coding/9917-average-salaries?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**'
  prefs: []
  type: TYPE_NORMAL
- en: There’s one table named employee.
  prefs: []
  type: TYPE_NORMAL
- en: '| id | int |'
  prefs: []
  type: TYPE_TB
- en: '| first_name | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| last_name | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| age | int |'
  prefs: []
  type: TYPE_TB
- en: '| sex | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| employee_title | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| department | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| salary | int |'
  prefs: []
  type: TYPE_TB
- en: '| target | int |'
  prefs: []
  type: TYPE_TB
- en: '| bonus | int |'
  prefs: []
  type: TYPE_TB
- en: '| email | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| city | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| address | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| manager_id | int |'
  prefs: []
  type: TYPE_TB
- en: Here’s the employee data.
  prefs: []
  type: TYPE_NORMAL
- en: '![the employee data](../Images/4bc11f82a38c125bbef2745baed6bcba.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Solution Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: The query selects the department, employee’s first name, and their salary. The
    fourth column will calculate the AVG() salary. Since it’s a window function, it
    has to be called using the OVER() clause. By using department as data partition,
    the query will return the average salary by department instead of the overall
    salary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: These are only the first five rows of the complete output.
  prefs: []
  type: TYPE_NORMAL
- en: '![output](../Images/fb5ea3a0cf80e687393049b3faf70103.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #17: Ranking Most Active Guests'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Rank guests based on the number of messages they''ve exchanged with the hosts.
    Guests with the same number of messages as other guests should have the same rank.
    Do not skip rankings if the preceding rankings are identical.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Output the rank, guest id, and the number of total messages they''ve sent.
    Order by the highest number of total messages first.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10159-ranking-most-active-guests?code_type=1](https://platform.stratascratch.com/coding/10159-ranking-most-active-guests?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you need to use the ranking window function, namely the DENSE_RANK() function.
    There will be no data ,partitioning, but use the ORDER BY to rank the sum of the
    messages from the highest to the lowest. Additionally, select the guest ID and
    calculate the sum of messages outside the window function.
  prefs: []
  type: TYPE_NORMAL
- en: Group data by the guest ID and sort data from the highest to the lowest number
    of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Your output should look something like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![guest rank](../Images/b9f01df96cbf23522eec59396c594c94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #18: Cum Sum Energy Consumption'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Calculate the running total (i.e., cumulative sum) energy consumption of
    the Meta/Facebook data centers in all 3 continents by the date. Output the date,
    running total energy consumption, and running total percentage rounded to the
    nearest whole number.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/10084-cum-sum-energy-consumption?code_type=1](https://platform.stratascratch.com/coding/10084-cum-sum-energy-consumption?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a hard question that covers most of the topics I talked about. First,
    you need to write a CTE. Use it to write three SELECT statements that select all
    data from each table and join the outputs using the UNION ALL.
  prefs: []
  type: TYPE_NORMAL
- en: The second CTE will use data from the first CTE to fetch the total energy consumption
    by date using the SUM() aggregate function.
  prefs: []
  type: TYPE_NORMAL
- en: The outer query uses the data from the second CTE in the following way. The
    SUM() window function calculates the cumulative sum by ordering data from the
    oldest to the newest date.
  prefs: []
  type: TYPE_NORMAL
- en: Then this same window function is divided by the total energy consumption –
    which you can get by summing the energy consumption by date – and multiplying
    by 100 to get the percentage. Use the ROUND() function to show the result as rounded
    to the nearest whole number, i.e., there will be no decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: There it is, the output that will get you points from the interviewer.
  prefs: []
  type: TYPE_NORMAL
- en: '![cumulative energy](../Images/c5535bbe224fa0173b32bfcb6d3d0564.png)'
  prefs: []
  type: TYPE_IMG
- en: 7\. Text & Date Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Text & Date Manipulation](../Images/cd714162e4e2c3e4ee09440ebc11f747.png)'
  prefs: []
  type: TYPE_IMG
- en: Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data scientists often have to handle text and dates/time in the databases,
    not only numerical values. This usually means creating one string from several
    ones or using only the part of the date (like day, month, year) or a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common [text manipulation functions](https://www.tutorialspoint.com/sql/sql-string-functions.htm)
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Text Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; or CONCAT() | Concatenates multiple string values into one. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| CHAR_LENGTH() | Returns the of characters in a string. |'
  prefs: []
  type: TYPE_TB
- en: '| LOWER() | Converts the string to all lowercase.  |'
  prefs: []
  type: TYPE_TB
- en: '| UPPER() | Converts the string to all uppercase. |'
  prefs: []
  type: TYPE_TB
- en: '| SUBSTRING() | Returns the part of the string.  |'
  prefs: []
  type: TYPE_TB
- en: '| TRIM() | Deletes space or any other character from the start and end of a
    string.  |'
  prefs: []
  type: TYPE_TB
- en: '| LTRIM() | Deletes space or any other character from the start of a string. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| RTRIM() | Deletes space or any other character from the end of a string. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| LEFT() | Returns the defined number of characters from the start of a string. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| RIGHT() | Returns the defined number of characters from the end of a string.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The two most often used [date/time functions](https://www.postgresql.org/docs/8.1/functions-datetime.html)
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Date/Time Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| EXTRACT() | Returns the part of the date or time; SQL standard.  |'
  prefs: []
  type: TYPE_TB
- en: '| DATE_PART() | Returns the part of the date or time; PostgreSQL specific. 
    |'
  prefs: []
  type: TYPE_TB
- en: Text & date/time functions come in handy for data scientists when they clean
    data. Of course, they can also perform calculations using the date/time functions,
    such as adding or subtracting time periods, and use it for data filtering, aggregation,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Interview Question #19: Pending Claims'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Count how many claims submitted in December 2021 are still pending. A claim
    is pending when it has neither an acceptance nor rejection date.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/2083-pending-claims?code_type=1](https://platform.stratascratch.com/coding/2083-pending-claims?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**'
  prefs: []
  type: TYPE_NORMAL
- en: The question gives you the table cvs_claims.
  prefs: []
  type: TYPE_NORMAL
- en: '| claim_id | int |'
  prefs: []
  type: TYPE_TB
- en: '| account_id | varchar |'
  prefs: []
  type: TYPE_TB
- en: '| date_submitted | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| date_accepted | datetime |'
  prefs: []
  type: TYPE_TB
- en: '| date_rejected | datetime |'
  prefs: []
  type: TYPE_TB
- en: Make yourself familiar with the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![data](../Images/48b991d627a626c57d97ae1dc38c8ee0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Solution Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: The COUNT() function is here for getting the number of claims. You need to count
    only the claims satisfying the certain criteria. Two criteria are set up with
    the help of the EXTRACT() function. The first one is used for extracting the month
    from the claim submission date. The other EXTRACT() function will get the year
    from the same column. That way, you get claims submitted in December 2021.
  prefs: []
  type: TYPE_NORMAL
- en: The next two criteria in the WHERE clause will show only claims that are not
    yet accepted nor rejected, i.e., they are pending.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![ive pending claims submitted in December 2021](../Images/f3487fbb71e85f3d608ba5051c6bf559.png)'
  prefs: []
  type: TYPE_IMG
- en: This solution shows there are five pending claims submitted in December 2021.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Interview Question #20: Rush Hour Calls'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Redfin helps clients to find agents. Each client will have a unique request_id,
    and each request_id has several calls. For each request_id, the first call is
    an “initial call”, and all the following calls are “update calls”.  How many customers
    have called 3 or more times between 3 PM and 6 PM (initial and update calls combined)?”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/2023-rush-hour-calls?code_type=1](https://platform.stratascratch.com/coding/2023-rush-hour-calls?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: The solution uses the DATE_PART() function instead of EXTRACT(). It does that
    in the subquery in the FROM clause. The subquery shows the clients, but not all
    of them. First, data is filtered and cast to timestamp using the WHERE clause
    and D,ATE_PART() so the subquery will return only the clients making calls between
    15 and 17 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Data is additionally filtered after grouping using the HAVING clause. The condition
    shows only customers with three or more calls in the above time period.
  prefs: []
  type: TYPE_NORMAL
- en: This result will be used in the main query only for counting the number of customers.
  prefs: []
  type: TYPE_NORMAL
- en: Only one customer called three or more times between 15:00 and 17:00.
  prefs: []
  type: TYPE_NORMAL
- en: '![one customer called three or more times between 15:00 and 17:00](../Images/405366a85904004e2a0111d6e31aaf9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQL Interview Question #21: Rules To Determine Grades'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*“Find the rules used to determine each grade. Show the rule in a separate
    column in the format of ''Score > X AND Score <= Y => Grade = A'' where X and
    Y are the lower and upper bounds for a grade. Output the corresponding grade and
    its highest and lowest scores along with the rule. Order the result based on the
    grade in ascending order.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/coding/9700-rules-to-determine-grades?code_type=1](https://platform.stratascratch.com/coding/9700-rules-to-determine-grades?code_type=1&utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SELECT statement returns the minimum and maximum score per grade. The last
    column is used for labeling the rules with the concatenate function. Use both
    MIN() and MAX() functions to get the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Grade A: score > 89 and <= 100'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grade B: score > 79 and <= 88'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grade C: score > 69 and <= 79'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the labels have to be formatted as is required.
  prefs: []
  type: TYPE_NORMAL
- en: The output is grouped by and ordered by grade.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the rules.
  prefs: []
  type: TYPE_NORMAL
- en: '![grouped by and ordered by grade](../Images/a3c5e11f1c149741d71770f7bd6fd084.png)'
  prefs: []
  type: TYPE_IMG
- en: SQL Theoretical Interview Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These questions test the SQL knowledge, too, the same as the coding questions.
    The difference is they don’t require writing a code, but you have to explain SQL
    concepts or the difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some examples of such questions, all testing the topics I mentioned
    in the coding questions section.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Interview Question #22: WHERE and HAVING'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*“What is the main difference between a WHERE clause and a HAVING clause in
    SQL?”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/technical/2374-where-and-having](https://platform.stratascratch.com/technical/2374-where-and-having?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: Both WHERE and HAVING are used for filtering data. The main difference is that
    the WHERE clause is used for filtering data before aggregation and GROUP BY. The
    HAVING clause filters already aggregated data and is written after the GROUP BY
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Interview Question #23: Left Join and Right Join'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*“What is the difference between a left join and a right join in SQL?”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/technical/2242-left-join-and-right-join](https://platform.stratascratch.com/technical/2242-left-join-and-right-join?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start off by explaining the similarities of these two outer joins.
    Then you can talk about their differences. Hint: the clue is in the ‘left’ and
    ‘right’.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Interview Question #24: Common Table Expression'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*“In SQL, what is a Common Table Expression? Give an example of a situation
    when you would use it.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Link to the question: [https://platform.stratascratch.com/technical/2354-common-table-expression](https://platform.stratascratch.com/technical/2354-common-table-expression?utm_source=blog&utm_medium=click&utm_campaign=kdnuggets)'
  prefs: []
  type: TYPE_NORMAL
- en: You already saw how the CTEs work. You could talk about comparing them with
    subqueries and then give an example of a CTE use. There you have it in the coding
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SQL interview questions usually come in two forms: coding and non-coding.
    Both question types most often test “The Unavoidable Seven”. You can’t even think
    of going to the interview without seven crucial SQL concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: Focus on them to cover the most SQL questions that can come up at the interview.
    The question difficulty is also one variable, so there can be a big difference
    in the knowledge required for solving the easy and hard questions.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Nate Rosidi](https://www.stratascratch.com)** is a data scientist and in
    product strategy. He''s also an adjunct professor teaching analytics, and is the
    founder of [StrataScratch](https://www.stratascratch.com/), a platform helping
    data scientists prepare for their interviews with real interview questions from
    top companies. Connect with him on [Twitter: StrataScratch](https://twitter.com/StrataScratch)
    or [LinkedIn](https://www.linkedin.com/in/nathanrosidi/).'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[5 Pandas Plotting Functions You Might Not Know](https://www.kdnuggets.com/2023/02/5-pandas-plotting-functions-might-know.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 10 Advanced Data Science SQL Interview Questions You Must Know…](https://www.kdnuggets.com/2023/01/top-10-advanced-data-science-sql-interview-questions-must-know-answer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL Interview Questions for Experienced Professionals](https://www.kdnuggets.com/2022/01/sql-interview-questions-experienced-professionals.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[25 Advanced SQL Interview Questions for Data Scientists](https://www.kdnuggets.com/2022/10/25-advanced-sql-interview-questions-data-scientists.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3 More SQL Aggregate Function Interview Questions for Data Science](https://www.kdnuggets.com/2023/01/3-sql-aggregate-function-interview-questions-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL and Python Interview Questions for Data Analysts](https://www.kdnuggets.com/2023/02/sql-python-interview-questions-data-analysts.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
