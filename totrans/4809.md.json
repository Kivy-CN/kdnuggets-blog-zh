["```py\n\n# Inputs of the equation.\nequation_inputs = [4,-2,3.5,5,-11,-4.7]\n# Number of the weights we are looking to optimize.\nnum_weights = 6\n\n```", "```py\n\nimport numpy\n\nsol_per_pop = 8\n# Defining the population size.\npop_size = (sol_per_pop,num_weights) # The population will have sol_per_pop chromosome where each chromosome has num_weights genes.\n#Creating the initial population.\nnew_population = numpy.ram.uniform(low=-4.0, high=4.0, size=pop_size)\n```", "```py\n\n[[-2.19134006 -2.88907857  2.02365737 -3.97346034  3.45160502  2.05773249]\n\n [ 2.12480298  2.97122243  3.60375452  3.78571392  0.28776565  3.5170347 ]\n\n [ 1.81098962  0.35130155  1.03049548 -0.33163294  3.52586421  2.53845644]\n\n [-0.63698911 -2.8638447   2.93392615 -1.40103767 -1.20313655  0.30567304]\n\n [-1.48998583 -1.53845766  1.11905299 -3.67541087  1.33225142  2.86073836]\n\n [ 1.14159503  2.88160332  1.74877772 -3.45854293  0.96125878  2.99178241]\n\n [ 1.96561297  0.51030292  0.52852716 -1.56909315 -2.35855588  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -0.72163167  0.7516408   0.00677938]]\n\n```", "```py\n\nimport GA\nnum_generations = 5\n\nnum_parents_mating = 4\nfor generation in range(num_generations):\n    # Measuring the fitness of each chromosome in the population.\n    fitness = GA.cal_pop_fitness(equation_inputs, new_population)\n\n    # Selecting the best parents in the population for mating.\n    parents = GA.select_mating_pool(new_population, fitness, \n                                      num_parents_mating)\n\n    # Generating next generation using crossover.\n    offspring_crossover = GA.crossover(parents,\n                                       offspring_size=(pop_size[0]-parents.shape[0], num_weights))\n\n    # Adding some variations to the offsrping using mutation.\n    offspring_mutation = GA.mutation(offspring_crossover)\n\n    # Creating the new population based on the parents and offspring.\n    new_population[0:parents.shape[0], :] = parents\n    new_population[parents.shape[0]:, :] = offspring_mutation\n```", "```py\n\ndef cal_pop_fitness(equation_inputs, pop):\n    # Calculating the fitness value of each solution in the current population.\n    # The fitness function calculates the sum of products between each input and its corresponding weight.\n    fitness = numpy.sum(pop*equation_inputs, axis=1)\n    return fitness\n```", "```py\n\n[-63.41070188  14.40299221 -42.22532674  18.24112489 -45.44363278 -37.00404311  15.99527402  17.0688537 ]\n```", "```py\n\ndef select_mating_pool(pop, fitness, num_parents):\n    # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\n    parents = numpy.empty((num_parents, pop.shape[1]))\n    for parent_num in range(num_parents):\n        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))\n        max_fitness_idx = max_fitness_idx[0][0]\n        parents[parent_num, :] = pop[max_fitness_idx, :]\n        fitness[max_fitness_idx] = -99999999999\n    return parents\n```", "```py\n\nparents = numpy.empty((num_parents, pop.shape[1]))\n```", "```py\n\nmax_fitness_idx = numpy.where(fitness == numpy.max(fitness))\n```", "```py\n\nparents[parent_num, :] = pop[max_fitness_idx, :]\n```", "```py\n\n[[-0.63698911 -2.8638447   2.93392615 -1.40103767 -1.20313655  0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -0.72163167  0.7516408   0.00677938]\n\n [ 1.96561297  0.51030292  0.52852716 -1.56909315 -2.35855588  2.29682254]\n\n [ 2.12480298  2.97122243  3.60375452  3.78571392  0.28776565  3.5170347 ]]\n```", "```py\n\ndef crossover(parents, offspring_size):\n    offspring = numpy.empty(offspring_size)\n    # The point at which crossover takes place between two parents. Usually, it is at the center.\n    crossover_point = numpy.uint8(offspring_size[1]/2)\n\n    for k in range(offspring_size[0]):\n        # Index of the first parent to mate.\n        parent1_idx = k%parents.shape[0]\n        # Index of the second parent to mate.\n        parent2_idx = (k+1)%parents.shape[0]\n        # The new offspring will have its first half of its genes taken from the first parent.\n        offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]\n        # The new offspring will have its second half of its genes taken from the second parent.\n        offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]\n```", "```py\n\noffspring = numpy.empty(offspring_size)\n```", "```py\n\ncrossover_point = numpy.uint8(offspring_size[1]/2)\n```", "```py\n\nparent1_idx = k%parents.shape[0]\nparent2_idx = (k+1)%parents.shape[0]\n```", "```py\n\n[[-0.63698911 -2.8638447   2.93392615 -0.72163167  0.7516408   0.00677938]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.35855588  2.29682254]\n\n [ 1.96561297  0.51030292  0.52852716  3.78571392  0.28776565  3.5170347 ]\n\n [ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.20313655  0.30567304]]\n```", "```py\n\ndef mutation(offspring_crossover):\n    # Mutation changes a single gene in each offspring randomly.\n    for idx in range(offspring_crossover.shape[0]):\n        # The random value to be added to the gene.\n        random_value = numpy.random.uniform(-1.0, 1.0, 1)\n        offspring_crossover[idx, 4] = offspring_crossover[idx, 4] + random_value\n```", "```py\n\nrandom_value = numpy.random.uniform(-1.0, 1.0, 1)\n```", "```py\n\noffspring_crossover[idx, 4] = offspring_crossover[idx, 4] + random_value\n```", "```py\n\n[[-0.63698911 -2.8638447   2.93392615 -0.72163167  1.66083721  0.00677938]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]\n\n [ 1.96561297  0.51030292  0.52852716  3.78571392  0.45337472  3.5170347 ]\n\n [ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.5781162   0.30567304]]\n```", "```py\n\nnew_population[0:parents.shape[0], :] = parents\n\nnew_population[parents.shape[0]:, :] = offspring_mutation\n```", "```py\n\n[ 18.24112489  17.0688537   15.99527402  14.40299221  -8.46075629  31.73289712   6.10307563  24.08733441]\n```", "```py\n\nGeneration :  1\n\nFitness values:\n\n[ 18.24112489  17.0688537   15.99527402  14.40299221  -8.46075629  31.73289712   6.10307563  24.08733441]\n\nSelected parents:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]\n\n [ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.5781162   0.30567304]\n\n [-0.63698911 -2.8638447   2.93392615 -1.40103767 -1.20313655  0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -0.72163167  0.7516408   0.00677938]]\n\nCrossover result:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.5781162   0.30567304]\n\n [ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.20313655  0.30567304]\n\n [-0.63698911 -2.8638447   2.93392615 -0.72163167  0.7516408   0.00677938]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]]\n\nMutation result:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]\n\n [ 2.12480298  2.97122243  3.60375452 -1.40103767 -0.38610586  0.30567304]\n\n [-0.63698911 -2.8638447   2.93392615 -0.72163167  1.33639943  0.00677938]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.13941727  2.29682254]]\n\nBest result after generation 1 :  34.1663669207\n\nGeneration :  2\n\nFitness values:\n\n[ 31.73289712  24.08733441  18.24112489  17.0688537   34.16636692  10.97522073  -4.89194068  22.86998223]\n\nSelected Parents:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]\n\n [ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.5781162   0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.13941727  2.29682254]]\n\nCrossover result:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.5781162   0.30567304]\n\n [ 2.12480298  2.97122243  3.60375452 -1.56909315 -1.13941727  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]]\n\nMutation result:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -0.73543721  0.30567304]\n\n [ 2.12480298  2.97122243  3.60375452 -1.56909315 -0.50581509  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.20089639  0.30567304]]\n\nBest result after generation 2:  34.5930432629\n\nGeneration :  3\n\nFitness values:\n\n[ 34.16636692  31.73289712  24.08733441  22.86998223  34.59304326  28.6248816    2.09334217  33.7449326 ]\n\nSelected parents:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.20089639  0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]]\n\nCrossover result:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.20089639  0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]]\n\nMutation result:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -2.20744102  0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.16589294  0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.37553107  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.44124005  2.29682254]]\n\nBest result after generation 3:  44.8169235189\n\nGeneration :  4\n\nFitness values\n\n[ 34.59304326  34.16636692  33.7449326   31.73289712  44.81692352\n\n  33.35989464  36.46723397  37.19003273]\n\nSelected parents:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -2.20744102  0.30567304]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.44124005  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.37553107  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]]\n\nCrossover result:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.37553107  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -2.20744102  0.30567304]]\n\nMutation result:\n\n[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.13382082  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.98105233  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.27638584  2.29682254]\n\n [ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.70558545  0.30567304]]\n\nBest result after generation 4:  44.8169235189\n\n```", "```py\n\n[3.00912373 -2.745417    3.27131287 -1.40103767 -2.20744102  0.30567304]\n```", "```py\n\nimport numpy\nimport GA\n\n\"\"\"\nThe y=target is to maximize this equation ASAP:\n    y = w1x1+w2x2+w3x3+w4x4+w5x5+6wx6\n    where (x1,x2,x3,x4,x5,x6)=(4,-2,3.5,5,-11,-4.7)\n\n    What are the best values for the 6 weights w1 to w6?\n    We are going to use the genetic algorithm for the best possible values after a number of generations.\n\"\"\"\n\n# Inputs of the equation.\nequation_inputs = [4,-2,3.5,5,-11,-4.7]\n\n# Number of the weights we are looking to optimize.\nnum_weights = 6\n\n\"\"\"\nGenetic algorithm parameters:\n    Mating pool size\n    Population size\n\"\"\"\n\nsol_per_pop = 8\nnum_parents_mating = 4\n\n# Defining the population size.\npop_size = (sol_per_pop,num_weights) # The population will have sol_per_pop chromosome where each chromosome has num_weights genes.\n\n#Creating the initial population.\nnew_population = numpy.random.uniform(low=-4.0, high=4.0, size=pop_size)\nprint(new_population)\n\nnum_generations = 5\n\nfor generation in range(num_generations):\n    print(\"Generation : \", generation)\n\n    # Measing the fitness of each chromosome in the population.\n    fitness = GA.cal_pop_fitness(equation_inputs, new_population)\n\n    # Selecting the best parents in the population for mating.\n    parents = GA.select_mating_pool(new_population, fitness, \n                                      num_parents_mating)\n\n    # Generating next generation using crossover.\n    offspring_crossover = GA.crossover(parents,\n                                       offspring_size=(pop_size[0]-parents.shape[0], num_weights))\n\n    # Adding some variations to the offsrping using mutation.\n    offspring_mutation = GA.mutation(offspring_crossover)\n\n    # Creating the new population based on the parents and offspring.\n    new_population[0:parents.shape[0], :] = parents\n    new_population[parents.shape[0]:, :] = offspring_mutation\n\n    # The best result in the current iteration.\n    print(\"Best result : \", numpy.max(numpy.sum(new_population*equation_inputs, axis=1)))\n\n# Getting the best solution after iterating finishing all generations.\n#At first, the fitness is calculated for each solution in the final generation.\nfitness = GA.cal_pop_fitness(equation_inputs, new_population)\n\n# Then return the index of that solution corresponding to the best fitness.\nbest_match_idx = numpy.where(fitness == numpy.max(fitness))\n\nprint(\"Best solution : \", new_population[best_match_idx, :])\nprint(\"Best solution fitness : \", fitness[best_match_idx])\n\n```", "```py\n\nimport numpy\n\ndef cal_pop_fitness(equation_inputs, pop):\n    # Calculating the fitness value of each solution in the current population.\n    # The fitness function caulcuates the sum of products between each input and its corresponding weight.\n    fitness = numpy.sum(pop*equation_inputs, axis=1)\n    return fitness\n\ndef select_mating_pool(pop, fitness, num_parents):\n    # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\n    parents = numpy.empty((num_parents, pop.shape[1]))\n    for parent_num in range(num_parents):\n        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))\n        max_fitness_idx = max_fitness_idx[0][0]\n        parents[parent_num, :] = pop[max_fitness_idx, :]\n        fitness[max_fitness_idx] = -99999999999\n    return parents\n\ndef crossover(parents, offspring_size):\n    offspring = numpy.empty(offspring_size)\n    # The point at which crossover takes place between two parents. Usually it is at the center.\n    crossover_point = numpy.uint8(offspring_size[1]/2)\n\n    for k in range(offspring_size[0]):\n        # Index of the first parent to mate.\n        parent1_idx = k%parents.shape[0]\n        # Index of the second parent to mate.\n        parent2_idx = (k+1)%parents.shape[0]\n        # The new offspring will have its first half of its genes taken from the first parent.\n        offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]\n        # The new offspring will have its second half of its genes taken from the second parent.\n        offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]\n    return offspring\n\ndef mutation(offspring_crossover):\n    # Mutation changes a single gene in each offspring randomly.\n    for idx in range(offspring_crossover.shape[0]):\n        # The random value to be added to the gene.\n        random_value = numpy.random.uniform(-1.0, 1.0, 1)\n        offspring_crossover[idx, 4] = offspring_crossover[idx, 4] + random_value\n\n```"]