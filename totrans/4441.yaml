- en: 3 Advanced Python Features You Should Know
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2020/07/3-advanced-python-features.html](https://www.kdnuggets.com/2020/07/3-advanced-python-features.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[comments](#comments)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3558bedbb897e8956c59a41112d451d0.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Photo by [David Clode](https://unsplash.com/@davidclode?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral).*'
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I will discuss 3 important features of Python that comes in
    handy for a data scientist and saves a lot of time. Let’s begin without wasting
    any time.
  prefs: []
  type: TYPE_NORMAL
- en: List & Dict Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: List & Dict Comprehensions are a very powerful tool in Python that comes in
    handy to make lists. It saves time, easy in syntax, and makes the logic easier
    as compared to making a list using normal Python for-loop.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, these are used instead of an explicit for-loop with simple logic
    inside it that appends or does something with a list or dictionary. These are
    single line and makes the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '**List Comprehensions**'
  prefs: []
  type: TYPE_NORMAL
- en: Will will see a normal python example first and then will see it’s equivalent
    using *list comprehensions*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we have a simple dataframe in Pandas with students results in 3 subjects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And if we print it,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s say we want to make a list with maximum marks of each subject, i.e.,
    that list should be equal to [10,8,9] because these are maximum marks of each
    subject.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And, if we print it,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Using List Comprehensions**'
  prefs: []
  type: TYPE_NORMAL
- en: The basic syntax for a list comprehension is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we can do anything with *varname *to modify it.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, our list comprehension would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And our output would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Do you see how it resembles our Python code? We were appending *max(results[i])* in *maxlist*
    inside the loop in normal Python code, here we are not appending it, but anything
    you want to append should the first argument in the list comprehension. So now
    I can rewrite the basic syntax as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Hence, in our examples, we wanted to append the maximum of each row in a dataframe,
    i.e., *max(results[i])* so we used
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Dictionary Comprehension**'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we use the same idea for dictionary comprehension. Basic syntax normally
    used is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For example, let’s say that I have a dummy table for the English alphabet,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we want to use numbers (0–25) as our values of the dictionary because
    a machine learning model can only process numbers, and we want to feed the dictionary
    values, w need to swap the keys and values of a dictionary. The easiest way to
    swap the keys and values in the dictionary is using *dict comprehension*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you focus on it for a second, it will start making sense that how it is reversing
    a dictionary, that we are looping *alphabet* and *number *which is the normal
    order of dictionary but what we want to insert is in reverse order so we are using *number:alphabet* instead
    of *alphaber:number*.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lambda Expressions are a very powerful tool for data scientists. They come in
    very handy especially when used with *DataFrame.apply()*, *map()*, *filter()*
    or *reduce()*. They provide an easy way to avoid manually defined functions and
    to write them in a single line making code more clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the basic syntax of Lambda Expression, where we return the next number
    of any number passed in any function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, our function argument is *functionArgument1,* and we are returning *functionArgument1*
    +1 which is the next number.
  prefs: []
  type: TYPE_NORMAL
- en: So to use it,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See, it is that simple. Let’s see a real-world example where we have a dataframe
    of names (taken from the titanic dataset), and we want to make a feature where
    we want to extract the title (Mr, Miss, Sir etc.) from the name.
  prefs: []
  type: TYPE_NORMAL
- en: So, the code for our data frame is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: and the dataframe is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a116a91303482d66adce66321b2f3da7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if we notice that we find a specific pattern here, which is that we have
    a comma after the first name and ‘full stop’ after the title that we want to extract.
    So we can use *list slicing* to extract from the comma until the full stop.
  prefs: []
  type: TYPE_NORMAL
- en: We want to slice from 2 indexes next to a comma because we don't want to include
    a comma and space after comma so our starting index will be *str.find(',')+2*,
    and we want to slice to the full stop (not included), so we will slice until *str.find('.')*.
    Luckily, the last index is not included, so we do not need to do -1 explicitly
    from the index. Let’s use a lambda expression to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using the *.apply* function from pandas on df[0], which is the column
    having all the names. Inside it, we are passing a lambda expression that takes
    in each name and returns the sliced version of that name. This sliced version
    is the title of that name. The output of our dataframe now is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ce7ed4504840075602bc1fc09d34eb27.png)'
  prefs: []
  type: TYPE_IMG
- en: And here, we can see that how we extracted the titles from the name using this
    pretty clear trick.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions are very useful when applied with *map*, *reduce *or *filter *in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Map Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, Map functions are very commonly used functions, which makes our work
    very easier. The idea of *map *is that when passed a function and an iterable
    in *map*, it performs that function on every single entity of that iterable.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that I have an iterable that is a list with the following data *[0,
    5, 10, 15, 20, 25, 30]*, and a custom function *isEven(anyInteger)* that tells
    if *anyInteger *passed into it is even or not. If we pass this function and the
    iterable into *map*, then it will automatically apply this function to all the
    entities in the list and return the *map *object, which we can convert into a
    list or tuple or dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say our function is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: and our iterable is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we want to use the traditional approach, then we would have to loop our list
    and apply the function to individual items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will return us a new list *isEvenList *with having True for Even and False
    for odd numbers.
  prefs: []
  type: TYPE_NORMAL
- en: To use it with *map *it will make our task much easier. Our code would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: and our code is done!
  prefs: []
  type: TYPE_NORMAL
- en: Here, what we are doing is that inside the *map *function, we are passing in
    our function *isEven* and our iterable *myList*, which is returning a *map *object
    which we are casting into *list*.
  prefs: []
  type: TYPE_NORMAL
- en: So basic syntax for the map function is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, Pandas offer *map*, *apply*, and *applymap *as built-in functions.
    They are very commonly used and are very helpful. The basic idea behind all these
    3 functions is the same as Python’s built-in map function. You can learn more
    about these functions in the official documentation of Pandas [here](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.map.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Python For Everybody: The Free eBook](https://www.kdnuggets.com/2020/05/python-everybody-free-ebook.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10 Python Tips and Tricks You Should Learn Today](https://www.kdnuggets.com/2020/01/10-python-tips-tricks-learn-today.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stop Hurting Your Pandas!](https://www.kdnuggets.com/2020/04/stop-hurting-pandas.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[KDnuggets News, April 13: Python Libraries Data Scientists Should…](https://www.kdnuggets.com/2022/n15.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 10 Advanced Data Science SQL Interview Questions You Must Know…](https://www.kdnuggets.com/2023/01/top-10-advanced-data-science-sql-interview-questions-must-know-answer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What You Should Know About Python Decorators And Metaclasses](https://www.kdnuggets.com/2023/03/know-python-decorators-metaclasses.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Three R Libraries Every Data Scientist Should Know (Even if You Use Python)](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[More Performance Evaluation Metrics for Classification Problems You…](https://www.kdnuggets.com/2020/04/performance-evaluation-metrics-classification.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Concepts You Should Know About Gradient Descent and Cost Function](https://www.kdnuggets.com/2020/05/5-concepts-gradient-descent-cost-function.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
