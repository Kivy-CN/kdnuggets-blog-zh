["```py\nfrom abc import ABC\n\nclass DatabaseConnector(ABC):\n\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n\n    @abc.abstractmethod\n    def connect(self):\n        pass\n\n    @abc.abstractmethod\n    def execute(self, sql: str):\n        pass\n```", "```py\nmysql = MySqlConnector(connection_string)\nmysql.connect()\nmysql.execute(\"SELECT * FROM public.table\")\n\ncassandra = CassandraDbConnector(connection_string)\ncassandra.connect()\ncassandra.execute(\"SELECT * FROM public.table\")\n```", "```py\n*\"This utils library will be used across all the ML data pipelines and feature engineering jobs to provide simple and reliable connectors to the different systems in the organization\".*\n```", "```py\n*\"This library contains a set of feature engineering methods, transformations and algorithms that can be used out-of-the-box with a simple interface that can be chained in a scikit-learn-type of pipeline\".*\n```", "```py\nclass NeptuneDbConnector:\n\t...\n\tdef close():\n\t    \"\"\"This function checks if the connection to the database\n             is opened. If it is, it closes it and if it doesnâ€™t,\n             it does nothing.\n          \"\"\" \n```", "```py\nclass NeptuneDbConnector:\n\t...\n\tdef close():\n\t    \"\"\"Closes connection to the database.\"\"\"\n```", "```py\n# Getting the maximum integer of the list\nl = [23, 49, 6, 32]\nreduce((lambda x, y: x if x > y else y), l)\n```", "```py\ndef extract(source: str) -> pd.DataFrame:\n    ...\n\ndef transform(data: pd.DataFrame) -> pd.DataFrame:\n    ...\n\ndef load(transformed_data: pd.DataFrame):\n    ...\n```", "```py\nfrom abc import ABC, abstractmethod\n\nclass BaseCollector(ABC):\n      @abstractmethod\n      def extract_sales() -> List[Sale]:\n            pass\n\nclass SalesAggregator:\n\n      def __init__(self, collectors: List[BaseCollector]):\n\t\tself.collectors = collectors\n\n      def get_sales(self) -> List[Sale]: \n\t\tsales = []\n\t\tfor collector in self.collectors:\n\t\t\tsales.extend(collector.extract_sales())\n\t\treturn sales\n\nclass StoreSalesCollector:\n\tdef extract_sales() -> List[Sale]:\n\t\t# Extract sales data from physical stores\n\nclass OnlineSalesCollector:\n\tdef extract_sales() -> List[Sale]:\n\t\t# Extract online sales data\n\nif __name__ == \"__main__\":\n     sales_aggregator = SalesAggregator(\n            collectors = [\n                StoreSalesCollector(),\n                OnlineSalesCollector()\n            ]\n     sales = sales_aggregator.get_sales()\n```", "```py\nfrom abc import ABC, abstractmethod\n\nclass DatabaseConnector(ABC):\n\tdef __init__(self, connection_string: str):\n\t\tself.connection_string = connection_string\n\n\t@abstractmethod\n\tdef connect():\n\t\tpass\n\n\t@abstractmethod\n\tdef execute_(query: str) -> pd.DataFrame:\n\t\tpass\n\nclass RedshiftConnector(DatabaseConnector):\n\tdef connect():\n\t# Redshift Connection implementation\n\n\tdef execute(query: str) -> pd.DataFrame:\n\t# Redshift Connection implementation\n\nclass BigQueryConnector(DatabaseConnector):\n\tdef connect():\n\t# BigQuery Connection implementation\n\n\tdef execute(query: str) -> pd.DataFrame:\n\t# BigQuery Connection implementation\n\nclass ETLQueryManager:\n\tdef __init__(self, connector: DatabaseConnector, connection_string: str):\n\t\tself.connector = connector(connection_string=connection_string).connect()\n\n\tdef run(self, sql_queries: List[str]):\n\t\tfor query in sql_queries:\n\t\t\tself.connector.execute(query=query)\n```", "```py\nfrom typer import Typer\n\napp = Typer()\n\n@app.command()\ndef run_etl(\n    environment: str,\n    start_date: str,\n    end_date: str,\n    threshold: int\n):\n    ...\n```", "```py\npython {file_name}.py run-etl --environment dev --start-date 2023/01/01 --end-date 2023/01/31 --threshold 10\n```", "```py\nfrom config import CONVERSION_FACTORS\n\ndef transform_data(data: pd.DataFrame) -> pd.DataFrame:\n    data = remove_duplicates(data=data)\n    data = encode_categorical_columns(data=data)\n    data[\"price_dollars\"] = data[\"price_euros\"] * CONVERSION_FACTORS[\"dollar-euro\"]\n    data[\"price_pounds\"] = data[\"price_euros\"] * CONVERSION_FACTORS[\"pound-euro\"]\n    return data\n```", "```py\nfrom config import CONVERSION_FACTOR\n\ndef transform_data(data: pd.DataFrame) -> pd.DataFrame:\n    data = remove_duplicates(data=data)\n    data = encode_categorical_columns(data=data)\n    data = convert_prices(data=data)\n    return data\n```", "```py\ndef transform_data(data: pd.DataFrame) -> pd.DataFrame:\n    reference_data = read_reference_data(table=\"public.references\")\n    data = data.join(reference_data, on=\"ref_id\")\n    return data\n```", "```py\ndef transform_data(data: pd.DataFrame, reference_data: pd.DataFrame) -> pd.DataFrame:\n    data = data.join(reference_data, on=\"ref_id\")\n    return data\n```"]