- en: 10 Amazing Machine Learning Visualizations You Should Know in 2023
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2022/11/10-amazing-machine-learning-visualizations-know-2023.html](https://www.kdnuggets.com/2022/11/10-amazing-machine-learning-visualizations-know-2023.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/94707c4df6887d0528c7e4b23ee48ee8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Editor
  prefs: []
  type: TYPE_NORMAL
- en: Data visualization plays an important role in machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data visualization use cases in machine learning include:'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter tuning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model performance evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating model assumptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding outliers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the most important features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying patterns and correlations between features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizations that are directly related to the above key things in machine
    learning are called ***machine learning visualizations***.
  prefs: []
  type: TYPE_NORMAL
- en: Creating machine learning visualizations is sometimes a complicated process
    as it requires a lot of code to write even in Python. But, thanks to Python's
    open-source **Yellowbrick** library, even complex machine learning visualizations
    can be created with less code. That library extends the Scikit-learn API and provides
    high-level functions for visual diagnostics that are not provided by Scikit-learn.
  prefs: []
  type: TYPE_NORMAL
- en: Today, I’ll discuss the following types of machine learning visualizations,
    their use cases and Yellowbrick implementation in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick — Quick start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installation of Yellowbrick can be done by running one of the following commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**pip **package installer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**conda** package installer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using Yellowbrick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yellowbrick visualizers have Scikit-learn-like syntax. A visualizer is an object
    that learns from data to produce a visualization. It is often used with a Scikit-learn
    estimator. To train a visualizer, we call its fit() method.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To save a plot created using a Yellowbrick visualizer, we call the show() method
    as follows. This will save the plot as a PNG file on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 1\. Principal Component Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principal component plot visualizes high-dimensional data in a 2D or 3D
    scatter plot. Therefore, this plot is extremely useful for identifying important
    patterns in high-dimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating this plot with the traditional method is complex and time-consuming.
    We need to apply PCA to the dataset first and then use the matplotlib library
    to create the scatter plot.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use Yellowbrick’s PCA visualizer class to achieve the same functionality.
    It utilizes the principal component analysis method, reduces the dimensionality
    of the dataset and creates the scatter plot with 2 or 3 lines of code! All we
    need to do is to specify some keyword arguments in the PCA() class.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example to further understand this. Here, we use the *breast_cancer* dataset
    (see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#6fde) at
    the end) which has 30 features and 569 samples of two classes (*Malignant* and* Benign*).
    Because of the high dimensionality (30 features) in the data, it is impossible
    to plot the original data in a 2D or 3D scatter plot unless we apply PCA to the
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s PCA visualizer
    to create a 2D scatter plot of a 30-dimensional dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/045f880cb835bfa38de67690ac085953.png)'
  prefs: []
  type: TYPE_IMG
- en: Principal Component Plot — 2D|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We can also create a 3D scatter plot by setting `projection=3`in the PCA() class.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/f7228111c3dc766f74a9566110390476.png)'
  prefs: []
  type: TYPE_IMG
- en: Principal Component Plot — 3D|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the PCA visualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scale: **bool, default `True`. This indicates whether the data should be
    scaled or not. We should scale data before running PCA. Learn more about [here](https://rukshanpramoditha.medium.com/principal-component-analysis-18-questions-answered-4abd72041ccd#f853).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**projection:** int, default is 2\. When `projection=2`, a 2D scatter plot
    is created. When `projection=3`, a 3D scatter plot is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**classes:** list, default `None`. This indicates the class labels for each
    class in y. The class names will be the labels for the legend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Validation Curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The validation curve plots the influence of a *single* hyperparameter on the
    train and validation set. By looking at the curve, we can determine the overfitting,
    underfitting and just-right conditions of the model for the specified values of
    the given hyperparameter. When there are multiple hyperparameters to tune at once,
    the validation curve cannot be used. Instated, you can use grid search or random
    search.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a validation curve with the traditional method is complex and time-consuming.
    Instead, we can use Yellowbrick’s ValidationCurve visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To plot a validation curve in Yellowbirck, we’ll build a random forest classifier
    using the same *breast_cancer* dataset (see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#6fde) at
    the end). We’ll plot the influence of the **max_depth** hyperparameter in the
    random forest model.
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s ValidationCurve
    visualizer to create a validation curve using the *breast_cancer* dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/150429e016c8884c12190c126762d4e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Validation Curve|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The model begins to overfit after the **max_depth** value of 6\. When `max_depth=6`,
    the model fits the training data very well and also generalizes well on new unseen
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the ValidationCurve visualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**estimator: **This can be any Scikit-learn ML model such as a decision tree,
    random forest, support vector machine, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**param_name: **This is the name of the hyperparameter that we want to monitor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**param_range: **This includes the possible values for *param_name*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cv:** int, defines the number of folds for the cross-validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**scoring: **string,contains the method of scoring of the model. For classification, *accuracy* is
    preferred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. Learning Curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The learning curve plots the training and validation errors or accuracies against
    the number of epochs or the number of training instances. You may think that both
    learning and validation curves appear the same, but the number of iterations is
    plotted in the learning curve’s x-axis while the values of the hyperparameter
    are plotted in the validation curve’s x-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The uses of the learning curve include:'
  prefs: []
  type: TYPE_NORMAL
- en: The learning curve is used to detect *underfitting*, *overfitting* and *just-right* conditions
    of the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The learning curve is used to identify *slow convergence*, *oscillating*, *oscillating
    with divergence* and *proper convergence*scenarios when finding the optimal learning
    rate of a neural network or ML model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The learning curve is used to see how much our model benefits from adding more
    training data. When used in this way, the x-axis shows the number of training
    instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the learning curve with the traditional method is complex and time-consuming.
    Instead, we can use Yellowbrick’s LearningCurve visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To plot a learning curve in Yellowbirck, we’ll build a support vector classifier
    using the same *breast_cancer* dataset (see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#6fde) at
    the end).
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s LearningCurve visualizer
    to create a validation curve using the *breast_cancer* dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/3d6f70a3ea545013b87705ed288eedf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Learning Curve|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The model will not benefit from adding more training instances. The model has
    already been trained with 569 training instances. The validation accuracy is not
    improving after 175 training instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the LearningCurve visualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**estimator: **This can be any Scikit-learn ML model such as a decision tree,
    random forest, support vector machine, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cv:** int, defines the number of folds for the cross-validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**scoring: **string,contains the method of scoring of the model. For classification, *accuracy* is
    preferred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. Elbow Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Elbow plot is used to select the optimal number of clusters in K-Means clustering.
    The model fits best at the point where the elbow occurs in the line chart. The
    elbow is the point of inflection on the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the Elbow plot with the traditional method is complex and time-consuming.
    Instead, we can use Yellowbrick’s KElbowVisualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To plot a learning curve in Yellowbirck, we’ll build a K-Means clustering model
    using the *iris* dataset (see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#2bc7) at
    the end).
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s KElbowVisualizer
    to create an Elbow plot using the *iris* dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/3cde2829e689c0b5be926da3a47f32b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Elbow Plot|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The *elbow* occurs at k=4 (annotated with a dashed line). The plot indicates
    that the optimal number of clusters for the model is 4\. In other words, the model
    is fitted well with 4 clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the KElbowVisualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**estimator: **K-Means model instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**k:** int or tuple. If an integer, it will compute scores for the clusters
    in the range of (2, k). If a tuple, it will compute scores for the clusters in
    the given range, for example, (3, 11).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5\. Silhouette Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The silhouette plot is used to select the optimal number of clusters in K-Means
    clustering and also to detect cluster imbalance. This plot provides very accurate
    results than the Elbow plot.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the silhouette plot with the traditional method is complex and time-consuming.
    Instead, we can use Yellowbrick’s SilhouetteVisualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To create a silhouette plot in Yellowbirck, we’ll build a K-Means clustering
    model using the *iris* dataset (see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#2bc7) at
    the end).
  prefs: []
  type: TYPE_NORMAL
- en: The following code blocks explain how we can utilize Yellowbrick’s SilhouetteVisualizer
    to create silhouette plots using the *iris* dataset with different k (number of
    clusters) values.
  prefs: []
  type: TYPE_NORMAL
- en: '**k=2**'
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/f703ccc9d7dcd76127416d55263c8354.png)'
  prefs: []
  type: TYPE_IMG
- en: Silhouette Plot with 2 Clusters (k=2)|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: By changing the number of clusters in the KMeans() class, we can execute the
    above code at different times to create silhouette plots when k=3, k=4 and k=5.
  prefs: []
  type: TYPE_NORMAL
- en: '**k=3**'
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/8903414955555e93c6cee0a303ae8a93.png)'
  prefs: []
  type: TYPE_IMG
- en: '|Silhouette Plot with 3 Clusters (k=3)|Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: '**k=4**'
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/dda9337e16726fee4d16d7da155015ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Silhouette Plot with 4 Clusters (k=4)|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '**k=5**'
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/31a7712a95ab447641da039dfce5e61d.png)'
  prefs: []
  type: TYPE_IMG
- en: Silhouette Plot with 4 Clusters (k=5)|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The silhouette plot contains one knife shape per cluster. Each knife shape is
    created by bars that represent all the data points in the cluster. So, the width
    of a knife shape represents the number of all instances in the cluster. The bar
    length represents the Silhouette Coefficient for each instance. The dashed line
    indicates the silhouette score — Source: [*Hands-On K-Means Clustering*](https://medium.com/mlearning-ai/k-means-clustering-with-scikit-learn-e2af706450e4) (written
    by me).
  prefs: []
  type: TYPE_NORMAL
- en: A plot with roughly equal widths of knife shapes tells us the clusters are well-balanced
    and have roughly the same number of instances within each cluster — one of the
    most important assumptions in K-Means clustering.
  prefs: []
  type: TYPE_NORMAL
- en: When the bars in a knife shape extend the dashed line, the clusters are well
    separated — another important assumption in K-Means clustering.
  prefs: []
  type: TYPE_NORMAL
- en: When k=3, the clusters are well-balanced and well-separated. So, the optimal
    number of clusters in our example is 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the SilhouetteVisualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**estimator: **K-Means model instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**colors:** string, a collection of colors used for each knife shape. ‘yellowbrick’
    or one of Matplotlib color map strings such as ‘Accent’, ‘Set1’, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6\. Class Imbalance Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class imbalance plot detects the imbalance of classes in the target column
    in classification datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Class imbalance happens when one class has significantly more instances than
    the other class. For example, a dataset related to spam email detection has 9900
    instances for the “Not spam” category and just 100 instances for the “Spam” category.
    The model will fail to capture the minority class (the *Spam* category). As a
    result of this, the model will not be accurate in predicting the minority class
    when a class imbalance occurs — Source: [*Top 20 Machine Learning and Deep Learning
    Mistakes That Secretly Happen Behind the Scenes*](https://rukshanpramoditha.medium.com/top-20-machine-learning-and-deep-learning-mistakes-that-secretly-happen-behind-the-scenes-e211e056c867) (written
    by me).
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the class imbalance plot with the traditional method is complex and
    time-consuming. Instead, we can use Yellowbrick’s ClassBalance visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To plot a class imbalance plot in Yellowbirck, we’ll use the *breast_cancer *dataset
    (classification dataset, see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#6fde) at
    the end).
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s ClassBalance visualizer
    to create a class imbalance plot using the *breast_cancer* dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/bef8df00aabfd074c350c6f16747c0a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Class Imbalance Plot|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: There are more than 200 instances in the *Malignant* class and more than 350
    instances in the *Benign *class. Therefore, we cannot see much class imbalance
    here although the instances are not equally distributed among the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the ClassBalance visualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**labels: **list, the names of the unique classes in the target column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7\. Residuals Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The residuals plot in linear regression is used to determine whether the residuals
    (observed values-predicted values) are uncorrelated (independent) by analyzing
    the variance of errors in a regression model.
  prefs: []
  type: TYPE_NORMAL
- en: The residuals plot is created by plotting the residuals against the predictions.
    If there is any kind of pattern between predictions and residuals, it confirms
    that the fitted regression model is not perfect. If the points are randomly dispersed
    around the x-axis, the regression model is fitted well with the data.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the residuals plot with the traditional method is complex and time-consuming.
    Instead, we can use Yellowbrick’s ResidualsPlot visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To plot a residuals plot in Yellowbirck, we’ll use the *Advertising *([Advertising.csv](https://drive.google.com/file/d/1-1MgAOHbTI5DreeXObN6KLcSka6LS9G-/view?usp=share_link),
    see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#8bd8) at
    the end) dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s ResidualsPlot visualizer
    to create a residuals plot using the *Advertising *dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/43a4c0ed19f3dfa9bb5268674da76344.png)'
  prefs: []
  type: TYPE_IMG
- en: Residuals Plot|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see some kind of non-linear pattern between predictions and residuals
    in the residuals plot. The fitted regression model is not perfect, but it is good
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the ResidualsPlot visualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**estimator: **This can be any Scikit-learn regressor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hist:** bool, default `True`. Whether to plot the histogram of residuals,
    which is used to check another assumption — The residuals are approximately normally
    distributed with the mean 0 and a fixed standard deviation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8\. Prediction Error Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prediction error plot in linear regression is a graphical method that is
    used to evaluate a regression model.
  prefs: []
  type: TYPE_NORMAL
- en: The prediction error plot is created by plotting the predictions against the
    actual target values.
  prefs: []
  type: TYPE_NORMAL
- en: If the model makes very accurate predictions, the points should be on the 45-degree
    line. Otherwise, the points are dispersed around that line.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the prediction error plot with the traditional method is complex and
    time-consuming. Instead, we can use Yellowbrick’s PredictionError visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To plot a prediction error plot in Yellowbirck, we’ll use the *Advertising *([Advertising.csv](https://drive.google.com/file/d/1-1MgAOHbTI5DreeXObN6KLcSka6LS9G-/view?usp=share_link),
    see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#8bd8) at
    the end) dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s PredictionError
    visualizer to create a residuals plot using the *Advertising *dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/975ad64ede24ec65172ffdc5e307d90c.png)'
  prefs: []
  type: TYPE_IMG
- en: Prediction Error Plot|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The points are not exactly on the 45-degree line, but the model is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the PredictionError visualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**estimator: **This can be any Scikit-learn regressor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**identity: **bool, default `True`. Whether to draw the 45-degree line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9\. Cook’s Distance Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Cook's distance measures the impact of instances on linear regression. Instances
    with large impacts are considered as outliers. A dataset with a large number of
    outliers is not suitable for linear regression without preprocessing. Simply,
    the Cook’s distance plot is used to detect outliers in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the Cook’s distance plot with the traditional method is complex and
    time-consuming. Instead, we can use Yellowbrick’s CooksDistance visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To plot a Cook’s distance plot in Yellowbirck, we’ll use the *Advertising *([Advertising.csv](https://drive.google.com/file/d/1-1MgAOHbTI5DreeXObN6KLcSka6LS9G-/view?usp=share_link),
    see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#8bd8) at
    the end) dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s CooksDistance visualizer
    to create a Cook’s distance plot using the *Advertising *dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/61959f47735e7883841325fbb5347350.png)'
  prefs: []
  type: TYPE_IMG
- en: Cook’s Distance Plot|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: There are some observations that extend the threshold (horizontal red) line.
    They are outliers. So, we should prepare the data before we make any regression
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the CooksDistance visualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**draw_threshold: **bool, default `True`. Whether to draw the threshold line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10\. Feature Importances Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The feature importances plot is used to select the minimum required important
    features to produce an ML model. Since not all features contribute the same to
    the model, we can remove less important features from the model. That will reduce
    the complexity of the model. Simple models are easy to train and interpret.
  prefs: []
  type: TYPE_NORMAL
- en: The feature importances plot visualizes the relative importances of each feature.
  prefs: []
  type: TYPE_NORMAL
- en: Yellowbrick implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the feature importances plot with the traditional method is complex
    and time-consuming. Instead, we can use Yellowbrick’s FeatureImportances visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To plot a feature importances plot in Yellowbirck, we’ll use the *breast_cancer *dataset
    (see [Citation](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582#6fde) at
    the end) which contains 30 features.
  prefs: []
  type: TYPE_NORMAL
- en: The following code explains how we can utilize Yellowbrick’s FeatureImportances
    visualizer to create a feature importances plot using the *breast_cancer* dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Code by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![10 Amazing Machine Learning Visualizations You Should Know in 2023](../Images/c9298cfb81fbeec3ff251f21569db3b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Feature Importances Plot|Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Not all 30 features in the dataset are much contributed to the model. We can
    remove the features with small bars from the dataset and refit the model with
    selected features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parameters of the FeatureImportances visualizer include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**estimator: **AnyScikit-learn estimator that supports either `feature_importances_` attribute
    or `coef_` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**relative: **bool, default `True`. Whether to plot relative importance as
    a percentage. If `False`, the raw numeric score of the feature importance is shown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**absolute: **bool, default `False`. Whether to consider only the magnitude
    of coefficients by avoiding negative signs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary of the uses of ML Visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Principal Component Plot:** *PCA()*, Usage — Visualizes high-dimensional
    data in a 2D or 3D scatter plot which can be used to identify important patterns
    in high-dimensional data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Validation Curve:** *ValidationCurve()*, Usage — Plots the influence of a *single* hyperparameter
    on the train and validation set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Learning Curve:** *LearningCurve()*, Usage — Detects *underfitting*, *overfitting* and *just-right* conditions
    of a model, Identifies *slow convergence*, *oscillating*, *oscillating with divergence* and *proper
    convergence*scenarios when finding the optimal learning rate of a neural network,
    Shows how much our model benefits from adding more training data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Elbow Plot:** *KElbowVisualizer()*, Usage — Selects the optimal number of
    clusters in K-Means clustering.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Silhouette Plot:** *SilhouetteVisualizer()*, Usage — Selects the optimal
    number of clusters in K-Means clustering, Detects cluster imbalance in K-Means
    clustering.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Class Imbalance Plot:** *ClassBalance()*, Usage — Detects the imbalance of
    classes in the target column in classification datasets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Residuals Plot:** *ResidualsPlot()*, Usage — Determines whether the residuals
    (observed values-predicted values) are uncorrelated (independent) by analyzing
    the variance of errors in a regression model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prediction Error Plot:** *PredictionError()*, Usage — A graphical method
    that is used to evaluate a regression model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cook’s Distance Plot:** *CooksDistance()*, Usage — Detects outliers in the
    dataset based on the Cook’s distances of instances.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Feature Importances Plot:** *FeatureImportances()*, Usage — Selects the minimum
    required important features based on the relative importances of each feature
    to produce an ML model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the end of today’s post.
  prefs: []
  type: TYPE_NORMAL
- en: Please let me know if you’ve any questions or feedback.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Breast cancer dataset info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Citation: **Dua, D. and Graff, C. (2019). UCI Machine Learning Repository
    [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School
    of Information and Computer Science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source: **[https://archive.ics.uci.edu/ml/datasets/breast+cancer+wisconsin+(diagnostic)](https://archive.ics.uci.edu/ml/datasets/breast+cancer+wisconsin+(diagnostic))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**License: ***Dr. William H. Wolberg* (General Surgery Dept.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: University of Wisconsin), *W. Nick Street* (Computer Sciences Dept.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: University of Wisconsin) and *Olvi L. Mangasarian* (Computer Sciences Dept.
    University of Wisconsin) holds the copyright of this dataset. Nick Street donated
    this dataset to the public under the *Creative Commons Attribution 4.0 International
    License *([**CC BY 4.0**](https://creativecommons.org/licenses/by/4.0/)). You
    can learn more about different dataset license types [here](https://rukshanpramoditha.medium.com/dataset-and-software-license-types-you-need-to-consider-d20965ca43dc#6ade).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Iris dataset info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Citation: **Dua, D. and Graff, C. (2019). UCI Machine Learning Repository
    [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School
    of Information and Computer Science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source: **[https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**License: ***R.A. Fisher* holds the copyright of this dataset. Michael Marshall
    donated this dataset to the public under the *Creative Commons Public Domain Dedication
    License *([**CC0**](https://creativecommons.org/share-your-work/public-domain/cc0)).
    You can learn more about different dataset license types [here](https://rukshanpramoditha.medium.com/dataset-and-software-license-types-you-need-to-consider-d20965ca43dc#6ade).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advertising dataset info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Source:** [https://www.kaggle.com/datasets/sazid28/advertising.csv](https://www.kaggle.com/datasets/sazid28/advertising.csv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**License: **This dataset is publicly available under the *Creative Commons
    Public Domain Dedication License *([**CC0**](https://creativecommons.org/share-your-work/public-domain/cc0)).
    You can learn more about different dataset license types [here](https://rukshanpramoditha.medium.com/dataset-and-software-license-types-you-need-to-consider-d20965ca43dc#6ade).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.scikit-yb.org/en/latest/](https://www.scikit-yb.org/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.scikit-yb.org/en/latest/quickstart.html](https://www.scikit-yb.org/en/latest/quickstart.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.scikit-yb.org/en/latest/api/index.html](https://www.scikit-yb.org/en/latest/api/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Rukshan Pramoditha](https://www.linkedin.com/in/rukshan-manorathna-700a3916b/)**
    ([@rukshanpramoditha](https://rukshanpramoditha.medium.com/)) has B.Sc. in Industrial
    Statistics. Supporting the data science education since 2020\. Top 50 Data Science/AI/ML
    Writer on Medium. He have wrtten articles on Data Science, Machine Learning, Deep
    Learning, Neural Networks, Python, and Data Analytics. He has proven track record
    of converting complex topics into something valuable and easy to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](https://towardsdatascience.com/10-amazing-machine-learning-visualizations-you-should-know-in-2023-528282940582).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Make Amazing Visualizations with Python Graph Gallery](https://www.kdnuggets.com/2022/12/make-amazing-visualizations-python-graph-gallery.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Amazing & Free LLMs Playgrounds You Need to Try in 2023](https://www.kdnuggets.com/5-amazing-free-llms-playgrounds-you-need-to-try-in-2023)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Machine Learning Skills Every Machine Learning Engineer Should…](https://www.kdnuggets.com/2023/03/5-machine-learning-skills-every-machine-learning-engineer-know-2023.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KDnuggets News, April 13: Python Libraries Data Scientists Should…](https://www.kdnuggets.com/2022/n15.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Top AutoML Frameworks You Should Consider in 2023](https://www.kdnuggets.com/2023/05/best-automl-frameworks-2023.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top 19 Skills You Need to Know in 2023 to Be a Data Scientist](https://www.kdnuggets.com/2023/04/top-19-skills-need-know-2023-data-scientist.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
