# 3个你应该知道的高级Python特性

> 原文：[https://www.kdnuggets.com/2020/07/3-advanced-python-features.html](https://www.kdnuggets.com/2020/07/3-advanced-python-features.html)

[评论](#comments)

![](../Images/3558bedbb897e8956c59a41112d451d0.png)

*照片由[David Clode](https://unsplash.com/@davidclode?utm_source=medium&utm_medium=referral)提供，发布在[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)。*

在这篇文章中，我将讨论Python的3个重要特性，这些特性对数据科学家非常实用，并且节省了大量时间。让我们开始吧，不浪费时间。

### 列表和字典推导式

列表和字典推导式是Python中非常强大的工具，能够方便地制作列表。它节省时间，语法简单，相比于使用普通Python for循环制作列表，逻辑更清晰。

基本上，这些用来代替显式的for循环，并在其中执行简单逻辑，将元素添加到列表或字典中。它们是一行代码，使代码更具可读性。

**列表推导式**

我们首先将看到一个普通的Python示例，然后看到它用*列表推导式*的等效写法。

**场景**

假设我们在Pandas中有一个简单的数据框，包含3门科目的学生成绩。

```py
In [1]: results = [[10,8,7],[5,4,3],[8,6,9]]

In [2]: results = pd.DataFrame(results, columns=['Maths','English','Science'])

```

如果我们打印它，

```py
In [5]: results

Out[5]:
   Maths  English  Science
0     10        8        7
1      5        4        3
2      8        6        9

```

现在假设我们想要制作一个包含每门科目最高分的列表，即，该列表应为[10,8,9]，因为这些是每门科目的最高分。

**Python 代码**

```py
In [7]: maxlist = []

In [8]: for i in results:
   ...:     maxlist.append(max(results[i]))

```

如果我们打印它，

```py
In [9]: maxlist

Out[9]: [10, 8, 9]

```

**使用列表推导式**

列表推导式的基本语法是

```py
[varname for varname in iterableName]

```

在这里我们可以对*varname*做任何修改。

在我们的例子中，我们的列表推导式将是

```py
In [27]:maxlist = [max(results[i]) for i in results]

```

我们的输出将是

```py
Out[27]: [10, 8, 9]

```

你看到它如何与我们的Python代码相似吗？我们在普通Python代码中将*max(results[i])*添加到*maxlist*中，这里我们没有添加它，而是将你想要添加的内容放在列表推导式的第一个参数中。所以现在我可以将基本语法重写为

```py
newlist = [whatYouwantToAppend for anything in anyIterable]

```

因此，在我们的例子中，我们想将数据框中每一行的最大值附加到列表中，即*max(results[i])*，所以我们使用了

```py
[max(results[i]) for i in results]

```

**字典推导式**

类似地，我们对字典推导式使用相同的思想。通常使用的基本语法是

```py
{key, value for key, value in anyIterable}

```

比如，假设我有一个英文字母的虚拟表格，

```py
df = 
{0: 'A',
 1: 'B',
 2: 'C',
 3: 'D',
 4: 'E',
 5: 'F',
 6: 'G',
 7: 'H',
 8: 'I',
 9: 'J',
 10: 'K',
 11: 'L',
 12: 'M',
 13: 'N',
 14: 'O',
 15: 'P',
 16: 'Q',
 17: 'R',
 18: 'S',
 19: 'T',
 20: 'U',
 21: 'V',
 22: 'W',
 23: 'X',
 24: 'Y',
 25: 'Z'}

```

现在，如果我们想用数字（0–25）作为字典的值，因为机器学习模型只能处理数字，并且我们要填充字典的值，我们需要交换字典的键和值。交换字典的键和值的最简单方法是使用*字典推导式*。

```py
{number: alphabet for alphabet , number in df.items()}

```

如果你稍微关注一下，它会开始变得明白它如何反转字典，我们在循环*alphabet*和*number*，这是字典的正常顺序，但我们想插入的是相反的顺序，所以我们使用*number:alphabet*而不是*alphabet:number*。

### Lambda 表达式

Lambda 表达式是数据科学家非常强大的工具。它们特别方便，尤其是当与 *DataFrame.apply()*、*map()*、*filter()* 或 *reduce()* 一起使用时。它们提供了一种简单的方法来避免手动定义函数，并将其写成一行代码，使代码更加清晰。

我们来看一下 Lambda 表达式的基本语法，其中我们返回任何传入函数的下一个数字。

```py
z = lambda functionArgument1 : functionArgument1 + 1

```

在这里，我们的函数参数是 *functionArgument1*，我们返回 *functionArgument1* +1，即下一个数字。

所以要使用它，

```py
z(5)
>>>6

```

看，这就是这么简单。我们来看一个实际的例子，我们有一个包含名字的数据框（取自泰坦尼克号数据集），我们想要创建一个特征，从名字中提取称谓（如 Mr, Miss, Sir 等）。

所以，我们的数据框代码是

```py
df = pd.DataFrame([
    'Braud, Mr. Owen Harris',
    'Cumings, Mrs. John Bradley',
    'Heikkeinen, Miss. Laina',
    'Futrelle, Mrs. Jacques Heath',
    'Allen, Mr. William Henry',
    'Moran, Mr. James'
])

```

而数据框是

![](../Images/a116a91303482d66adce66321b2f3da7.png)

现在，如果我们注意到，我们发现一个特定的模式，那就是我们在名字后面有一个逗号，在我们想要提取的称谓后面有一个“句号”。所以我们可以使用 *list slicing* 从逗号到句号进行提取。

我们想从逗号后面两个索引的位置开始切片，因为我们不想包含逗号和逗号后的空格，所以我们的起始索引将是 *str.find(',')+2*，而我们要切片到句号（不包括），所以我们将切片到 *str.find('.')*。幸运的是，最后一个索引没有包含，因此我们不需要显式地从索引中减去 -1。让我们用 Lambda 表达式来解决这个问题。

```py
df['Title'] = df[0].apply(lambda a: a[a.find(',')+2: a.find('.')])

```

在这里，我们使用的是 pandas 的 *.apply* 函数，作用于 df[0]，这是包含所有名字的列。在其中，我们传递了一个 Lambda 表达式，它接受每个名字并返回该名字的切片版本。这个切片版本就是那个名字的称谓。我们数据框的输出现在是

![](../Images/ce7ed4504840075602bc1fc09d34eb27.png)

在这里，我们可以看到我们是如何使用这个非常简单的技巧从名字中提取称谓的。

当与*map*、*reduce* 或 *filter* 一起使用时，Lambda 表达式非常有用。

### Map 函数

在 Python 中，Map 函数是非常常用的函数，它使我们的工作变得更轻松。*map* 的思想是，当传入一个函数和一个可迭代对象时，它会对该可迭代对象的每一个实体执行该函数。

这是什么意思？

假设我有一个可迭代对象，它是一个包含以下数据的列表 *[0, 5, 10, 15, 20, 25, 30]*，以及一个自定义函数 *isEven(anyInteger)*，它用于判断 *anyInteger* 是否为偶数。如果我们将这个函数和可迭代对象传递给 *map*，它将自动将这个函数应用于列表中的所有实体，并返回 *map* 对象，我们可以将其转换为列表、元组或字典。

**示例**

假设我们的函数是

```py
def isEven(anyInteger):
   return anyInteger % 2 == 0

```

而我们的可迭代对象是

```py
myList = [0, 5, 10, 15, 20, 25, 30]

```

如果我们想使用传统方法，则需要遍历我们的列表并将函数应用于每个项目。

```py
# Traditional approach
isEvenList = []
for i in myList:
    isEvenList.append(isEven(i))

```

这将返回一个新的列表*isEvenList*，其中偶数为 True，奇数为 False。

使用*map*可以让我们的任务变得更加轻松。我们的代码如下

```py
isEvenList = list(map(isEven, myList))

```

我们的代码完成了！

在这里，我们所做的是在*map*函数内部，传入我们的函数*isEven*和我们的可迭代对象*myList*，返回一个*map*对象，我们将其转换为*list*。

所以 map 函数的基本语法是

```py
list/dict/tuple(map(myFunction, myIterable))

```

幸运的是，Pandas 提供了*map*、*apply*和*applymap*作为内置函数。它们非常常用，也非常有用。这三种函数的基本思想与 Python 的内置 map 函数相同。你可以在 Pandas 的官方文档中了解更多关于这些函数的信息[这里](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.map.html)。

**相关：**

+   [面向每个人的 Python：免费电子书](https://www.kdnuggets.com/2020/05/python-everybody-free-ebook.html)

+   [今天你应该学习的 10 个 Python 技巧和窍门](https://www.kdnuggets.com/2020/01/10-python-tips-tricks-learn-today.html)

+   [停止伤害你的 Pandas！](https://www.kdnuggets.com/2020/04/stop-hurting-pandas.html)

* * *

## 我们的三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速开启网络安全职业生涯

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织进行 IT 维护

* * *

### 更多相关话题

+   [KDnuggets 新闻，4月13日：数据科学家应该了解的 Python 库…](https://www.kdnuggets.com/2022/n15.html)

+   [你必须了解的 10 个高级数据科学 SQL 面试问题…](https://www.kdnuggets.com/2023/01/top-10-advanced-data-science-sql-interview-questions-must-know-answer.html)

+   [你应该了解的 Python 装饰器和元类](https://www.kdnuggets.com/2023/03/know-python-decorators-metaclasses.html)

+   [每个数据科学家都应该了解的三个 R 库（即使你使用 Python）](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)

+   [更多分类问题的性能评估指标](https://www.kdnuggets.com/2020/04/performance-evaluation-metrics-classification.html)

+   [你应该了解的关于梯度下降和成本函数的 5 个概念](https://www.kdnuggets.com/2020/05/5-concepts-gradient-descent-cost-function.html)
