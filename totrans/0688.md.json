["```py\n---------------------------------------------------------------------------\n```", "```py\ndef draw_lines(img, lines, color=[255, 0, 0], thickness=2):\n    \"\"\"\n    This function draws `lines` with `color` and `thickness`.    \n    \"\"\"\n    imshape = img.shape\n\n    # these variables represent the y-axis coordinates to which \n    # the line will be extrapolated to\n    ymin_global = img.shape[0]\n    ymax_global = img.shape[0]\n\n    # left lane line variables\n    all_left_grad = []\n    all_left_y = []\n    all_left_x = []\n\n    # right lane line variables\n    all_right_grad = []\n    all_right_y = []\n    all_right_x = []\n\n    for line in lines:\n        for x1,y1,x2,y2 in line:\n            gradient, intercept = np.polyfit((x1,x2), (y1,y2), 1)\n            ymin_global = min(min(y1, y2), ymin_global)\n\n            if (gradient > 0):\n                all_left_grad += [gradient]\n                all_left_y += [y1, y2]\n                all_left_x += [x1, x2]\n            else:\n                all_right_grad += [gradient]\n                all_right_y += [y1, y2]\n                all_right_x += [x1, x2]\n\n    left_mean_grad = np.mean(all_left_grad)\n    left_y_mean = np.mean(all_left_y)\n    left_x_mean = np.mean(all_left_x)\n    left_intercept = left_y_mean - (left_mean_grad * left_x_mean)\n\n    right_mean_grad = np.mean(all_right_grad)\n    right_y_mean = np.mean(all_right_y)\n    right_x_mean = np.mean(all_right_x)\n    right_intercept = right_y_mean - (right_mean_grad * right_x_mean)\n\n    # Make sure we have some points in each lane line category\n    if ((len(all_left_grad) > 0) and (len(all_right_grad) > 0)):\n        upper_left_x = int((ymin_global - left_intercept) / left_mean_grad)\n        lower_left_x = int((ymax_global - left_intercept) / left_mean_grad)\n        upper_right_x = int((ymin_global - right_intercept) / right_mean_grad)\n        lower_right_x = int((ymax_global - right_intercept) / right_mean_grad)\n\n        cv2.line(img, (upper_left_x, ymin_global), \n                      (lower_left_x, ymax_global), color, thickness)\n        cv2.line(img, (upper_right_x, ymin_global), \n                      (lower_right_x, ymax_global), color, thickness)\n\n```", "```py\n---------------------------------------------------------------------------\n```", "```py\n---------------------------------------------------------------------------\n```", "```py\ndef weighted_img(img, initial_img, α=0.8, β=1., λ=0.):\n    \"\"\"\n    `img` is the output of the hough_lines(), An image with lines drawn on it.\n    Should be a blank image (all black) with lines drawn on it.\n\n    `initial_img` should be the image before any processing.\n\n    The result image is computed as follows:\n\n    initial_img * α + img * β + λ\n    NOTE: initial_img and img must be the same shape!\n    \"\"\"\n    return cv2.addWeighted(initial_img, α, img, β, λ)\n\n# outline the input image\ncolored_image = weighted_img(houged, image)\n\n```", "```py\n---------------------------------------------------------------------------\n```", "```py\n---------------------------------------------------------------------------\n```", "```py\nfrom moviepy.editor import VideoFileClip\nfrom IPython.display import HTML\n\ndef process_image(image):\n    # grayscale the image\n    grayscaled = grayscale(image)\n\n    # apply gaussian blur\n    kernelSize = 5\n    gaussianBlur = gaussian_blur(grayscaled, kernelSize)\n\n    # canny\n    minThreshold = 100\n    maxThreshold = 200\n    edgeDetectedImage = canny(gaussianBlur, minThreshold, maxThreshold)\n\n    # apply mask\n    lowerLeftPoint = [130, 540]\n    upperLeftPoint = [410, 350]\n    upperRightPoint = [570, 350]\n    lowerRightPoint = [915, 540]\n\n    pts = np.array([[lowerLeftPoint, upperLeftPoint, upperRightPoint, \n                    lowerRightPoint]], dtype=np.int32)\n    masked_image = region_of_interest(edgeDetectedImage, pts)\n\n    # hough lines\n    rho = 1\n    theta = np.pi/180\n    threshold = 30\n    min_line_len = 20 \n    max_line_gap = 20\n\n    houged = hough_lines(masked_image, rho, theta, threshold, min_line_len, \n                         max_line_gap)\n\n    # outline the input image\n    colored_image = weighted_img(houged, image)\n    return colored_image\n\noutput = 'car_lane_detection.mp4'\nclip1 = VideoFileClip(\"insert_car_lane_video.mp4\")\nwhite_clip = clip1.fl_image(process_image)\n%time white_clip.write_videofile(output, audio=False)\n\n```", "```py\n---------------------------------------------------------------------------\n```"]