# 面向数据科学家的面向对象编程：构建你的 ML 估算器

> 原文：[https://www.kdnuggets.com/2019/08/object-oriented-programming-data-scientists-estimator.html](https://www.kdnuggets.com/2019/08/object-oriented-programming-data-scientists-estimator.html)

![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [评论](#comments)

**更新**: 你将始终找到最新的 Python 脚本（包括线性回归类定义和方法）[**在这里**](https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/OOP_in_ML/Class_MyLinearRegression.py)。用它来进行进一步的构建或实验。

### 问题是什么？

* * *

## 我们的前三个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业道路

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织 IT

* * *

数据科学家通常来自与传统计算机科学/软件工程相去甚远的背景——物理学、生物学、统计学、经济学、电气工程等。

![图示](../Images/14047e07e857d9d8af0a64fd62947456.png)

**来源**: [“数据科学家来自哪里？”](https://medium.com/indeed-engineering/where-do-data-scientists-come-from-fc526023ace)

但最终，他们被期望掌握足够的编程/软件工程知识，以对其组织和业务产生真正的影响。

**[成为数据科学家并不等于成为软件工程师！](https://towardsdatascience.com/being-a-data-scientist-does-not-make-you-a-software-engineer-c64081526372?source=post_page-----7da416751f64----------------------)**

如何构建可扩展的机器学习系统 — 第 1/2 部分

那么，大多数现代编程语言和软件工程范式的核心是什么？

[面向对象编程 (OOP)。](https://www.webopedia.com/TERM/O/object_oriented_programming_OOP.html)

但对于未曾接触过的人来说，[面向对象编程的原则](https://realpython.com/python3-object-oriented-programming/)最初可能会显得有些陌生或甚至令人生畏。因此，那些背景中没有计算机编程正式培训的数据科学家，可能会发现 OOP 的概念在日常工作中有些难以接受。

流行的数据科学/AI/ML MOOCs 和培训营也无济于事。

他们尝试给即将成为数据科学家的人员提供一种混合的统计、数值分析、科学编程、机器学习 (ML) 算法、可视化，甚至可能还有一些用于部署这些 ML 模型的网络框架的风味。

几乎所有这些都可以学习和实践，即使不严格遵循面向对象编程的原则。实际上，年轻的数据科学家们，如果被淹没在面向对象编程的细节中，可能会感到窒息，他们渴望学习最新的神经网络架构或最酷的数据可视化技术。因此，MOOCs通常不会在他们的数据科学课程中混合或强调这些内容。

![](../Images/7fd218516dbca417bf02d9ed323659c7.png)

### 一个简单的例子（以及更多…）

让我用Python举一个例子，因为它是[数据科学和机器学习任务中增长最快的语言](https://stackoverflow.blog/2017/09/14/python-growing-quickly/)。

### 算术例子

如果你被要求编写一个程序来实现涉及几个数字`a`和`b`的加法、减法、乘法和除法，你最可能会怎么做？

你很可能会打开一个Jupyter笔记本，在一个单元格中输入以下内容，按*shift-enter*键并获取结果。

```py
a+b
a-b
a*b
a/b
```

如果你喜欢通过函数整理事务，那么你可以这样做，

```py
def add(a,b):
    return a+b
...
```

但是你会不会去定义一个完整的（包含初始化方法）Calc ***类***，并将这些函数放入该类作为***方法***？这些都是性质相似的操作，并且作用于相似的数据。为什么不[封装](https://stackify.com/oop-concept-for-beginners-what-is-encapsulation/)它们在一个单一的高级对象中呢？为什么不使用以下代码？

```py
class Calc:
    def __init__(self,a,b):
        self.a = a
        self.b = b
    def add(self):
        return self.a+self.b
    def sub(self):
        return self.a-self.b
    def mult(self):
        return self.a*self.b
    def div(self):
        return self.a/self.b
```

不，你不会这样做。对于这个特定问题，可能也没有意义去这么做。但是这个想法是有效的——*如果你有数据和函数（在面向对象编程的术语中称为方法），这些可以逻辑地结合，那么它们应该被封装在一个类中*。

但这看起来只是为了快速得到一些简单的数字计算结果而做的太多工作。那么，意义何在？数据科学家通常被重视的是他们能否得到正确的数据问题答案，而不是他们在代码中使用了什么复杂的对象。

### 数据科学家的例子

如果数据科学家不是这样编码的，那么难道他们真的不需要使用这些复杂的编程结构吗？

**错误。**

数据科学家们在不自觉的情况下大量利用面向对象编程的好处。**一直如此**。

记得`plt.plot`在`import matplotlib.pyplot as plt`之后吗？

那些**.**符号。你有一丝面向对象编程的痕迹。就在这里。

或者，你是否记得在Jupyter笔记本中学习到的那个酷技巧——在输入点（DOT）之后按Tab键，从而显示所有可以与*object*关联的函数？像这样，

![](../Images/97c267ebc460ca2af1652a07ac458847.png)

### 这个例子展示了什么？

这个例子展示了对逻辑一致性的遵守。

如果没有面向对象编程（OOP）范式，我们不得不将这些函数命名为`linear_model_linear_regression_fit`、`linear_model_linear_regression_predict`，等等。它们将不会被归入一个共同的逻辑单元。

为什么？因为它们是不同的函数，作用于不同的数据集。虽然`fit`函数需要训练特征和目标，但`predict`只需要一个测试数据集。`fit`函数不期望返回任何东西，而`predict`则期望返回一组预测结果。

**那么，它们为什么会出现在同一个下拉菜单中**？尽管它们不同，但它们有一个共同点，那就是*它们都可以被想象成整体线性回归过程中的重要部分*——我们期望线性回归能拟合一些训练数据，然后能够对未来未见的数据进行预测。我们还期望线性回归模型能提供一些关于拟合效果的指示——通常以一个称为回归系数或R²的数值或评分的形式。正如预期的那样，我们看到一个`score`函数，它正好返回那个R²数字，也与`fit`和`predict`一起存在。

整洁又干净，不是吗？

> 数据、函数和参数共同存在于一个逻辑单元中。

![](../Images/50eb96c8a9e886ec5e8981b520522367.png)

### 这如何成为可能的？

这成为可能是因为**我们超越了个体差异，将线性回归视为一个高级过程**，并决定它应该服务于哪些关键操作，以及它应该向用户提供哪些关键参数信息。

我们创建了一个名为`LinearRegression`的高级类，在这个类下，所有那些看似不同的函数都可以被归集在一起，方便管理和增强可用性。

一旦我们从库中导入了这个类，我们只需创建一个该类的实例——我们称之为`lm`。就是这样。所有归属于这个类的函数，通过新定义的实例`lm`变得对我们可访问。

如果我们对某些内部函数的实现不满意，我们可以修改它们并在修改后重新附加到主类中。只有内部函数的代码发生了变化，其他没有。

看，听起来多么合乎逻辑且具有扩展性？

![](../Images/b574d609433e3dac521a60cf30c50316.png)

### 创建你自己的ML估计器

传统的面向对象编程介绍会有很多使用类的例子，比如动物、运动、几何图形。

但对于数据科学家来说，**为什么不使用他们在代码中每天都用到的对象——机器学习估计器来阐明这些概念**。就像上图中的Scikit-learn库中的`lm`对象一样。

### 一个古老的线性回归估计器——但有些新意

[**在这个Github仓库**](https://github.com/tirthajyoti/Machine-Learning-with-Python/tree/master/OOP_in_ML)中，我逐步展示了如何按照OOP范式构建一个简单的线性回归（单变量或多变量）估计器类。

是的，这是老牌的线性回归类。它具有Scikit-learn中`LinearRegression`类的常见`fit`和`predict`方法，但功能更多。这是一个偷看……

![](../Images/8c58fd137523c1bcd9c3dd1cd79a8707.png)

是的，这个估计器比Scikit-learn的估计器更丰富，因为它除了标准的`fit`、`predict`和R² `score`函数外，还有**大量对于线性回归建模任务至关重要的其他实用功能**。

特别是对于数据科学家和统计建模人员——他们不仅想要进行预测，还想要

+   测量[拟合优度](https://blog.minitab.com/blog/adventures-in-statistics-2/regression-analysis-how-do-i-interpret-r-squared-and-assess-the-goodness-of-fit)，

+   验证[线性回归的假设](https://statisticsbyjim.com/regression/ols-linear-regression-assumptions/)，

+   检查[数据中的多重共线性](https://blog.minitab.com/blog/understanding-statistics/handling-multicollinearity-in-regression-analysis)，或者

+   识别[异常值](https://stattrek.com/regression/influential-points.aspx)。

**[如何检查你在Python中回归模型的质量？](https://towardsdatascience.com/how-do-you-check-the-quality-of-your-regression-model-in-python-fa61759ff685?source=post_page-----7da416751f64----------------------)**

线性回归深深根植于统计学习中，因此必须检查模型的“优度”。

### 你怎么开始构建这个类？

我们从一个简单的代码片段开始定义类。我们将其命名为`MyLinearRegression`。

在这里，`self`表示对象本身，`__init__`是一个[在创建类的实例时调用的特殊函数](https://micropyramid.com/blog/understand-self-and-__init__-method-in-python-class/)。正如其名称所示，`__init__`可用于用必要的参数（如果有的话）初始化类。

![](../Images/70c02f5518e56cd53bb6ddc03a6d9c9a.png)

我们可以添加一个简单的描述字符串来保持诚实 :-)

![](../Images/6be0608e25d1f6584625e0e2da6593ef.png)

接下来，我们添加核心的`fit`方法。请注意[**文档字符串**](https://www.geeksforgeeks.org/python-docstrings/)描述了该方法的目的、功能以及期望的数据类型。[这些都是良好面向对象编程原则的一部分](https://towardsdatascience.com/how-a-simple-mix-of-object-oriented-programming-can-sharpen-your-deep-learning-prototype-19893bd969bd)。

![](../Images/b0999e6f072e96e626a33d5bb4fee98f.png)

我们可以生成一些随机数据来测试到目前为止的代码。我们创建了一个包含两个变量的线性函数。以下是数据的散点图。

![](../Images/7f6ba261575fc70a25b26bb4a2b5df46.png)

现在，我们可以创建一个名为`mlr`的`MyLinearRegression`类的实例。如果我们尝试打印回归参数，会发生什么呢？

![](../Images/050574a0011945253ffa1324d61e849f.png)

因为`self.coef_`被设置为`None`，所以在尝试打印`mlr.coef_`时得到的也是相同的。注意，一旦创建了类的实例`mlr`，`self`变得等同于该实例。

但是`fit`的定义包括在拟合完成后设置属性。因此，我们只需调用`mlr.fit()`并打印出拟合的回归参数即可。

![](../Images/49eef3affe2909fca466bf5317cf6d43.png)

### 经典的`Predict`方法

拟合后，进行预测。我们可以轻松地将该方法添加到我们的回归类中。

![](../Images/adc25f937a8be3e2e63a7dbe181fc39e.png)

### 如果我们想添加一个（或几个）绘图工具函数怎么办？

到目前为止，我们开始扩展我们的回归类并**添加标准scikit-learn类中甚至没有的功能！**例如，我们总是希望看到拟合值与实际值的对比。创建一个函数来实现这一点很简单。我们将其称为`plot_fitted`。

请注意，[方法就像普通函数](https://stackoverflow.com/questions/155609/whats-the-difference-between-a-method-and-a-function/29379748)。它可以接受额外的参数。在这里，我们有一个`reference_line`参数（默认设置为`False`），它在拟合值与真实值的图上绘制一条45度参考线。同时，请注意文档字符串的描述。

![](../Images/aa3ddeee84b3de9e4bd2fcd2c3992387.png)

我们可以通过简单地执行以下操作来测试`plot_fitted`方法，

```py
m = MyLinearRegression()
m.fit(X,y)
m.plot_fitted()
```

或者，我们可以选择绘制参考线，

```py
m.plot_fitted(reference_line=True)
```

我们得到了以下图表！

![](../Images/dc458160e528deab2021214f05391f73.png)

一旦我们理解了可以在相同数据（训练集）上添加任何有用的方法，并且与相同目的（线性回归）相关，我们的想象力就没有界限了！我们来考虑将以下图表添加到我们的类中怎么样？

+   **配对图**（绘制所有特征和输出之间的配对关系，很像R中的`pairs`函数）

+   **拟合值与残差**图（这属于线性回归的诊断图，即检查基本假设的有效性）

+   **直方图**和**分位数-分位数（Q-Q）**图（这检查误差分布的正态性假设）

### 继承——不要使你的主类过于复杂

当我们热情地计划将实用方法添加到类中时，我们认识到这种方法可能会使主类的代码非常长且难以调试。为了解决这个难题，我们可以利用面向对象编程的另一个美妙原则——[**继承**](https://www.geeksforgeeks.org/inheritance-in-python/)。

**[Python中的继承 - GeeksforGeeks](https://www.geeksforgeeks.org/inheritance-in-python/?source=post_page-----7da416751f64----------------------)**

继承是一个类从另一个类派生或继承属性的能力。其好处是…

我们进一步认识到**所有图表并不相同**。成对图和拟合与真实数据图是类似的，因为它们仅能从数据中得出。其他图表与拟合优度和残差相关。

因此，我们可以创建两个独立的类来包含这些绘图函数——`Data_plots`和`Diagnostic_plots`。

猜猜看！我们可以将主`MyLinearRegression`类***定义为这些工具类的形式***。这就是继承的一个实例。

**注意**：这可能与标准的父类-子类继承实践略有不同，但在这里使用了相同的语言特性，以保持主类的简洁和紧凑，同时从其他类似构造的类中继承有用的方法。

![](../Images/dbf1bccc0045c88bdf44e7a8f63f493b.png)

注意，以下代码片段仅用于说明。请使用上面的Github链接查看实际代码。

![图](../Images/7e6d3e16ced328bdd829de63c91082f2.png)

`Data_plots` 类！[图](../Images/e7df0082a7f0bcc4978c3d4321977433.png)

`Diagnostics_plots` 类

并且`MyLinearregression`的定义仅略微改变，

```py
class MyLinearRegression(Diagnostics_plots,Data_plots):

    def __init__(self, fit_intercept=True):
        self.coef_ = None
        self.intercept_ = None
        self._fit_intercept = fit_intercept
...
```

通过将`Data_plots`和`Diagnostics_plots`的引用传递到`MyLinearRgression`类的定义中，我们继承了这些类的所有方法和属性。

现在，为了检查误差项的正态性假设，我们可以简单地拟合模型并运行这些方法。

```py
m = MyLinearRegression() # A brand new model instance
m.fit(X,y) # Fit the model with some datam.histogram_resid() # Plot histogram of the residuals
m.qqplot_resid() # Q-Q plot of the residuals
```

我们得到，

![](../Images/4c438910375e2697d073be9b2086c20b.png)

再次强调，代码的分离在这里发挥作用。你可以修改和改进核心绘图工具而不触及主类。这是一种高度灵活且不容易出错的方法！

### 利用面向对象编程的力量做更多事情

我们不会进一步阐述我们可以添加到`MyLinearRegression`的各种工具类和方法。你可以[**查看Github仓库**](https://github.com/tirthajyoti/Machine-Learning-with-Python/tree/master/OOP_in_ML)。

### 添加的附加类

仅为完整性，我们添加了，

+   一个类`Metrics`用于计算各种回归指标——SSE、SST、MSE、*R*²和调整后的*R*²。

+   一个类`Outliers`用于绘制Cook’s距离、杠杆值和影响图

+   一个类`Multicollinearity`用于计算方差膨胀因子（VIF）

总的来说，宏大的计划看起来如下，

![](../Images/c7cd17cb8c128a37c79da2a641840506.png)

这个类是否比Scikit-learn的LinearRegression类更丰富？你来决定。

### 通过创建分组工具来增加语法糖

一旦你继承了其他类，它们的行为就像你熟悉的普通Python模块一样。所以，你可以向主类中添加实用方法，以一起执行来自子类的多个方法。

例如，以下方法一次运行所有常规的诊断检查。注意我们是如何通过简单的**.DOT**访问绘图方法，即`Diagnostics_plot.histogram_resid`。就像访问Pandas或NumPy库中的函数一样！

![图](../Images/5d7eb84d02341a5bb80965d32df8a8bb.png)

主类中的`run_diagnostics`方法

有了这个，我们可以在拟合数据后用一行代码运行所有诊断。

```py
m = MyLinearRegression() # A brand new model instance
m.fit(X,y) # Fit the model with some datam.run_diagnostics()
```

![](../Images/84ee9de902da24ad8cfd0c739fc0275e.png)

类似地，你可以将所有离群值图表添加到一个单独的工具方法中。

### 模块化——将类作为模块导入

虽然不是经典的OOP原则，但遵循OOP范式的基本优点是[**能够模块化你的代码**](https://atomicobject.com/resources/oo-programming/encapsulation-modularity)。

你可以在标准的Jupyter笔记本中实验和开发所有这些代码。但为了实现最大的模块化，考虑将笔记本转换为独立的Python脚本（.py扩展名）。作为良好的实践，删除此文件中所有不必要的注释和测试代码，仅保留类。

[**这是我为这篇文章整理的脚本链接**](https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/OOP_in_ML/Class_MyLinearRegression.py)。

一旦你这样做了，你可以从一个完全不同的笔记本中导入`MyLinearRgression`类。这通常是**测试代码的首选方法**，因为这不会触及核心模型，而只是用各种数据样本和功能参数测试它。

![](../Images/8abefd0c466c96cfb71776b25f19d539.png)

此时，你可以考虑将此Python脚本放在Github上，创建一个Setup.py文件，创建适当的目录结构，并[将其发布为独立的线性回归包](https://towardsdatascience.com/build-your-first-open-source-python-project-53471c9942a7)，该包进行拟合、预测、绘图、诊断等。

当然，你还需要添加大量的[文档字符串描述](https://www.geeksforgeeks.org/python-docstrings/)、函数使用示例、[断言检查](https://airbrake.io/blog/python-exception-handling/python-assertionerror)和[单元测试](http://softwaretestingfundamentals.com/unit-testing/)，以使其成为一个好的包。

> 但作为数据科学家，现在你已将一项重要技能添加到你的技能库中——遵循OOP原则的软件开发。

这并不难，对吧？

### 结语

### 动机和相关文章

撰写本文时，我受到[这篇精彩文章](https://dziganto.github.io/classes/data%20science/linear%20regression/machine%20learning/object-oriented%20programming/python/Understanding-Object-Oriented-Programming-Through-Machine-Learning/)的启发，该文章详细探讨了Python中的OOP概念，并结合了机器学习的背景。

**[通过机器学习理解面向对象编程](https://dziganto.github.io/classes/data%20science/linear%20regression/machine%20learning/object-oriented%20programming/python/Understanding-Object-Oriented-Programming-Through-Machine-Learning/?source=post_page-----7da416751f64----------------------)**

面向对象编程（OOP）并不容易理解。你可以读一遍又一遍的教程，但仍需筛选…

我写了一篇类似的文章，探讨了更多基本方法，内容涉及深度学习。可以在这里查看，

**[如何通过简单的面向对象编程混合来锐化你的深度学习原型](https://towardsdatascience.com/how-a-simple-mix-of-object-oriented-programming-can-sharpen-your-deep-learning-prototype-19893bd969bd?source=post_page-----7da416751f64----------------------)**

通过混合面向对象编程的简单概念，如函数化和类继承，你可以添加…

### 课程？

我尝试寻找相关课程，但发现使用Python的课程很少。大多数软件工程课程都是用Java授课的。这里有两个可能对你有帮助，

+   [Python中的数据科学软件工程](https://www.datacamp.com/courses/software-engineering-for-data-scientists-in-python)

+   [Python类和继承](https://www.coursera.org/learn/python-classes-inheritance/)

如果你有任何问题或想法，请通过[**tirthajyoti[AT]gmail.com**](mailto:tirthajyoti@gmail.com)联系作者。此外，你还可以查看作者的GitHub库，了解其他有趣的Python、R或MATLAB代码片段和机器学习资源。如果你和我一样，对机器学习/数据科学充满热情，请随时[在LinkedIn上添加我](https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/)或[在Twitter上关注我](https://twitter.com/tirthajyotiS)。

[原文](https://towardsdatascience.com/object-oriented-programming-for-data-scientists-build-your-ml-estimator-7da416751f64)。经许可转载。

**相关：**

+   [如何通过简单的面向对象编程混合来锐化你的深度学习原型](/2019/08/simple-mix-object-oriented-programming-sharpen-deep-learning-prototype.html)

+   [数学编程 — 提升数据科学的关键习惯](/2019/05/mathematical-programming-key-habit-advancing-data-science.html)

+   [用Python优化：如何在最小风险下赚取最多的钱？](/2019/06/optimization-python-money-risk.html)

### 更多相关主题

+   [成为优秀数据科学家所需的5项关键技能](https://www.kdnuggets.com/2021/12/5-key-skills-needed-become-great-data-scientist.html)

+   [每位初学者数据科学家应掌握的6种预测模型](https://www.kdnuggets.com/2021/12/6-predictive-models-every-beginner-data-scientist-master.html)

+   [2021年最佳ETL工具](https://www.kdnuggets.com/2021/12/mozart-best-etl-tools-2021.html)

+   [是什么让Python成为初创公司的理想编程语言](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)

+   [停止学习数据科学以寻找目的，并寻找目的以…](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)

+   [建立一个强大的数据团队](https://www.kdnuggets.com/2021/12/build-solid-data-team.html)
