# 朴素贝叶斯：机器学习分类性能的基准模型

> 原文：[https://www.kdnuggets.com/2019/04/naive-bayes-baseline-model-machine-learning-classification-performance.html](https://www.kdnuggets.com/2019/04/naive-bayes-baseline-model-machine-learning-classification-performance.html)

![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [评论](/2019/04/naive-bayes-baseline-model-machine-learning-classification-performance.html?page=2#comments)![scikitlearn-pandas-naive-bayes](../Images/d3fbe85bbd5285ee92f5591fc9b15d6f.png)

### 贝叶斯定理

![方程](../Images/3792011e5ee54c481017b1511c531e4d.png)

* * *

## 我们的前三个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织的 IT

* * *

上述方程表示贝叶斯定理，其中描述了基于我们对可能与事件 A 相关的事件 B 的先验知识，事件 A 发生的概率 P(A)。

让我们探索贝叶斯定理的各个部分：

+   P(A|B) - **后验概率**

    +   在事件 B 发生的条件下，事件 A 发生的条件概率。

+   P(A) - **先验概率**

    +   事件 A 的概率。

+   P(B) - **证据**

    +   事件 B 的概率。

+   P(B|A) - **似然**

    +   给定事件 A 已发生的情况下，事件 B 发生的条件概率。

*现在，让我们从进行机器学习的角度来探索贝叶斯定理的各个部分：*

+   P(A|B) - **后验概率**

    +   给定训练数据输入的响应变量（目标变量）的条件概率。

+   P(A) - **先验概率**

    +   响应变量（目标变量）的概率。

+   P(B) - **证据**

    +   训练数据的概率。

+   P(B|A) - **似然**

    +   给定响应变量的训练数据的条件概率。

![方程](../Images/b132eb838838ec88563bb42acd6e8ded.png)

+   P(c|x) - 给定预测因子（x）的目标/类别（c）的后验概率。

+   P(c) - 类别（目标）的先验概率。

+   P(x|c) - 给定类别/目标（c）的预测因子（x）的概率。

+   P(x) - 预测因子（x）的先验概率。

**贝叶斯定理的示例：**

我将使用 [网球天气数据集](https://www.kaggle.com/pranavpandey2511/naive-bayes-classifier-from-scratch/data)。

```py
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline

```

```py
tennis = pd.read_csv('tennis.csv')
tennis

```

|  | 天气 | 温度 | 湿度 | 风 | 玩 |
| --- | --- | --- | --- | --- | --- |
| 0 | 晴朗 | 热 | 高 | 假 | 否 |
| 1 | 晴朗 | 热 | 高 | 真 | 否 |
| 2 | 多云 | 热 | 高 | 假 | 是 |
| 3 | 雨天 | 温和 | 高 | 假 | 是 |
| 4 | 多云 | 凉爽 | 普通 | 假 | 是 |
| 5 | 多云 | 凉爽 | 普通 | 真 | 否 |
| 6 | 阴天 | 凉爽 | 普通 | 真 | 是 |
| 7 | 晴天 | 温和 | 高 | 假 | 否 |
| 8 | 晴天 | 凉爽 | 普通 | 假 | 是 |
| 9 | 多云 | 温和 | 普通 | 假 | 是 |
| 10 | 晴天 | 温和 | 普通 | 真 | 是 |
| 11 | 阴天 | 温和 | 高 | 真 | 是 |
| 12 | 阴天 | 热 | 普通 | 假 | 是 |
| 13 | 多云 | 温和 | 高 | 真 | 否 |

让我们看看每个类别在频率表中的表现：

```py
outlook = tennis.groupby(['outlook', 'play']).size()
temp = tennis.groupby(['temp', 'play']).size()
humidity = tennis.groupby(['humidity', 'play']).size()
windy = tennis.groupby(['windy', 'play']).size()
play = tennis.play.value_counts()

```

```py
print(temp)
print('------------------')
print(humidity)
print('------------------')
print(windy)
print('------------------')
print(outlook)
print('------------------')
print('play')
print(play)

```

```py
 temp  play
cool  no      1
      yes     3
hot   no      2
      yes     2
mild  no      2
      yes     4
dtype: int64
------------------
humidity  play
high      no      4
          yes     3
normal    no      1
          yes     6
dtype: int64
------------------
windy  play
False  no      2
       yes     6
True   no      3
       yes     3
dtype: int64
------------------
outlook   play
overcast  yes     4
rainy     no      2
          yes     3
sunny     no      3
          yes     2
dtype: int64
------------------
play
yes    9
no     5
Name: play, dtype: int64 
```

**在下雨的情况下打网球的概率是多少？**

+   P(下雨|玩耍=是)

    +   (展望=多云)时 (玩耍=是) 的频率 / (玩耍=是) 的频率 = 3/9

+   P(玩耍=是)

    +   (玩耍=是)的频率 / (玩耍)总数 = 9/14

+   P(展望=多云)

    +   (展望=多云)的频率 / (展望)总数 = 5/14

![方程](../Images/d7a41a03bdc3d8062103dca6c9067ef3.png)

```py
(3/9)*(9/14)/(5/14)

```

```py
 0.6 
```

当下雨时打网球的概率是**60%。** 一旦获得每个类别的频率，这个过程非常简单。

这是一个简单的函数来帮助新手记住贝叶斯方程的各个部分：

```py
  def bayestheorem():
    print('Posterior [P(c|x)] - Posterior probability of the target/class (c) given predictors (x)'),
    print('Prior [P(c)] - Prior probability of the class (target)'),
    print('Likelihood [P(x|c)] - Probability of the predictor (x) given the class/target (c)'),
    print('Evidence [P(x)] - Prior probability of the predictor (x))')

```

这是一个简单的函数来计算后验概率，但你必须能够自己找到贝叶斯方程的每个部分。

```py
  def bayesposterior(prior, likelihood, evidence, string):
      print('Prior=', prior),
      print('Likelihood=', likelihood),
      print('Evidence=', evidence),
      print('Equation =','(Prior*Likelihood)/Evidence')
      print(string, (prior*likelihood)/evidence)

```

**让我们看看另一种方法，使用 Python 中的列联表来找到后验概率：**

```py
ct = pd.crosstab(tennis['outlook'], tennis['play'], margins = True)
print(ct)

```

```py
 no  yes  rowtotal
overcast   0    4         4
rainy      2    3         5
sunny      3    2         5
coltotal   5    9        14 
```

```py
ct.columns = ["no","yes","rowtotal"]
ct.index= ["overcast","rainy","sunny","coltotal"]
ct / ct.loc["coltotal","rowtotal"]

```

|  | 否 | 是 | 行总计 |
| --- | --- | --- | --- |
| 阴天 | 0.000000 | 0.285714 | 0.285714 |
| 多云 | 0.000000 | 0.285714 | 0.285714 |
| 晴天 | 0.214286 | 0.142857 | 0.357143 |
| 列总计 | 0.357143 | 0.642857 | 1.000000 |

仅获取列总计

```py
ct / ct.loc["coltotal"]

```

|  | 否 | 是 | 行总计 |
| --- | --- | --- | --- |
| 阴天 | 0.0 | 0.444444 | 0.285714 |
| 多云 | 0.4 | 0.333333 | 0.357143 |
| 晴天 | 0.6 | 0.222222 | 0.357143 |
| 列总计 | 1.0 | 1.000000 | 1.000000 |

仅获取行总计

```py
ct.div(ct["rowtotal"], axis=0)

```

|  | 否 | 是 | 行总计 |
| --- | --- | --- | --- |
| 阴天 | 0.000000 | 1.000000 | 1.0 |
| 多云 | 0.400000 | 0.600000 | 1.0 |
| 晴天 | 0.600000 | 0.400000 | 1.0 |
| 列总计 | 0.357143 | 0.642857 | 1.0 |

这些表格都是 pandas 数据框对象。因此，使用 pandas 子集和我创建的 `bayesposterior` 函数，我们可以得出相同的结论：

```py
bayesposterior(prior = ct.iloc[1,1]/ct.iloc[3,1],
               likelihood = ct.iloc[3,1]/ct.iloc[3,2],
               evidence = ct.iloc[1,2]/ct.iloc[3,2],
               string = 'Probability of Tennis given Rain =')

```

```py
 Prior= 0.3333333333333333
Likelihood= 0.6428571428571429
Evidence= 0.35714285714285715
Equation = (Prior*Likelihood)/Evidence
Probability of Tennis given Rain = 0.6 
```

### 朴素贝叶斯算法

[朴素贝叶斯](https://www.kdnuggets.com/2020/06/naive-bayes-algorithm-everything.html)是一种受贝叶斯定理启发的监督式机器学习算法。它基于条件概率原理工作。朴素贝叶斯是一种用于二分类和多分类的分类算法。朴素贝叶斯算法使用每个属性属于每个类别的概率来进行预测。

**示例**

当天气晴朗、炎热、高湿和多风时打网球的概率是多少？因此，使用网球数据集，我们需要使用朴素贝叶斯方法来预测在提到的天气条件下有人打网球的概率。

```py
pd.crosstab(tennis['outlook'], tennis['play'], margins = True)

```

| 玩耍 | 否 | 是 | 所有 |
| --- | --- | --- | --- |
| 展望 |  |  |  |
| --- | --- | --- | --- |
| 阴天 | 0 | 4 | 4 |
| 雨天 | 2 | 3 | 5 |
| 晴天 | 3 | 2 | 5 |
| 全部 | 5 | 9 | 14 |

```py
pd.crosstab(tennis['temp'], tennis['play'], margins = True)

```

| 游戏 | 否 | 是 | 全部 |
| --- | --- | --- | --- |
| 温度 |  |  |  |
| --- | --- | --- | --- |
| 凉爽 | 1 | 3 | 4 |
| 热 | 2 | 2 | 4 |
| 温和 | 2 | 4 | 6 |
| 全部 | 5 | 9 | 14 |

```py
pd.crosstab(tennis['humidity'], tennis['play'], margins = True)

```

| 游戏 | 否 | 是 | 全部 |
| --- | --- | --- | --- |
| 湿度 |  |  |  |
| --- | --- | --- | --- |
| 高 | 4 | 3 | 7 |
| 正常 | 1 | 6 | 7 |
| 全部 | 5 | 9 | 14 |

```py
pd.crosstab(tennis['windy'], tennis['play'], margins = True)

```

| 游戏 | 否 | 是 | 全部 |
| --- | --- | --- | --- |
| 有风 |  |  |  |
| --- | --- | --- | --- |
| 假 | 2 | 6 | 8 |
| 真 | 3 | 3 | 6 |
| 全部 | 5 | 9 | 14 |

```py
pd.crosstab(index=tennis['play'],columns="count", margins=True)

```

| col_0 | 计数 | 全部 |
| --- | --- | --- |
| 游戏 |  |  |
| --- | --- | --- |
| 否 | 5 | 5 |
| 是 | 9 | 9 |
| 全部 | 14 | 14 |

现在通过使用上述列联表，我们将深入探讨朴素贝叶斯算法如何计算后验概率。

1.  1.  计算P(x|play=yes)。在这种情况下，x指的是所有预测变量“outlook”、“temp”、“humidity”和“windy”。

        1.  P(sunny|play=yes)→2/9

        1.  P(hot|play=yes)→2/9

        1.  P(high|play=yes)→3/9

        1.  P(True|play=yes)→3/9

![公式](../Images/bec5c1f801cc9c8ccf92a161c9dca547.png)

```py
p_x_yes = ((2/9)*(2/9)*(3/9)*(3/9))
print('The probability of the predictors given playing tennis is', '%.3f'%p_x_yes)

```

```py
 The probability of the predictors given playing tennis is 0.005 
```

1.  1.  使用上述相同方法计算P(x|play=no)。

        1.  P(sunny|play=no)→3/5

        1.  P(hot|play=no)→2/5

        1.  P(high|play=no)→4/5

        1.  P(True|play=no)→3/5

![公式](../Images/70fbd367eb381cbabb572a825d6e53c7.png)

```py
p_x_no = ((3/5)*(2/5)*(4/5)*(3/5))
print('The probability of the predictors given not playing tennis is ', '%.3f'%p_x_no)

```

```py
 The probability of the predictors given not playing tennis is  0.115 
```

1.  1.  计算P(play=yes)和P(play=no)

        1.  P(play=yes)→9/14

        1.  P(play=yes)→5/14

```py
yes = (9/14)
no = (5/14)
print('The probability of playing tennis is', '%.3f'% yes)
print('The probability of not playing tennis is', '%.3f'% no)

```

```py
 The probability of playing tennis is 0.643
The probability of not playing tennis is 0.357 
```

1.  1.  计算在给定预测变量的情况下打网球和不打网球的概率

![公式](../Images/d596883dd6ccbaa6b96ac83242bc7a7e.png)![公式](../Images/a434b4dc81a82288a4e9667dfd955778.png)

```py
yes_x = p_x_yes*yes
print('The probability of playing tennis given the predictors is', '%.3f'%yes_x)

no_x = p_x_no*no
print('The probability of not playing tennis given the predictors is', '%.3f'%no_x)

```

```py
 The probability of playing tennis given the predictors is 0.004
  The probability of not playing tennis given the predictors is 0.041 
```

1.  1.  预测将是概率较高的结果

```py
if yes_x > no_x:
  print('The probability of playing tennis when the outlook is sunny, the temperature is hot, there is high humidity and windy is higher')
else:
  print('The probability of not playing tennis when the outlook is sunny, the temperature is hot, there is high humidity and windy is higher')

```

```py
The probability of not playing tennis is higher when the outlook is sunny, the temperature is hot, there is high humidity and it is windy. 

```

### 朴素贝叶斯算法的类型

Python的Scikit-learn为用户提供了以下三种朴素贝叶斯模型。

1.  高斯

    +   高斯朴素贝叶斯算法假设所有连续特征（预测变量）都遵循高斯（正态）分布。

1.  多项式

    +   多项式朴素贝叶斯适用于具有频率和计数的离散数据。垃圾邮件过滤和文本/文档分类是两个非常著名的应用场景。

1.  伯努利

    +   伯努利与多项式类似，只不过它用于布尔/二元特征。像多项式方法一样，它可以用于垃圾邮件过滤和文档分类，其中二元术语（即在文档中表示的单词出现情况为真或假）。

让我们用Scikit-learn实现一个多项式和高斯模型

```py
from sklearn.naive_bayes import GaussianNB, BernoulliNB, MultinomialNB
from sklearn.model_selection import train_test_split
from sklearn.metrics import *

```

### 更多相关话题

+   [高斯朴素贝叶斯，详解](https://www.kdnuggets.com/2023/03/gaussian-naive-bayes-explained.html)

+   [朴素贝叶斯算法：你需要知道的一切](https://www.kdnuggets.com/2020/06/naive-bayes-algorithm-everything.html)

+   [KDnuggets新闻，4月13日：数据科学家应了解的Python库](https://www.kdnuggets.com/2022/n15.html)

+   [更多分类问题的性能评估指标](https://www.kdnuggets.com/2020/04/performance-evaluation-metrics-classification.html)

+   [使用 Tensorflow 训练图像分类模型指南](https://www.kdnuggets.com/2022/12/guide-train-image-classification-model-tensorflow.html)

+   [理解分类指标：评估模型准确性的指南](https://www.kdnuggets.com/understanding-classification-metrics-your-guide-to-assessing-model-accuracy)
