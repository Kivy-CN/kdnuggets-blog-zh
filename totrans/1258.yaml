- en: 'Essential Math for Data Science: Introduction to Matrices and the Matrix Product'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2021/02/essential-math-data-science-matrices-matrix-product.html](https://www.kdnuggets.com/2021/02/essential-math-data-science-matrices-matrix-product.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[comments](#comments)[![Image](../Images/e6b504358bea8f63e781d7dbce4b4afc.png)](https://www.essentialmathfordatascience.com/?utm_source=kdnuggets&utm_medium=blog&utm_campaign=kdnuggets_scalars_vectors)'
  prefs: []
  type: TYPE_NORMAL
- en: Matrices and Tensors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you saw in [Essential Math for Data Science](https://bit.ly/3mpb4F2), vectors
    are a useful way to store and manipulate data. You can represent them geometrically
    as arrows, or as arrays of numbers (the coordinates of their ending points). However,
    it can be helpful to create more complicated data structures – and that is where
    matrices need to be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As vectors, *matrices* are data structures allowing you to organize numbers.
    They are square or rectangular arrays containing values organized in two dimensions:
    as rows and columns. You can think of them as a spreadsheet. Usually, you’ll see
    the term *matrix* in the context of math and *two-dimensional array* in the context
    of Numpy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dimensions**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the context of matrices, the term *dimension* is different from dimensions
    of the geometric representation of vectors (the dimensions of the space). When
    we say that a matrix is a two-dimensional array, it means that there are two *directions* in
    the array: the rows and the columns.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Matrix Notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, I’ll denote matrices with bold typeface and upper-case letters, like *A*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Equation](../Images/1e3859de92c28c620fd3fed24f7d6930.png)'
  prefs: []
  type: TYPE_IMG
- en: The matrix ***A*** has two rows and two columns but you can imagine matrices
    with any shape. More generally, if the matrix has *m* rows and *n* columns and
    contains real values, you can characterize it with the following notation: ![Equation](../Images/112c6ef1621e38c3cf294b5a45aa93fa.png)
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to matrix entries with the name of the matrix with no bold font
    (because the entries are scalars) followed by the index for the row and the index
    for the column separated by a comma in subscript. For instance, ***A[1,2]*** denotes
    the entry in the first row and the second column.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, the first index is for the row and the second for the column.
    For instance, the entry 2 in the matrix ***A*** above is located in the second
    row and the first column of the matrix ***A***, so it is denoted as ***A[2,1]*** (as
    shown in [Essential Math for Data Science](https://bit.ly/3mpb4F2), one-based
    indexing is generally used in mathematical notation).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write the matrix components as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Equation](../Images/41fe351b69e7443e4a2e970d96146437.png)'
  prefs: []
  type: TYPE_IMG
- en: Shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Figure](../Images/38a06d30eb7c3028aa971109720af4b3.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1: Matrices are two-dimensional arrays. The number of rows is usually
    denoted as mm and the number of columns as nn.*'
  prefs: []
  type: TYPE_NORMAL
- en: The *shape* of an array gives you the number of components in each dimension,
    as illustrated in Figure 1\. Since this matrix is two-dimensional (rows and columns),
    you need two values to describe the shape (the number of rows and the number of
    columns in this order).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a 2D Numpy array with the method `np.array()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use arrays in arrays (`[[]]`) to create the 2D array. This differs
    from creating a 1D array by the number of square brackets that you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like with vectors, it is possible to access the shape property of Numpy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the shape contains two numbers: they correspond to the number
    of rows and column respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get a matrix entry, you need two indexes: one to refer to the row index
    and one to refer to the column index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Numpy, the indexing process is the same to that of vectors. You just
    need to specify two indexes. Let’s take again the following matrix ***A***:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to get a specific entry with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`A[1, 2]` returns the component with the row index one and the column index
    two (with a zero-based indexing).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a complete column, it is possible to use a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the first column (index zero) because the colon says that we want
    the components from the first to the last rows. Similarly, to get a specific row,
    you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Being able to manipulate matrices containing data is an essential skill for
    data scientists. Checking the shape of your data is important to be sure that
    it is organized the way you want. It is also important to know the data shape
    you’ll need to use libraries like Sklearn or Tensorflow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default indexing**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you specify a single index from a 2D array, Numpy considers that
    it is for the first dimension (the rows) and all the values of the other dimension
    (the columns) are used. For instance
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'which is similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Vectors and Matrices**'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Numpy, if the array is a vector (1D Numpy array), the shape is a single
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that *v* is a vector. If it is a matrix, the shape has two numbers
    (the number of value in the rows and in the columns respectively). For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the matrix has a single row: the first number of the shape
    is 1\. Once again, using two square brackets, `[[` and `]]`, allows you to create
    a two-dimensional array (a matrix).'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You learn about the dot product in [Essential Math for Data Science](https://bit.ly/3mpb4F2).
    The equivalent operation for matrices is called the *matrix product*, or *matrix
    multiplication*. It takes two matrices and returns another matrix. This is a core
    operation in linear algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Matrices with Vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simpler case of matrix product is between a matrix and a vector (that you
    can consider as a matrix product with one of them having a single column).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure](../Images/1d9a37c4eec3a9c22944e02b7d36fb5d.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2: Steps of the product between a matrix and a vector.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2 illustrates the steps of the product between a matrix and a vector.
    Let’s consider the first row of the matrix. You do the dot product between the
    vector (the values 3 and 4 in red) and the row you’re considering (the values
    1 and 2 in blue). You multiply the values by pairs: the first value in the row
    with the first in the column vector (*1⋅3*), and the second in the row with the
    second in the vector (*2⋅4*). It gives you the first component of the resulting
    matrix (*1⋅3+2⋅4=11*).'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the matrix-vector product relates to the dot product. It is
    like splitting the matrix AA in three rows and applying the dot product (as in [Essential
    Math for Data Science](https://bit.ly/3mpb4F2)).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how it works with Numpy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used the `reshape()` function to reshape the vector into a 2 by
    1 matrix (the `-1` tells Numpy to guess the remaining number). Without it, you
    would end with a one-dimensional array instead of a two-dimensional array here
    (a matrix with a single column).
  prefs: []
  type: TYPE_NORMAL
- en: '**Weighting of the Matrix’s Columns**'
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to think about the matrix product. You can consider that
    the vector contains values that weight each column of the matrix. It clearly shows
    that the length of the vector needs to be equal to the number of columns of the
    matrix on which the vector is applied.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure](../Images/2f5351efa1f863fda83cb2261bcc47cb.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3: The vectors values are weighting the columns of the matrix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3 might help to visualize this concept. You can consider the vector values
    (3 and 4) as weights applied to the columns of the matrix. The rules about scalar
    multiplication that you saw earlier lead to the same results as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the last example, you can write the dot product between *A* and *v* as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Equation](../Images/64a2a6dec5c4de41ce3ffb16fad31515.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Equation](../Images/5df6bfdc1bba891269dcc265ee217033.png)'
  prefs: []
  type: TYPE_IMG
- en: This is important because, as you’ll see in more details in [Essential Math
    for Data Science](https://bit.ly/3mpb4F2), it shows that *Av* is a linear combination
    of the columns of *A* with the coefficients being the values from *v*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shapes**'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can see that the shapes of the matrix and the vector must match
    for the dot product to be possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure](../Images/a92e6f94c2a80bd7fdedab0971aa957a.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4: Shapes needed for the dot product between a matrix and a vector.*'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4 summarizes the shapes involved in the matrix-vector product and shows
    that the number of columns of the matrix must be equal to the number of rows of
    the vector.
  prefs: []
  type: TYPE_NORMAL
- en: Matrices Product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *matrix product* is the equivalent of the dot product operation for two
    matrices. As you’ll see, it is similar to the matrix-vector product, but applied
    to each column of the second matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure](../Images/a47ba608600705046e52abaecc6a54f0.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5: Matrix product.*'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5 shows you an example of matrix product. You can see that the resulting
    matrix has two columns, as the second matrix. The values of first column of the
    second matrix (3 and 4) weight the two columns and the result fills the first
    column of the resulting matrix. Similarly, the values of the second column of
    the second matrix (9 and 0) weight the two columns and the result fills the second
    column of the resulting matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Numpy, you can calculate the matrix product exactly as the dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Shapes**'
  prefs: []
  type: TYPE_NORMAL
- en: Like with the matrix-vector product and as illustrated in Figure 6, the number
    of columns of the first matrix must match the number of rows of the second matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure](../Images/53a3564daac9f13bc8cbefed22b8e52f.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6: Shapes must match for the dot product between two matrices.*'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting matrix has as many rows as the first matrix and as many columns
    as the second matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The matrices *A* and *B* have different shapes. Let’s calculate their dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can see the result of *A⋅B* is a 3 by 3 matrix. This shape comes from the
    number of rows of *A* (3) and the number of columns of *B* (3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Matrix Product to Calculate the Covariance Matrix**'
  prefs: []
  type: TYPE_NORMAL
- en: You can calculate the covariance matrix (more details about the covariance matrix
    in [Essential Math for Data Science](https://bit.ly/3mpb4F2)) of a dataset with
    the product between the matrix containing the variables and its transpose. Then,
    you divide by the number of observations (or this number minus one for the Bessel
    correction). You need to be sure that the variables are centered around zero beforehand
    (this can be done by subtracting the mean).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s simulate the following variables *x*, *y* and *z*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Numpy, the covariance matrix is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using the matrix product, you first need to stack the variables as columns
    of a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the variable `X` is a 100 by 3 matrix: the 100 rows correspond
    to the observations and the 3 columns to the features. Then, you center this matrix
    around zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you calculate the covariance matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You get a covariance matrix similar to the one from the function `np.cov()`.
    This is important to keep in mind that the dot product of a matrix with its transpose
    corresponds to the covariance matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Transpose of a Matrix Product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The transpose of the dot product between two matrices is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Equation](../Images/2aa29b7a5625a16da771e7d70883eb98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For instance, take the following matrices *A* and *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the result of ![Equation](../Images/83b1a0cdf30766ed77f5c2f846d1d054.png) and ![Equation](../Images/d6bdacd69456fc7dbd03d4b9b4fabb84.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This can be surprising at first that the order of the two vectors or matrices
    in the parentheses must change for the equivalence to be satisfy. Let’s look at
    the details of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure](../Images/f19e3a4ebad998abfa3e258d1619a770.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7: You must change the order of the vector and the matrix to obtain
    the transpose of the matrix product.*'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7 shows that the transpose of a matrix product is equal to the product
    of the transpose if you change the order of the vector and matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**More than two Matrices or Vectors**'
  prefs: []
  type: TYPE_NORMAL
- en: You can apply this property to more than two matrices or vectors. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '![Equation](../Images/31aefe885baae2573a91cb2ff2147dbe.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep this property in a corner of your mind. It explains many “cosmetic rearrangements”
    that you can encounter when matrices and vectors are manipulated. Trying these
    manipulations with code is a great way to learn.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, the matrix product is a key concept of linear algebra, and you
    will see in [Essential Math for Data Science](https://bit.ly/3mpb4F2) how it relates
    to space transformation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bio: [Hadrien Jean](https://hadrienj.github.io/)** is a machine learning
    scientist. He owns a Ph.D in cognitive science from the Ecole Normale Superieure,
    Paris, where he did research on auditory perception using behavioral and electrophysiological
    data. He previously worked in industry where he built deep learning pipelines
    for speech processing. At the corner of data science and environment, he works
    on projects about biodiversity assessement using deep learning applied to audio
    recordings. He also periodically creates content and teaches at Le Wagon (data
    science Bootcamp), and writes articles in his blog ([hadrienj.github.io](http://hadrienj.github.io)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Original](https://hadrienj.github.io/posts/Essential-Math-for-Data-Science-Introduction_to_matrices_and_matrix_product/).
    Reposted with permission.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Related:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Essential Math for Data Science: Probability Density and Probability Mass
    Functions](/2020/12/essential-math-data-science-probability-density-probability-mass-functions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Matrix Decomposition Decoded](/2020/12/matrix-decomposition-decoded.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Essential Math for Data Science: Information Theory](/2021/01/essential-math-data-science-information-theory.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Stop Learning Data Science to Find Purpose and Find Purpose to…](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Top Resources for Learning Statistics for Data Science](https://www.kdnuggets.com/2021/12/springboard-top-resources-learn-data-science-statistics.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The 5 Characteristics of a Successful Data Scientist](https://www.kdnuggets.com/2021/12/5-characteristics-successful-data-scientist.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Three R Libraries Every Data Scientist Should Know (Even if You Use Python)](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A $9B AI Failure, Examined](https://www.kdnuggets.com/2021/12/9b-ai-failure-examined.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Makes Python An Ideal Programming Language For Startups](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
