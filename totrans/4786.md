# 边界框的数据增强：重新思考物体检测的图像变换

> 原文：[https://www.kdnuggets.com/2018/09/data-augmentation-bounding-boxes-image-transforms.html/2](https://www.kdnuggets.com/2018/09/data-augmentation-bounding-boxes-image-transforms.html/2)

![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [评论](/2018/09/data-augmentation-object-detection-rethinking-image-transforms-bounding-boxes.html?page=2#comments)

### 随机水平翻转

首先，我们导入所有必要的内容，并确保即使我们从包含文件的文件夹外部调用函数，也能添加路径。以下代码放在`data_aug.py`文件中。

```py
import random
import numpy as np
import cv2
import matplotlib.pyplot as plt
import sys
import os

lib_path = os.path.join(os.path.realpath("."), "data_aug")
sys.path.append(lib_path)
```

数据增强将实现的是`RandomHorizontalFlip`，它以概率*p*水平翻转图像。

我们首先定义类，并定义它的`__init__`方法。初始化方法包含增广的参数。对于这个增广，参数是每张图像被翻转的概率。对于其他增广操作，如旋转，它可能包含对象要旋转的角度。

```py
class RandomHorizontalFlip(object):

    """Randomly horizontally flips the Image with the probability *p*

    Parameters
    ----------
    p: float
        The probability with which the image is flipped

    Returns
    -------

    numpy.ndaaray
        Flipped image in the numpy format of shape `HxWxC`

    numpy.ndarray
        Tranformed bounding box co-ordinates of the format `n x 4` where n is 
        number of bounding boxes and 4 represents `x1,y1,x2,y2` of the box

    """

    def __init__(self, p=0.5):
        self.p = p

```

函数的文档字符串是用*Numpy*文档格式编写的。这将有助于使用Sphinx生成文档。

每个函数的`__init__`方法用于定义增广的所有参数。然而，实际的增广逻辑在`__call__`函数中定义。

调用函数时，从类实例调用需要两个参数，`img`和`bboxes`，其中`img`是包含像素值的OpenCV numpy数组，`bboxes`是包含边界框注释的numpy数组。

`__call__`函数也返回相同的参数，这帮助我们将一系列增广操作链在一起，按顺序应用。

```py
def __call__(self, img, bboxes):
        img_center = np.array(img.shape[:2])[::-1]/2
        img_center = np.hstack((img_center, img_center))
        if random.random() < self.p:
            img =  img[:,::-1,:]
            bboxes[:,[0,2]] += 2*(img_center[[0,2]] - bboxes[:,[0,2]])

            box_w = abs(bboxes[:,0] - bboxes[:,2])

            bboxes[:,0] -= box_w
            bboxes[:,2] += box_w

        return img, bboxes
```

让我们逐步解析这里发生了什么。

在水平翻转中，我们围绕通过图像中心的垂直线旋转图像。

每个角的新的坐标可以描述为**在通过图像中心的垂直线上的角的镜像**。对于数学上感兴趣的人来说，**通过中心的垂直线将是连接原始角和新的变换角的线的垂直平分线**。

为了更好地理解发生了什么，请考虑下面的图像。变换图像的右半部分和原始图像的左半部分是关于中央线的镜像。

![](../Images/9746142705fcd6fba513a5ca22f10ae8.png)

上述操作由以下代码实现。

```py
img_center = np.array(img.shape[:2])[::-1]/2
img_center = np.hstack((img_center, img_center))
if random.random() < self.p:
   img =  img[:,::-1,:]
   bboxes[:,[0,2]] += 2*(img_center[[0,2]] - bboxes[:,[0,2]])
```

请注意，`img = img[:,::-1,:]`这一行基本上是对包含图像的数组进行操作，并反转其在第一个维度中的元素，即存储像素值的x坐标的维度。

然而，需要注意的是，左上角的镜像图像是结果框的右上角。实际上，结果坐标是边界框的右上角和左下角坐标。然而，我们需要它们以左上角和右下角格式表示。

![](../Images/ab97c08274eef2d4efac9d3e0a19fd1a.png)

我们代码的副作用

以下代码处理转换。

```py
box_w = abs(bboxes[:,0] - bboxes[:,2])
bboxes[:,0] -= box_w
bboxes[:,2] += box_w

```

我们最终返回图像和包含边界框的数组。

### *HorizontalFlip* 的确定性版本

上述代码以概率*p* 随机应用变换。然而，如果我们想构建一个确定性版本，可以简单地将参数*p* 设置为 1。或者我们可以编写另一个类，在其中完全没有参数*p*，并像这样实现`__call__`函数。

```py
def __call__(self, img, bboxes):
        img_center = np.array(img.shape[:2])[::-1]/2
        img_center = np.hstack((img_center, img_center))

        img =  img[:,::-1,:]
        bboxes[:,[0,2]] += 2*(img_center[[0,2]] - bboxes[:,[0,2]])

        box_w = abs(bboxes[:,0] - bboxes[:,2])

        bboxes[:,0] -= box_w
        bboxes[:,2] += box_w

    return img, bboxes
```

### 观察实际效果

现在，假设你需要在图像上使用*HorizontalFlip*增强。我们将其应用于一张图像，但你可以在任意数量的图像上使用。首先，我们创建一个文件`test.py`。我们开始导入所有需要的内容。

```py
from data_aug.data_aug import *
import cv2 
import pickle as pkl
import numpy as np 
import matplotlib.pyplot as plt
```

然后，我们导入图像并加载注释。

```py
img = cv2.imread("messi.jpg")[:,:,::-1] #OpenCV uses BGR channels
bboxes = pkl.load(open("messi_ann.pkl", "rb"))

#print(bboxes)   #visual inspection

```

为了检查我们的增强是否真的有效，我们定义了一个辅助函数`draw_rect`，它接受`img`和`bboxes`并返回一个 numpy 图像数组，上面绘制了边界框。

让我们创建一个文件`bbox_utils.py`并导入所需的内容。

```py
import cv2 
import numpy as np
```

现在，我们定义函数`draw_rect`

```py
def draw_rect(im, cords, color = None):
    """Draw the rectangle on the image

    Parameters
    ----------

    im : numpy.ndarray
        numpy image 

    cords: numpy.ndarray
        Numpy array containing bounding boxes of shape `N X 4` where N is the 
        number of bounding boxes and the bounding boxes are represented in the
        format `x1 y1 x2 y2`

    Returns
    -------

    numpy.ndarray
        numpy image with bounding boxes drawn on it

    """

    im = im.copy()

    cords = cords.reshape(-1,4)
    if not color:
        color = [255,255,255]
    for cord in cords:

        pt1, pt2 = (cord[0], cord[1]) , (cord[2], cord[3])

        pt1 = int(pt1[0]), int(pt1[1])
        pt2 = int(pt2[0]), int(pt2[1])

        im = cv2.rectangle(im.copy(), pt1, pt2, color, int(max(im.shape[:2])/200))
    return im
```

完成这些后，让我们回到`test.py`文件中，绘制原始的边界框。

```py
plt.imshow(draw_rect(img, bboxes))
```

这将生成如下图所示的结果。

![](../Images/8c6ead560f1bdbb932f6849e28fcaffb.png)

让我们看看我们的变换效果。

```py
hor_flip = RandomHorizontalFlip(1)  

img, bboxes = hor_flip(img, bboxes)

plt.imshow(draw_rect(img, bboxes))
```

你应该得到如下结果：

![](../Images/af813c433a38d666473552b2842c5e70.png)

### 收获的经验

+   边界框注释应该存储在一个大小为 N x 5 的 numpy 数组中，其中 N 是对象的数量，每个框由具有 5 个属性的行表示；**即左上角坐标、右下角坐标以及对象的类别。**

+   每种数据增强被定义为一个类，其中`__init__`方法用于定义增强的参数，而`__call__`方法描述增强的实际逻辑。它接受两个参数，图像`img`和边界框注释`bboxes`，并返回转换后的值。

这就是本文的内容。在下一篇文章中，我们将处理`Scale`和`Translate`增强。这些不仅是更复杂的变换，因为涉及更多的参数（缩放和翻译因子），而且还带来了一些我们在`HorizontalFlip`变换中未曾遇到的挑战。例如，要决定在增强后如果部分框在图像之外时是否保留该框。

**简历：[Ayoosh Kathuria](https://www.linkedin.com/in/ayoosh-kathuria-44a319132/)** 目前在印度国防研究与发展组织实习，致力于提高颗粒视频中的目标检测精度。当他不在工作时，他要么在睡觉，要么在弹吉他演奏 Pink Floyd。你可以在 [LinkedIn](https://www.linkedin.com/in/ayoosh-kathuria-44a319132/) 上与他联系，或在 [GitHub](https://github.com/ayooshkathuria) 上查看他的更多工作。

[原文](https://blog.paperspace.com/data-augmentation-for-bounding-boxes/)。已获许可转载。

**相关：**

+   [如何从零开始在 PyTorch 中实现 YOLO (v3) 目标检测器：第 1 部分](/2018/05/implement-yolo-v3-object-detector-pytorch-part-1.html)

+   [使用 Tensorflow 对象检测 API 构建玩具检测器](/2018/02/building-toy-detector-tensorflow-object-detection-api.html)

+   [开始使用 PyTorch 第 1 部分：理解自动微分的工作原理](/2018/04/getting-started-pytorch-understanding-automatic-differentiation.html)

* * *

## 我们的三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织进行 IT

* * *

### 更多相关主题

+   [边界框深度学习：视频标注的未来](https://www.kdnuggets.com/2022/07/bounding-box-deep-learning-future-video-annotation.html)

+   [IT 人员增补：人工智能如何改变软件开发行业](https://www.kdnuggets.com/2023/05/staff-augmentation-ai-changing-software-development-industry.html)

+   [语义向量搜索如何改变客户支持互动](https://www.kdnuggets.com/how-semantic-vector-search-transforms-customer-support-interactions)

+   [KDnuggets™ 新闻 22:n09, 3月2日：讲述一个伟大的数据故事：A…](https://www.kdnuggets.com/2022/n09.html)

+   [SQL 和对象关系映射（ORM）之间有什么区别？](https://www.kdnuggets.com/2022/02/difference-sql-object-relational-mapping-orm.html)

+   [数据科学中的异常检测技术初学者指南](https://www.kdnuggets.com/2023/05/beginner-guide-anomaly-detection-techniques-data-science.html)
