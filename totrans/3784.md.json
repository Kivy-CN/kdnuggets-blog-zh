["```py\n# Initialization\nmy_list = [1, 2, 3]\n\n# Indexing\nprint(my_list[0])        # output: 1\n\n# Appending\nmy_list.append(4)        # my_list becomes [1, 2, 3, 4]\n\n# Resizing\nmy_list.extend([5, 6])   # my_list becomes [1, 2, 3, 4, 5, 6]\n```", "```py\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n\n    def delete_node(self, key):\n        temp = self.head\n        if temp and temp.data == key:\n            self.head = temp.next\n            temp = None\n            return\n        prev = None\n        while temp and temp.data != key:\n            prev = temp\n            temp = temp.next\n        if temp is None:\n            return\n        prev.next = temp.next\n        temp = None\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=' ')\n            current = current.next\n        print()\n```", "```py\n# Create a new LinkedList\nmy_list = LinkedList()\n\n# Append nodes with data\nmy_list.append(10)\nmy_list.append(20)\nmy_list.append(30)\nmy_list.append(40)\nmy_list.append(50)\n\n# Print the current list\nprint(\"List after appending elements:\")\nmy_list.print_list()       # outputs: 10 20 30 40 50\n\n# Delete a node with data '30'\nmy_list.delete_node(30)\n\n# Print the list after deletion\nprint(\"List after deleting the node with value 30:\")\nmy_list.print_list()       # outputs: 10 20 40 50\n\n# Append another node\nmy_list.append(60) \n\n# Print the final state of the list\nprint(\"Final list after appending 60:\")\nmy_list.print_list()       # outputs: 10 20 40 50 60\n```", "```py\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insert(root, key):\n    if root is None:\n        return TreeNode(key)\n    else:\n        if root.val < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n\ndef search(root, key):\n    if root is None or root.val == key:\n        return root\n    if root.val < key:\n        return search(root.right, key)\n    return search(root.left, key)\n\ndef deleteNode(root, key):\n    if root is None:\n        return root\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif(key > root.val):\n        root.right = deleteNode(root.right, key)\n    else:\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n        temp = minValueNode(root.right)\n        root.val = temp.val\n        root.right = deleteNode(root.right, temp.val)\n    return root\n\ndef minValueNode(node):\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current\n```", "```py\n# Create the root node with an initial value\nroot = TreeNode(50)\n\n# Insert elements into the BST\ninsert(root, 30)\ninsert(root, 20)\ninsert(root, 40)\ninsert(root, 70)\ninsert(root, 60)\ninsert(root, 80)\n\n# Search for a value\nsearched_node = search(root, 70)\nif searched_node:\n    print(f\"Found node with value: {searched_node.val}\")\nelse:\n    print(\"Value not found in the BST.\")\n\n# output -> Found node with value: 70\n\n# Delete a node with no children\nroot = deleteNode(root, 20)\n\n# Attempt to search for the deleted node\nsearched_node = search(root, 20)\nif searched_node:\n    print(f\"Found node with value: {searched_node.val}\")\nelse:\n    print(\"Value not found in the BST - it was deleted.\")\n\n# output -> Value not found in the BST - it was deleted.\n```", "```py\n# Creating a hash table using a dictionary\nhash_table = {}\n\n# Inserting items\nhash_table['key1'] = 'value1'\nhash_table['key2'] = 'value2'\n\n# Handling collisions by chaining\nif 'key1' in hash_table:\n    if isinstance(hash_table['key1'], list):\n        hash_table['key1'].append('new_value1')\n    else:\n        hash_table['key1'] = [hash_table['key1'], 'new_value1']\nelse:\n    hash_table['key1'] = 'new_value1'\n\n# Retrieving items\nprint(hash_table['key1'])\n\n# output: can be 'value1' or a list of values in case of collision\n\n# Deleting items\ndel hash_table['key2']\n```"]