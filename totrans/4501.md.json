["```py\nfrom sklearn import datasets\nnp.random.seed(0)\nfeature_set, labels = datasets.make_moons(300, noise=0.20)\nplt.figure(figsize=(10,7))\nplt.scatter(feature_set[:,0], feature_set[:,1], c=labels, cmap=plt.cm.Spectral)\n```", "```py\nnum_examples = len(X) # training set size\nnn_input_dim = 2 # input layer dimensionality\nnn_output_dim = 2 # output layer dimensionality\n```", "```py\nepsilon = 0.01 # learning rate for gradient descent\nreg_lambda = 0.01 # regularization strength\n```", "```py\n# Helper function to evaluate the total loss on the dataset\ndef calculate_loss(model, X, y):\n    num_examples = len(X)  # training set size\n    W1, b1, W2, b2 = model['W1'], model['b1'], model['W2'], model['b2']\n    # Forward propagation to calculate our predictions\n    z1 = X.dot(W1) + b1\n    a1 = np.tanh(z1)\n    z2 = a1.dot(W2) + b2\n    exp_scores = np.exp(z2)\n    probs = exp_scores / np.sum(exp_scores, axis=1, keepdims=True)\n    # Calculating the loss\n    corect_logprobs = -np.log(probs[range(num_examples), y])\n    data_loss = np.sum(corect_logprobs)\n    # Add regulatization term to loss (optional)\n    data_loss += Config.reg_lambda / 2 * (np.sum(np.square(W1)) + np.sum(np.square(W2)))\n    return 1\\. / num_examples * data_loss\n```", "```py\ndef predict(model, x):\n    W1, b1, W2, b2 = model['W1'], model['b1'], model['W2'], model['b2']\n    # Forward propagation\n    z1 = x.dot(W1) + b1\n    a1 = np.tanh(z1)\n    z2 = a1.dot(W2) + b2\n    exp_scores = np.exp(z2)\n    probs = exp_scores / np.sum(exp_scores, axis=1, keepdims=True)\n    return np.argmax(probs, axis=1)\n```", "```py\ndef build_model(X, y, nn_hdim, num_passes=20000, print_loss=False):\n    # Initialize the parameters to random values. We need to learn these.\n    num_examples = len(X)\n    np.random.seed(0)\n    W1 = np.random.randn(Config.nn_input_dim, nn_hdim) / np.sqrt(Config.nn_input_dim)\n    b1 = np.zeros((1, nn_hdim))\n    W2 = np.random.randn(nn_hdim, Config.nn_output_dim) / np.sqrt(nn_hdim)\n    b2 = np.zeros((1, Config.nn_output_dim))# This is what we return at the end\n    model = {}# Gradient descent. For each batch...\n    for i in range(0, num_passes):# Forward propagation\n        z1 = X.dot(W1) + b1\n        a1 = np.tanh(z1)\n        z2 = a1.dot(W2) + b2\n        exp_scores = np.exp(z2)\n        probs = exp_scores / np.sum(exp_scores, axis=1, keepdims=True)# Backpropagation\n        delta3 = probs\n        delta3[range(num_examples), y] -= 1\n        dW2 = (a1.T).dot(delta3)\n        db2 = np.sum(delta3, axis=0, keepdims=True)\n        delta2 = delta3.dot(W2.T) * (1 - np.power(a1, 2))\n        dW1 = np.dot(X.T, delta2)\n        db1 = np.sum(delta2, axis=0)# Add regularization terms (b1 and b2 don't have regularization terms)\n        dW2 += Config.reg_lambda * W2\n        dW1 += Config.reg_lambda * W1# Gradient descent parameter update\n        W1 += -Config.epsilon * dW1\n        b1 += -Config.epsilon * db1\n        W2 += -Config.epsilon * dW2\n        b2 += -Config.epsilon * db2# Assign new parameters to the model\n        model = {'W1': W1, 'b1': b1, 'W2': W2, 'b2': b2}# Optionally print the loss.\n        # This is expensive because it uses the whole dataset, so we don't want to do it too often.\n        if print_loss and i % 1000 == 0:\n            print(\"Loss after iteration %i: %f\" % (i, calculate_loss(model, X, y)))return model\n```", "```py\ndef main():\n    X, y = generate_data()\n    model = build_model(X, y, 3, print_loss=True)\n    visualize(X, y, model)\n```", "```py\nhidden_layer_dimensions = [1, 2, 3, 4, 5, 20, 50] \nfor i, nn_hdim in enumerate(hidden_layer_dimensions): \n    plt.subplot(5, 2, i+1)\n    plt.title('Hidden Layer size %d' % nn_hdim)\n    model = build_model(X, y,nn_hdim, 20000, print_loss=False)\n    plot_decision_boundary(lambda x:predict(model,x), X, y) \n    plt.show()\n```"]