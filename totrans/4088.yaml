- en: 'Python Function Arguments: A Definitive Guide'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.kdnuggets.com/2023/02/python-function-arguments-definitive-guide.html](https://www.kdnuggets.com/2023/02/python-function-arguments-definitive-guide.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Python Function Arguments: A Definitive Guide](../Images/d9c4eae2eb65b627d7d7af25bef3cf00.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Like all programming languages, Python lets you define functions. After you’ve
    defined a function, you can call it wherever you need in the script, and also
    import a function from a specific module inside another module. Functions make
    your code *modular* and *reusable*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our Top 3 Course Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google Cybersecurity
    Certificate](https://www.kdnuggets.com/google-cybersecurity) - Get on the fast
    track to a career in cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google Data Analytics
    Professional Certificate](https://www.kdnuggets.com/google-data-analytics) - Up
    your data analytics game'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT Support
    Professional Certificate](https://www.kdnuggets.com/google-itsupport) - Support
    your organization in IT'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you can define functions to take in different types of arguments.
    And this guide will teach you all about function arguments in Python. Let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Review of Python Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define a  Python function, you can use the `def` keyword followed by the
    name of the function in parentheses. If you’d like the function to take in *arguments*,
    then the names of the arguments should be specified as *parameters* inside parentheses.
    After defining a function, you can call it with values for the parameters, called
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the definition of the `add()` function: `num1` and `num2`
    are the parameters and the values used for these parameters in the function call
    are the arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python Function Arguments: A Definitive Guide](../Images/9439ddfa1c8901bec106c19a2adcc0e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Parameters vs. Arguments | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Positional Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the following function `meet()`. It takes in three strings and prints
    out the info of the person.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the function with arguments, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In calling the function like this, the arguments are passed in as positional
    arguments. Positional arguments get mapped to the function parameters in the *same*
    order in which they appear in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the first, second, and third arguments in the function call are used
    as the values of `name`, `job_title`, and `city`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the output, 'Meet Artist, a John from Austin.', does not make
    sense. Here is where *keyword arguments* can help.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using keyword arguments in the function call, you should specify the *name*
    of the parameter and the *value* it takes.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify the keyword arguments in any order so long as the names of the
    parameters are correct. Let’s call the same function `meet()`, but this time with
    keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What if you’d like to use a mix of positional and keyword arguments? This will
    make your code less readable and is not recommended. But if you’re using both
    positional and keyword arguments in the function call, the positional arguments
    should *always* precede the keyword arguments. Otherwise, you’ll run into errors.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Functions with a Variable Number of Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we knew the number of arguments beforehand and defined the function
    accordingly. However, it may not always be the case. What if you'd like your function
    to take on a variable number of arguments each time it is called?
  prefs: []
  type: TYPE_NORMAL
- en: '![Python Function Arguments: A Definitive Guide](../Images/55eacdf8e0e782dbac43496538b6dbd1.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with Python code bases, you’ll have likely come across function
    definitions of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `*args` and `**kwargs` in the function definition, you can make the function
    take in a variable number of positional and keyword arguments, respectively. They
    work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`args` collects a variable number of positional arguments as a tuple, which
    can then be unpacked using the * unpacking operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kwargs` collects all the keyword arguments in the function call as a dictionary.
    These keyword arguments can then be unpacked using the ** operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note:** Using `*args` and `**kwargs` is not a strict requirement. You can
    use any name of your choice.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's take examples to understand this better.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Number of Positional Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The function `reverse_strings` takes in a variable number of strings and returns
    a list of reversed strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now call the function with one or more arguments as needed. Here are
    a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Variable Number of Keyword Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following function `running_sum()` takes in a variable number of keyword
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As `nums` is a Python dictionary, you can call the `items()` method on the dict
    object to get a list of tuples. Each tuple is a key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:** When using `*args` and `**kwargs`, the positional and keyword arguments
    are not required. Therefore, this is one way you can make your function arguments
    *optional*.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using Default Values for Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When defining Python functions, you can provide default values for one or more
    parameters. If you provide a default value for a specific parameter, you don’t
    have to use the argument in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: If the argument corresponding to the parameter is provided in the function call,
    that value is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Else, the default value is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following example, the function `greet()` has a parameter, `name`, set
    to a default value of "there".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So when you call `greet()` with a specific string as the argument, its value
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When you don’t pass in the name string, the default argument "there" is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Mutable Default Arguments - The Curious Case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using default arguments, you should be careful to not set the default value
    to a mutable object. But why? Let's take an example to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '![Python Function Arguments: A Definitive Guide](../Images/7f0a4e840c1868954a962604a59fd92d.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author | Created on [imgflip](https://imgflip.com/)
  prefs: []
  type: TYPE_NORMAL
- en: The following function `append_to_list()` takes in an element and a list as
    the arguments. It appends the element to the end of the list and returns the resultant
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You’d expect the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: When the function is called with *both* the element and the list, it returns
    the list containing the element appended to the end of the original list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you call the function with *only* the elements the argument, then it returns
    a list containing only that element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But let’s see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your terminal, run `python -i` to start a Python REPL. I’ve defined
    the `append_to_list()` function in the `def_args.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When you call the function with the number 4 and the list [1,2,3] as the arguments,
    we get [1,2,3,4], which is expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us make a series of function calls with only the element to be appended
    to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Wait, this isn’t what we expected. The first time the function is called with
    7 as the argument (without the list), we get [7]. However, in the next calls,
    we see that the elements are appended to *this* list.
  prefs: []
  type: TYPE_NORMAL
- en: This is because default arguments are bound to the function definition only
    once—at the time of defining the function. The list is first modified during the
    function call `append_to_list(7)`. The list is not empty anymore. And all subsequent
    calls to the function—without the list—will modify the original list.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you should avoid using mutable default arguments. A possible workaround
    is to set the default value to `None`, and initialize an empty list whenever the
    function call does not contain the list.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s a summary of what you’ve learned in this tutorial. You’ve learned how
    to call Python functions with positional and keyword arguments, and how to use
    `*args` and `**kwargs` to pass in a variable number of positional and keyword
    arguments, respectively. You then learned how to set default values for certain
    parameters and the curious case of mutable default arguments. I hope you found
    this tutorial helpful. Keep coding!
  prefs: []
  type: TYPE_NORMAL
- en: '**[Bala Priya C](https://twitter.com/balawc27)** is a technical writer who
    enjoys creating long-form content. Her areas of interest include math, programming,
    and data science. She shares her learning with the developer community by authoring
    tutorials, how-to guides, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: More On This Topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[The Definitive Guide To Switching Your Career Into Data Science](https://www.kdnuggets.com/2022/05/definitive-guide-switching-career-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Definitive Guide to Solving the Phantom Read in MySQL](https://www.kdnuggets.com/2022/06/definitive-guide-solving-phantom-read-mysql.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Beginner''s Guide to Pandas Melt Function](https://www.kdnuggets.com/2023/03/beginner-guide-pandas-melt-function.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5 Concepts You Should Know About Gradient Descent and Cost Function](https://www.kdnuggets.com/2020/05/5-concepts-gradient-descent-cost-function.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What is a Function?](https://www.kdnuggets.com/2022/11/function.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3 More SQL Aggregate Function Interview Questions for Data Science](https://www.kdnuggets.com/2023/01/3-sql-aggregate-function-interview-questions-data-science.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
