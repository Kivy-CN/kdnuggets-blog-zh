# 使用遗传算法优化人工神经网络与Python

> 原文：[https://www.kdnuggets.com/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html](https://www.kdnuggets.com/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html)

![c](../Images/3d9c022da2d331bb56691a9617b91b90.png) [评论](/2019/03/artificial-neural-networks-optimization-genetic-algorithm-python.html?page=2#comments)![实用计算机视觉应用深度学习](../Images/2d2eba3f4293703bd96266e9008105f8.png)

在之前的教程“**使用NumPy实现人工神经网络及分类Fruits360图像数据集**”中，创建了一个用于分类Fruits360图像数据集中4个类别的人工神经网络（ANN）。此教程中使用的源代码可在我的GitHub页面找到，链接为：[https://github.com/ahmedfgad/NumPyANN](https://github.com/ahmedfgad/NumPyANN)

本教程的快速总结是提取特征向量（360个bin的色调通道直方图），并使用基于滤波的技术通过标准差将其减少到仅102个元素。然后，使用NumPy从零开始构建ANN。

* * *

## 我们的前3个课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织在IT领域

* * *

ANN没有完全创建，只完成了前向传播，但没有反向传播用于更新网络权重。这就是为什么准确率非常低，未超过45%。解决这个问题的方法是使用优化技术来更新网络权重。本教程扩展了之前的内容，使用遗传算法（GA）来优化网络权重。

值得一提的是，之前和本教程都基于我2018年的书籍“**Ahmed Fawzy Gad 'Practical Computer Vision Applications Using Deep Learning with CNNs'. Dec. 2018, Apress, 978-1-4842-4167-7**”。这本书可以在Springer网站上找到，链接为：[https://springer.com/us/book/9781484241660](https://springer.com/us/book/9781484241660)。你可以在这本书中找到所有详细信息。

本教程中使用的源代码可以在我的 GitHub 页面找到，链接如下：[https://github.com/ahmedfgad/NeuralGenetic](https://github.com/ahmedfgad/NeuralGenetic)

### 阅读更多关于遗传算法的信息

在开始本教程之前，我建议阅读关于遗传算法如何工作以及如何使用 NumPy 从零开始在 Python 中实现的内容，这些可以在我之前的教程中找到，链接如下：

+   遗传算法优化介绍

    +   [https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/](https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/)

    +   [https://www.kdnuggets.com/2018/03/introduction-optimization-with-genetic-algorithm.html](/2018/03/introduction-optimization-with-genetic-algorithm.html)

    +   [https://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b](https://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b)

    +   [https://www.springer.com/us/book/9781484241660](https://www.springer.com/us/book/9781484241660)

+   遗传算法（GA）优化 - 逐步示例

    +   [https://www.slideshare.net/AhmedGadFCIT/genetic-algorithm-ga-optimization-stepbystep-example](https://www.slideshare.net/AhmedGadFCIT/genetic-algorithm-ga-optimization-stepbystep-example)

+   遗传算法在 Python 中的实现

    +   [https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/](https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/)

    +   [/2018/07/genetic-algorithm-implementation-python.html](/2018/07/genetic-algorithm-implementation-python.html)

    +   [https://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6](https://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6)

    +   [https://github.com/ahmedfgad/GeneticAlgorithmPython](https://github.com/ahmedfgad/GeneticAlgorithmPython)

在了解了遗传算法如何基于数值示例运行，并用 Python 实现后，我们可以开始使用遗传算法来优化人工神经网络（ANN），通过更新其权重（参数）。

### 使用遗传算法与人工神经网络（ANN）

遗传算法（GA）为给定问题创建多个解，并通过多个世代进化这些解。每个解包含所有可能有助于提高结果的参数。对于 ANN，所有层中的权重有助于实现高准确率。因此，GA 中的单个解将包含 ANN 中的所有权重。根据之前教程中讨论的网络结构和下图所示，ANN 有 4 层（1 输入层，2 隐藏层，1 输出层）。任何层中的权重都是同一个解的一部分。这样网络的单个解将包含总共 102x150+150x60+60x4=24,540 个权重。如果种群中有 8 个解，每个解有 24,540 个参数，那么整个种群中的参数总数为 24,540x8=196,320。

![artificial-neural-network](../Images/d3ee8682d9b41f4e59bad5b79e948a75.png)

从上面的图中可以看出，网络的参数以矩阵形式存在，因为这使得人工神经网络（ANN）的计算更为简便。对于每一层，都有一个相关的权重矩阵。只需将输入矩阵与给定层的参数矩阵相乘，即可返回该层的输出。遗传算法（GA）中的染色体是 1D 向量，因此我们需要将权重矩阵转换为 1D 向量。

由于矩阵乘法是处理 ANN 的一个好选项，我们在使用 ANN 时仍将 ANN 参数以矩阵形式表示。因此，矩阵形式用于处理 ANN，而向量形式用于处理 GA。这使得我们需要将矩阵转换为向量，反之亦然。下一个图总结了使用的步骤。

带有 ANN 的 GA。此图称为**主图**。

![figure-name](../Images/57ce8711167885fdd567d24b6587d7b0.png)

### 权重矩阵到 1D 向量

种群中的每个解决方案将有两种表示方式。首先是用于 GA 的 1D 向量，其次是用于 ANN 的矩阵。由于有 3 个权重矩阵用于 3 层（2 个隐藏层 + 1 个输出层），因此将有 3 个向量，每个矩阵一个。由于 GA 中的解决方案表示为单个 1D 向量，这 3 个单独的 1D 向量将被连接成一个单独的 1D 向量。每个解决方案将表示为长度为 24,540 的向量。下一个 Python 代码创建了一个名为**mat_to_vector()**的函数，用于将种群中所有解决方案的参数从矩阵转换为向量。

```py

def mat_to_vector(mat_pop_weights):
    pop_weights_vector = []
    for sol_idx in range(mat_pop_weights.shape[0]):
        curr_vector = []
        for layer_idx in range(mat_pop_weights.shape[1]):
            vector_weights = numpy.reshape(mat_pop_weights[sol_idx, layer_idx], newshape=(mat_pop_weights[sol_idx, layer_idx].size))
            curr_vector.extend(vector_weights)
        pop_weights_vector.append(curr_vector)
    return numpy.array(pop_weights_vector)

```

该函数接受一个表示所有解决方案种群的参数，以便遍历它们并返回其向量表示。在函数开始时，创建了一个名为**pop_weights_vector**的空列表变量，用于存放结果（所有解决方案的向量）。对于矩阵形式的每个解决方案，有一个内部循环遍历其三个矩阵。对于每个矩阵，使用**numpy.reshape()**函数将其转换为向量，该函数接受输入矩阵和矩阵要重新调整的输出大小。变量**curr_vector**接受单个解决方案的所有向量。在所有向量生成后，它们会被附加到**pop_weights_vector**变量中。

请注意，我们使用了**numpy.extend()**函数来处理属于同一解的向量，而**numpy.append()**则用于处理属于不同解的向量。原因在于，**numpy.extend()**将属于同一解的3个向量中的数字连接在一起。换句话说，调用此函数处理两个列表会返回一个新的单一列表，包含两个列表中的所有数字。这适用于为每个解创建一个1D染色体。但**numpy.append()**会返回每个解的三个列表。调用它处理两个列表时，会返回一个新列表，该列表被拆分为两个子列表。这不是我们的目标。最后，函数**mat_to_vector()**将种群解返回为一个NumPy数组，方便后续操作。

### 实现GA步骤

在将所有解从矩阵转换为向量并将其连接在一起之后，我们就准备好按照标题为**“遗传算法优化简介”**的教程中讨论的GA步骤进行操作。这些步骤在**主图**中展示，并在下图中总结。

![genetic-algorithm-steps](../Images/6ab6d32f52e77336c2e67f65d9e0058b.png)

请记住，GA使用适应度函数为每个解返回一个适应度值。适应度值越高，解越好。最佳解在**父代选择**步骤中作为父代返回。

对于分类器（如ANN）而言，常见的适应度函数之一是准确率。它是正确分类样本与样本总数之间的比例。根据下面的公式进行计算。每个解的分类准确率根据**主图**中的步骤进行计算。

![Equation](../Images/e8768f7eb7deeb08cb4bd8ca72e54f27.png)

每个解的单一1D向量被转换回3个矩阵，每层一个矩阵（2个隐藏层和1个输出层）。转换通过一个名为**vector_to_mat()**的函数完成。这个函数在下面的代码中定义。

```py

def vector_to_mat(vector_pop_weights, mat_pop_weights):

    mat_weights = []

    for sol_idx in range(mat_pop_weights.shape[0]):

        start = 0

        end = 0

        for layer_idx in range(mat_pop_weights.shape[1]):

            end = end + mat_pop_weights[sol_idx, layer_idx].size

            curr_vector = vector_pop_weights[sol_idx, start:end]

            mat_layer_weights = numpy.reshape(curr_vector, newshape=(mat_pop_weights[sol_idx, layer_idx].shape))

            mat_weights.append(mat_layer_weights)

            start = end

    return numpy.reshape(mat_weights, newshape=mat_pop_weights.shape)

```

它会逆转之前完成的工作。但有一个重要的问题。如果给定解的向量只有一块，我们如何将其拆分为三个不同的部分，每部分代表一个矩阵？输入层和隐藏层之间的第一个参数矩阵的大小为102x150。当它被转换成向量时，其长度将为15,300。因为它是根据**mat_to_vector()**函数插入**curr_vector**变量的第一个向量，所以其索引从0开始，直到15,299。**mat_pop_weights**用作**vector_to_mat()**函数的参数，以确定每个矩阵的大小。我们不关心使用**mat_pop_weights**变量中的权重，只需要从中获取矩阵的大小。

对于相同解决方案中的第二个向量，它将是将一个 150x60 的矩阵转换后的结果。因此，向量长度为 9,000。这样的向量被插入到**curr_vector**变量中，紧接在长度为 15,300 的前一个向量之前。因此，它将从索引 15,300 开始，结束于索引 15,300+9,000-1=24,299。-1 是因为 Python 从 0 开始索引。对于从 60x4 大小的参数矩阵中创建的最后一个向量，它的长度为 240。因为它被添加到**curr_vector**变量中，正好在前一个长度为 9,000 的向量之后，因此它的索引将从该位置开始。即起始索引为 24,300，结束索引为 24,300+240-1=24,539。因此，我们可以成功地将向量恢复到原始的 3 个矩阵中。

返回的每个解决方案的矩阵用于预测用于数据集中的 1,962 个样本的类别标签，以计算准确性。这是通过**predict_outputs()**和**fitness()**两个函数完成的，具体见下代码。

```py

def predict_outputs(weights_mat, data_inputs, data_outputs, activation="relu"):

    predictions = numpy.zeros(shape=(data_inputs.shape[0]))

    for sample_idx in range(data_inputs.shape[0]):

        r1 = data_inputs[sample_idx, :]

        for curr_weights in weights_mat:

            r1 = numpy.matmul(a=r1, b=curr_weights)

            if activation == "relu":

                r1 = relu(r1)

            elif activation == "sigmoid":

                r1 = sigmoid(r1)

        predicted_label = numpy.where(r1 == numpy.max(r1))[0][0]

        predictions[sample_idx] = predicted_label

    correct_predictions = numpy.where(predictions == data_outputs)[0].size

    accuracy = (correct_predictions/data_outputs.size)*100

    return accuracy, predictions

def fitness(weights_mat, data_inputs, data_outputs, activation="relu"):

    accuracy = numpy.empty(shape=(weights_mat.shape[0]))

    for sol_idx in range(weights_mat.shape[0]):

        curr_sol_mat = weights_mat[sol_idx, :]

        accuracy[sol_idx], _ = predict_outputs(curr_sol_mat, data_inputs, data_outputs, activation=activation)

    return accuracy

```

**predict_outputs()**函数接受单个解决方案的权重、输入和训练数据的输出，以及一个可选参数，指定使用哪个激活函数。它返回的只是一个解决方案的准确性，而不是种群中的所有解决方案。为了返回种群中所有解决方案的适应度值（即准确性），**fitness()**函数遍历每个解决方案，将其传递给**predict_outputs()**函数，将所有解决方案的准确性存储到**accuracy**数组中，并最终返回该数组。

在计算所有解决方案的适应度值（即准确性）后，GA 主图中的其余步骤以之前的方式应用。根据准确性选择最佳父代，进入交配池。然后应用变异和交叉变体以生成后代。新一代的种群是通过后代和父代一起创建的。这些步骤会在多个世代中重复进行。

### 更多相关内容

+   [使用管道编写干净的 Python 代码](https://www.kdnuggets.com/2021/12/write-clean-python-code-pipes.html)

+   [建立一个稳固的数据团队](https://www.kdnuggets.com/2021/12/build-solid-data-team.html)

+   [是什么让 Python 成为初创企业的理想编程语言](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)

+   [每个数据科学家都应该了解的三个 R 库（即使你使用 Python）](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)

+   [停止学习数据科学以寻找目标，并通过寻找目标…](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)

+   [成为伟大的数据科学家所需的 5 项关键技能](https://www.kdnuggets.com/2021/12/5-key-skills-needed-become-great-data-scientist.html)
