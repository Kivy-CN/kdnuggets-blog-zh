# 实现你自己的 k-最近邻算法使用 Python

> 原文：[https://www.kdnuggets.com/2016/01/implementing-your-own-knn-using-python.html/2](https://www.kdnuggets.com/2016/01/implementing-your-own-knn-using-python.html/2)

**测量所有案例之间的距离**

给定一个来自未知物种的新花朵，你希望根据它与其他花朵的相似度来分配一个物种。为此，你需要一种相似度测量方法。其中一种测量方法是欧几里得距离，其中两点 (a1, a2) 和 (b1, b2) 之间的距离 d 由 d = sqrt((a1-b1)^2 + (a2-b2)^2) 给出。每朵花在鸢尾花数据集中有 4 个维度（即 4 个特征），因此你需要编写一个函数来找出每朵花之间的距离。之前的距离公式可以推广到更高的维度，例如两点 (a1, a2, a3, a4) 和 (b1, b2, b3, b4) 之间的距离就是

我们将使用 zip 函数和列表推导式。zip 函数将来自列表（或其他可迭代对象，如字符串）的元素聚合起来，返回一个元组列表，例如 zip([1,2,3], [4,5,6]) 将返回 [(1,4), (2,5), (3,6)]。列表推导式是一个强大的 Pythonic 构造，可以快速对列表进行计算。例如，你可以用 [pow(x, 2) for x in range(101)] 快速获取从 1 到 100 的所有数字的平方，或者用 [x*2 for x in range(11) if x%2==1] 将 1 到 10 的奇数值翻倍。在这里，你将遍历两个数据点中对应维度的值，计算平方差，并将每个维度的平方差存储在 diffs_squared_distance 中。这些平方差会被求和并返回。

![欧几里得距离方程](../Images/90c059417c1578146bbf2fc73cf08172.png)

```py
import math

# 1) given two data points, calculate the euclidean distance between them
def get_distance(data1, data2):
    points = zip(data1, data2)
    diffs_squared_distance = [pow(a - b, 2) for (a, b) in points]
    return math.sqrt(sum(diffs_squared_distance))

```

例如，你现在可以获取前两个训练数据实例之间的距离：

```py
>>> get_distance(train[0][0], train[1][0])

4.052159917870962

```

或者你喜欢的任何其他元组：

```py
>>> get_distance([1,1], [2,3])

2.23606797749979

```

**获取所有邻居的距离**

接下来，需要一个返回测试用例与所有训练用例之间的排序距离的函数。一个解决方案是：

```py
from operator import itemgetter

def get_neighbours(training_set, test_instance, k):
    distances = [_get_tuple_distance(training_instance, test_instance) for training_instance in training_set]

    # index 1 is the calculated distance between training_instance and test_instance
    sorted_distances = sorted(distances, key=itemgetter(1))

    # extract only training instances
    sorted_training_instances = [tuple[0] for tuple in sorted_distances]

    # select first k elements
    return sorted_training_instances[:k]

def _get_tuple_distance(training_instance, test_instance):
    return (training_instance, get_distance(test_instance, training_instance[0]))

```

让我们来解剖这些函数：首先，你需要计算从任何给定测试数据点到训练集中的所有实例的距离。这可以通过对每个 training_instance 进行迭代来完成，并使用辅助函数 _get_tuple_distance（前导下划线表示该函数仅用于内部使用）来计算它与测试实例之间的距离。它还方便地返回它正在处理的训练实例（这一点的有用性稍后会显现）。要测试这个函数，可以尝试：

```py
>>> _get_tuple_distance(train[0], test[0][0])

(array([array([ 4.8, 3.4, 1.6, 0.2]), 0], dtype=object), 1.2328828005937953)

```

这将返回训练实例 train[0] 本身，随后是它与 test[0] 实例之间的距离 (1.23)。

这种逐对计算会对每个训练实例和给定测试实例进行。你可以通过这个命令来了解发生了什么：

```py
>>> [_get_tuple_distance(training_instance, test[0][0]) for training_instance in train[0:3]]

[(array([array([ 4.8, 3.4, 1.6, 0.2]), 0], dtype=object),
1.2328828005937953),
(array([array([ 5.7, 2.5, 5. , 2. ]), 2], dtype=object),
4.465422712353221),
(array([array([ 6.3, 2.7, 4.9, 1.8]), 2], dtype=object),
4.264973622427225)]

```

接下来，距离（例如这里的 1.23、4.47、4.26）被排序以找到与测试实例最接近的 k 个邻居。要了解如何返回排序后的距离，请尝试：

```py
>>> distances = [_get_tuple_distance(training_instance, test[0][0]) for training_instance in train[0:3]]
>>> sorted_distances = sorted(distances, key=itemgetter(1))
>>> [tuple[0] for tuple in sorted_distances]

[array([array([ 4.8, 3.4, 1.6, 0.2]), 0], dtype=object),
array([array([ 6.3, 2.7, 4.9, 1.8]), 2], dtype=object),
array([array([ 5.7, 2.5, 5. , 2. ]), 2], dtype=object)]

```

训练实例按照距离测试实例的远近排序。该函数接受 k 参数，用于控制返回多少个最近邻。

另外，相比于使用排序将测试案例的距离按递减顺序排列，计算上更便宜的是在距离列表中找到最大值——具体来说，排序的复杂度是 n log(n)，而遍历数组找最大值的复杂度是 O(n)。如果你在优化我们的脚本以提高效率（而不是专注于做教育演示），这些考虑将变得非常重要。

* * *

## 我们的前三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [谷歌网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [谷歌数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析技能

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [谷歌 IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你所在的组织的 IT 需求

* * *

### 更多相关话题

+   [从理论到实践：构建 k 最近邻分类器](https://www.kdnuggets.com/2023/06/theory-practice-building-knearest-neighbors-classifier.html)

+   [分类中的最近邻算法](https://www.kdnuggets.com/2022/04/nearest-neighbors-classification.html)

+   [Scikit-learn 中的 K 最近邻算法](https://www.kdnuggets.com/2022/07/knearest-neighbors-scikitlearn.html)

+   [LangChain 101：构建自己的 GPT 驱动应用](https://www.kdnuggets.com/2023/04/langchain-101-build-gptpowered-applications.html)

+   [使用 LlamaIndex 构建自己的 PandasAI](https://www.kdnuggets.com/build-your-own-pandasai-with-llamaindex)

+   [使用 ChatGPT 的 GPTs 创建自己的 GPT！](https://www.kdnuggets.com/make-your-own-gpts-with-chatgpts-gpts)
