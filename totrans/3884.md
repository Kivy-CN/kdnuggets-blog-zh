# fastcore: 一款被低估的 Python 库

> 原文：[https://www.kdnuggets.com/2020/10/fastcore-underrated-python-library.html](https://www.kdnuggets.com/2020/10/fastcore-underrated-python-library.html)

[评论](#comments)

**作者：[Hamel Husain](https://hamel.dev/)，GitHub 员工机器学习工程师**

![带代码的截图](../Images/bc8b7c0e278bb807e36cc708a9ab4dad.png)

* * *

## 我们的前三大课程推荐

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 1\. [Google 网络安全证书](https://www.kdnuggets.com/google-cybersecurity) - 快速进入网络安全职业生涯。

![](../Images/e225c49c3c91745821c8c0368bf04711.png) 2\. [Google 数据分析专业证书](https://www.kdnuggets.com/google-data-analytics) - 提升你的数据分析能力

![](../Images/0244c01ba9267c002ef39d4907e0b8fb.png) 3\. [Google IT 支持专业证书](https://www.kdnuggets.com/google-itsupport) - 支持你的组织的 IT 工作

* * *

### 背景

*我最近开始了一个提高我 Python 技能的旅程：我想学习高级模式、习语和技术。我开始阅读关于高级 Python 的书籍，然而，没有一个实际应用的地方，信息似乎很难记住。我还希望在学习过程中能向专家提问——这种安排很难找到！这时我想到：如果我能找到一个有相当高级 Python 代码的开源项目，并编写文档和测试呢？我打赌这样做会迫使我深入学习所有内容，而且维护者会欣赏我的工作，并愿意回答我的问题。*

而这正是我在过去一个月做的事情！我很高兴地报告，这是我经历过的最有效的学习经历。我发现编写文档迫使我不仅深入理解代码的作用，还要理解*代码为什么以这种方式工作*，并在编写测试时探索边界情况。最重要的是，当我遇到困难时，我能够提问，维护者愿意投入额外时间，知道他们的指导是为了使他们的代码更易于访问！结果证明，我选择的库，[fastcore](https://fastcore.fast.ai/)，是我遇到的最令人着迷的 Python 库，因为它的目的和目标相当独特。*

对于未曾接触过的人，[fastcore](https://fastcore.fast.ai/)是许多[fast.ai](https://github.com/fastai)项目构建的基础库。最重要的是，[fastcore](https://fastcore.fast.ai/)扩展了Python编程语言，并致力于消除冗余代码，为常见任务添加有用的功能。在这篇博客文章中，我将重点介绍fastcore提供的一些我最喜欢的工具，而不是分享我学到的Python知识。我的目标是激发你对这个库的兴趣，并希望在你阅读完之后，能激励你查看文档以了解更多内容！

### 为什么fastcore很有趣

*1.  **在不离开Python的情况下接触其他语言的思想：** 我一直听说学习其他语言有助于成为更好的程序员。从务实的角度来看，我发现学习其他语言很困难，因为我在工作中无法使用它们。Fastcore扩展了Python，包含了像Julia、Ruby和Haskell这样的语言中的模式。现在我了解了这些工具，我有动力去学习其他语言。*

1.  **你会获得一套新的务实工具**：fastcore包括一些工具，可以让你编写更简洁、更富有表现力的代码，并且可能解决新的问题。

1.  **了解更多关于Python编程语言的内容：** 因为fastcore扩展了Python编程语言，许多高级概念在这个过程中暴露出来。对于有动力的人来说，这是了解Python内部工作方式的一个好方法。

### 快速了解fastcore

*这里是一些使用fastcore立即吸引我注意的功能。*

### 让**kwargs**透明化

*每当我看到一个函数有参数****kwargs**时，我都会感到有些不安。这是因为这意味着API被混淆了，我必须阅读源代码才能搞清楚有效的参数可能是什么。考虑下面的例子：*

```py
def baz(a, b=2, c =3, d=4): return a + b + c

def foo(c, a, **kwargs):
    return c + baz(a, **kwargs)

inspect.signature(foo) 
```

```py
<Signature (c, a, **kwargs)>
```

如果不阅读源代码，我可能很难知道`foo`还接受额外的参数`b`和`d`。我们可以通过`delegates`来解决这个问题：

```py
def baz(a, b=2, c =3, d=4): return a + b + c

@delegates(baz) # this decorator will pass down keyword arguments from baz
def foo(c, a, **kwargs):
    return c + baz(a, **kwargs)

inspect.signature(foo) 
```

```py
<Signature (c, a, b=2, d=4)>
```

你可以自定义这个装饰器的行为。例如，你可以通过传递参数并保留`**kwargs`来同时实现“拥有蛋糕和吃掉它”的效果：

```py
@delegates(baz, keep=True)
def foo(c, a, **kwargs):
    return c + baz(a, **kwargs)

inspect.signature(foo) 
```

```py
<Signature (c, a, b=2, d=4, **kwargs)>
```

你还可以排除参数。例如，我们排除了参数`d`的委托：

```py
def basefoo(a, b=2, c =3, d=4): pass

@delegates(basefoo, but= ['d']) # exclude `d`
def foo(c, a, **kwargs): pass

inspect.signature(foo) 
```

```py
<Signature (c, a, b=2)>
```

你还可以在类之间进行委托：

```py
class BaseFoo:
    def __init__(self, e, c=2): pass

@delegates()# since no argument was passsed here we delegate to the superclass
class Foo(BaseFoo):
    def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs)

inspect.signature(Foo) 
```

```py
<Signature (a, b=1, c=2)>
```

欲了解更多信息，请阅读[关于委托的文档](https://fastcore.fast.ai/foundation.html#delegates)。

### 在设置实例属性时避免冗余代码

*你是否曾经想过是否有可能避免在`__init__`中设置属性时的冗余代码？*

```py
class Test:
    def __init__(self, a, b ,c): 
        self.a, self.b, self.c = a, b, c 
```

哎呀！这真是很痛苦。看看所有重复的变量名。我真的需要在定义类时重复自己吗？不再需要了！请查看[store_attr](https://fastcore.fast.ai/utils.html#store_attr)：

```py
class Test:
    def __init__(self, a, b, c): 
        store_attr()

t = Test(5,4,3)
assert t.b == 4 
```

你还可以排除某些属性：

```py
class Test:
    def __init__(self, a, b, c): 
        store_attr(but=['c'])

t = Test(5,4,3)
assert t.b == 4
assert not hasattr(t, 'c') 
```

还有许多自定义和使用`store_attr`的方法，超出了我在这里提到的范围。请查看[文档](https://fastcore.fast.ai/utils.html#store_attr)以获取更多详细信息。

附注：你可能会认为Python的[dataclasses](https://docs.python.org/3/library/dataclasses.html)也可以避免这些样板代码。虽然在某些情况下是这样，但`store_attr`更加灵活。^[1](https://fastpages.fast.ai/fastcore/#fn-1)

1. 例如，store_attr不依赖于继承，这意味着你在使用自己的类时不会陷入多重继承的问题。此外，与dataclasses不同，store_attr不需要Python 3.7或更高版本。此外，你可以在对象生命周期中的任何时候，以及在类中的任何位置使用store_attr，以自定义变量的存储行为和时机。[↩](https://fastpages.fast.ai/fastcore/#fnref-1)

### 避免子类化样板代码

*我讨厌Python中与子类化相关的`__super__().__init__()`样板代码。例如：

```py
class ParentClass:
    def __init__(self): self.some_attr = 'hello'

class ChildClass(ParentClass):
    def __init__(self):
        super().__init__()

cc = ChildClass()
assert cc.some_attr == 'hello' # only accessible b/c you used super 
```

我们可以通过使用元类[PrePostInitMeta](https://fastcore.fast.ai/foundation.html#PrePostInitMeta)来避免这些样板代码。我们定义了一个叫做`NewParent`的新类，它是`ParentClass`的一个包装器：

```py
class NewParent(ParentClass, metaclass=PrePostInitMeta):
    def __pre_init__(self, *args, **kwargs): super().__init__()

class ChildClass(NewParent):
    def __init__(self):pass

sc = ChildClass()
assert sc.some_attr == 'hello' 
```

### 类型调度

*类型调度，或者[多重调度](https://en.wikipedia.org/wiki/Multiple_dispatch#Julia)，允许你根据函数接收到的输入类型来改变函数的行为。这在一些编程语言中，如Julia，是一个显著的特性。例如，这是一个[概念示例](https://en.wikipedia.org/wiki/Multiple_dispatch#Julia)，展示了多重调度在Julia中的工作方式，根据x和y的输入类型返回不同的值：

```py
collide_with(x::Asteroid, y::Asteroid) = ... 
# deal with asteroid hitting asteroid

collide_with(x::Asteroid, y::Spaceship) = ... 
# deal with asteroid hitting spaceship

collide_with(x::Spaceship, y::Asteroid) = ... 
# deal with spaceship hitting asteroid

collide_with(x::Spaceship, y::Spaceship) = ... 
# deal with spaceship hitting spaceship 
```

类型调度在数据科学中尤其有用，你可能会允许不同的输入类型（即Numpy数组和Pandas数据框）传递给一个处理数据的函数。类型调度允许你为执行类似任务的函数提供一个通用的API。

不幸的是，Python本身不支持这一点。幸运的是，[@typedispatch](https://fastcore.fast.ai/dispatch.html#typedispatch-Decorator)装饰器可以派上用场。这个装饰器依赖于类型提示，以将输入路由到正确版本的函数：

```py
@typedispatch
def f(x:str, y:str): return f'{x}{y}'

@typedispatch
def f(x:np.ndarray): return x.sum()

@typedispatch
def f(x:int, y:int): return x+y 
```

下面是`f`函数类型调度工作的演示：

```py
f('Hello ', 'World!') 
```

```py
'Hello World!'
```

```py
f(2,3) 
```

```py
5
```

```py
f(np.array([5,5,5,5])) 
```

```py
20
```

这个功能有一些限制，还有其他使用此功能的方法，你可以在[这里阅读](https://fastcore.fast.ai/dispatch.html)。在学习类型调度的过程中，我还发现了一个叫做[multipledispatch](https://github.com/mrocklin/multipledispatch)的Python库，它是由[Mathhew Rocklin](https://github.com/mrocklin)（Dask的创建者）制作的。

使用了这个功能后，我现在有动力学习像Julia这样的语言，以发现我可能错过了哪些其他范式。

### functools.partial的更好版本

*`functools.partial` 是一个很好的工具，它从其他函数创建函数，并允许你设置默认值。以这个函数为例，它过滤列表，仅保留值大于等于 `val` 的项：

```py
test_input = [1,2,3,4,5,6]
def f(arr, val): 
    "Filter a list to remove any values that are less than val."
    return [x for x in arr if x >= val]

f(test_input, 3) 
```

```py
[3, 4, 5, 6]
```

你可以使用 `partial` 从这个函数创建一个新函数，将默认值设置为 5：

```py
filter5 = partial(f, val=5)
filter5(test_input) 
```

```py
[5, 6]
```

`partial` 的一个问题是它会移除原始文档字符串，并用一个通用的文档字符串替代：

```py
filter5.__doc__ 
```

```py
'partial(func, *args, **keywords) - new function with partial application\n    of the given arguments and keywords.\n'
```

[fastcore.utils.partialler](https://fastcore.fast.ai/utils.html#partialler) 解决了这个问题，并确保文档字符串被保留，从而使新 API 透明：

```py
filter5 = partialler(f, val=5)
filter5.__doc__ 
```

```py
'Filter a list to remove any values that are less than val.'
```

### 函数的组合

*在函数式编程语言中，广泛使用的一种技术是函数组合，通过将多个函数链在一起以实现某种结果。这在应用各种数据转换时特别有用。考虑一个简单的例子，我有三个函数：（1）移除列表中小于 5 的元素（来自前一节）（2）给每个数字加 2（3）对所有数字求和：

```py
def add(arr, val): return [x + val for x in arr]
def arrsum(arr): return sum(arr)

# See the previous section on partialler
add2 = partialler(add, val=2)

transform = compose(filter5, add2, arrsum)
transform([1,2,3,4,5,6]) 
```

```py
15
```

但这有什么用？你可能会想，我可以用以下方法实现同样的效果：

```py
arrsum(add2(filter5([1,2,3,4,5,6]))) 
```

你没有错！不过，组合为你提供了一个方便的接口，如果你想做如下操作时特别有用：

```py
def fit(x, transforms:list):
    "fit a model after performing transformations"
    x = compose(*transforms)(x)
    y = [np.mean(x)] * len(x) # its a dumb model.  Don't judge me
    return y

# filters out elements < 5, adds 2, then predicts the mean
fit(x=[1,2,3,4,5,6], transforms=[filter5, add2]) 
```

```py
[7.5, 7.5]
```

欲了解有关 `compose` 的更多信息，请阅读 [文档](https://fastcore.fast.ai/utils.html#compose)。

### 更有用的 `__repr__`

*在 Python 中，`__repr__` 帮助你获取有关对象的信息，用于日志记录和调试。下面是你在定义新类时默认获得的内容。（注意：我们使用了之前讨论过的 `store_attr`）。

```py
class Test:
    def __init__(self, a, b=2, c=3): store_attr() # `store_attr` was discussed previously

Test(1) 
```

```py
<__main__.Test at 0x7ffcd766cee0>
```

我们可以使用 [basic_repr](https://fastcore.fast.ai/utils.html#basic_repr) 来快速提供一个更合适的默认值：

```py
class Test:
    def __init__(self, a, b=2, c=3): store_attr() 
    __repr__ = basic_repr('a,b,c')

Test(2) 
```

```py
Test(a=2, b=2, c=3)
```

### 使用装饰器的 Monkey Patching

*使用装饰器进行 [monkey patch](https://www.geeksforgeeks.org/monkey-patching-in-python-dynamic-behavior/) 是很方便的，这在你想要修补你正在导入的外部库时特别有用。我们可以使用 [装饰器 @patch](https://fastcore.fast.ai/foundation.html#patch) 来自 `fastcore.foundation`，以及类型提示，如下所示：

```py
class MyClass(int): pass  

@patch
def func(self:MyClass, a): return self+a

mc = MyClass(3) 
```

现在，`MyClass` 有一个名为 `func` 的额外方法：

```py
mc.func(10) 
```

```py
13
```

仍然不信服？我将在下一节展示另一个这种补丁的例子。

### 更好的 pathlib.Path

*当你看到 [这些扩展](https://fastcore.fast.ai/utils.html#Extensions-to-Pathlib.Path) 时，你就不会再使用原生的 pathlib 了！许多额外的方法已被添加到 pathlib 中，例如：

+   `Path.readlines`：与 `with open('somefile', 'r') as f: f.readlines()` 相同

+   `Path.read`：与 `with open('somefile', 'r') as f: f.read()` 相同

+   `Path.save`：将文件保存为 pickle

+   `Path.load`：加载 pickle 文件

+   `Path.ls`：以列表形式显示路径的内容。

+   等等。

[在这里阅读更多内容](https://fastcore.fast.ai/utils.html#Extensions-to-Pathlib.Path)。这是 `ls` 的演示：

```py
from fastcore.utils import *
from pathlib import Path
p = Path('.')
p.ls() # you don't get this with vanilla Pathlib.Path!! 
```

```py
(#7) [Path('2020-09-01-fastcore.ipynb'),Path('README.md'),Path('fastcore_imgs'),Path('2020-02-20-test.ipynb'),Path('.ipynb_checkpoints'),Path('2020-02-21-introducing-fastpages.ipynb'),Path('my_icons')]
```

等等！这是怎么回事？我们刚刚导入了`pathlib.Path`，为什么会有这些新功能？那是因为我们导入了`fastcore.utils`模块，它通过前面讨论的`@patch`装饰器修补了这个模块。为了强调`@patch`装饰器的用处，我现在就再给`Path`添加一个方法：

```py
@patch
def fun(self:Path): return "This is fun!"

p.fun() 
```

```py
'This is fun!'
```

这很神奇，对吧？我知道！这就是为什么我写这篇文章的原因！

### 创建 Lambda 的一种更简洁的方法

*`Self`（大写的 S）是一种更简洁的方式来创建调用对象方法的 lambdas。例如，创建一个对 Numpy 数组求和的 lambda：

```py
arr=np.array([5,4,3,2,1])
f = lambda a: a.sum()
assert f(arr) == 15 
```

你可以以相同的方式使用`Self`：

```py
f = Self.sum()
assert f(arr) == 15 
```

让我们创建一个对 Pandas 数据框进行 groupby 和 max 的 lambda：

```py
import pandas as pd
df=pd.DataFrame({'Some Column': ['a', 'a', 'b', 'b', ], 
                 'Another Column': [5, 7, 50, 70]})

f = Self.groupby('Some Column').mean()
f(df) 
```

|  | 另一列 |
| --- | --- |
| 一些列 |  |
| --- | --- |
| a | 6 |
| b | 60 |

详细了解`Self`可以参考[文档](https://fastcore.fast.ai/utils.html#Self-(with-an-uppercase-S))。

### 笔记本函数

*这些很简单但很方便，让你知道代码是否在 Jupyter Notebook、Colab 或 Ipython Shell 中执行：

```py
from fastcore.imports import in_notebook, in_colab, in_ipython
in_notebook(), in_colab(), in_ipython() 
```

```py
(True, False, True)
```

如果你在代码中展示某些类型的可视化、进度条或动画，你可能会根据环境需要修改或切换这些内容，这时就很有用。

### 适用于列表的替代品

*你可能对 Python 的`list`已经很满意了。这是那种你不知道需要更好列表的情况，直到有人展示给你。试试`L`，一个拥有许多额外功能的类似列表的对象。

我最能描述`L`的方法是想象一下`list`和`numpy`有了一个漂亮的孩子：

定义一个列表（查看显示列表长度的漂亮`__repr__`！）

```py
L(1,2,3) 
```

```py
(#3) [1,2,3]
```

洗牌一个列表：

```py
p = L.range(20).shuffle()
p 
```

```py
(#20) [8,7,5,12,14,16,2,15,19,6...]
```

索引列表：

```py
p[2,4,6] 
```

```py
(#3) [5,14,2]
```

L 有合理的默认值，例如向列表中追加元素：

```py
1 + L(2,3,4) 
```

```py
(#4) [1,2,3,4]
```

`L`还有更多功能。阅读[文档](https://fastcore.fast.ai/foundation.html#Class-L-Methods)了解更多。

### 但等等……还有更多！

*![](../Images/df633329da955c1492c3d331c612e2aa.png)

我还有更多关于 fastcore 的内容想展示给你，但这些内容不太适合放在博客文章中。以下是一些我最喜欢但未在这篇博客中演示的内容：

### 工具

*[Utilities](https://fastcore.fast.ai/utils.html)部分包含许多快捷方式，用于执行常见任务或提供额外的接口，以扩展标准 Python 的功能。

+   [mk_class](https://fastcore.fast.ai/utils.html#mk_class)：快速向类中添加大量属性

+   [wrap_class](https://fastcore.fast.ai/utils.html#wrap_class)：通过简单的装饰器为类添加新方法

+   [groupby](https://fastcore.fast.ai/utils.html#groupby)：类似于 Scala 的 groupby

+   [merge](https://fastcore.fast.ai/utils.html#merge)：合并字典

+   [fasttuple](https://fastcore.fast.ai/utils.html#fastuple)：功能增强的元组

+   [Infinite Lists](https://fastcore.fast.ai/utils.html#Infinite-Lists)：用于填充和测试

+   [chunked](https://fastcore.fast.ai/utils.html#chunked)：用于批量和组织内容

### 多进程

*[Multiprocessing部分](http://fastcore.fast.ai/utils.html#Multiprocessing) 扩展了 Python 的 multiprocessing 库，提供了如：*

+   进度条

+   能够暂停以缓解与外部服务的竞争条件

+   在每个工作节点上批量处理事物，例如：如果你有一个分块进行的矢量化操作

### 函数式编程

*[函数式编程部分](http://fastcore.fast.ai/utils.html#Functions-on-Functions) 是我最喜欢的库部分。*

+   [maps](https://fastcore.fast.ai/utils.html#maps)：一个还组合函数的映射

+   [mapped](https://fastcore.fast.ai/utils.html#mapped)：一个更强大的 `map`

+   [using_attr](https://fastcore.fast.ai/utils.html#using_attr)：组合一个操作属性的函数

### 转换

*[Transforms](https://fastcore.fast.ai/transform.html) 是用于创建数据转换及相关管道的实用工具集。这些转换实用工具基于本文中讨论的许多构建块。*

### 进一步阅读

***应注意，你应该先阅读[文档的主页](https://fastcore.fast.ai/)，然后是关于[测试](https://fastcore.fast.ai/)的部分，以充分理解文档。***

+   [fastcore 文档网站](https://fastcore.fast.ai/)。

+   [fastcore GitHub 仓库](https://github.com/fastai/fastcore)。

+   关于[委派](https://www.fast.ai/2019/08/06/delegation/)的博客文章。

### 不好意思的推广：fastpages

*这篇博客文章完全在 Jupyter Notebook 中编写，GitHub 自动将其转换为博客文章！听起来有趣吗？[查看 fastpages](https://github.com/fastai/fastpages)。*

**简介：[Hamel Husain](https://hamel.dev/)** 是 GitHub 的高级机器学习工程师。

[原始文档](https://fastpages.fast.ai/fastcore/)。经许可转载。

**相关：**

+   [数据科学与 DevOps 的融合：使用 Jupyter、Git 和 Kubernetes 的 MLOps](/2020/08/data-science-meets-devops-mlops-jupyter-git-kubernetes.html)

+   [如何利用机器学习在 GitHub 上自动化任务以获得乐趣和利润](/2019/05/automate-tasks-github-machine-learning-fun-profit.html)

+   [自动化机器学习——加速数据科学家生产力的范式转变](/2017/07/automated-machine-learning-paradigm-shift.html)

### 更多相关主题

+   [使用管道编写干净的 Python 代码](https://www.kdnuggets.com/2021/12/write-clean-python-code-pipes.html)

+   [建立一个坚实的数据团队](https://www.kdnuggets.com/2021/12/build-solid-data-team.html)

+   [是什么使 Python 成为初创企业理想的编程语言](https://www.kdnuggets.com/2021/12/makes-python-ideal-programming-language-startups.html)

+   [每位数据科学家都应了解的三个 R 库（即使你使用 Python）](https://www.kdnuggets.com/2021/12/three-r-libraries-every-data-scientist-know-even-python.html)

+   [停止学习数据科学以寻找目标，并通过寻找目标来……](https://www.kdnuggets.com/2021/12/stop-learning-data-science-find-purpose.html)

+   [一个90亿美元的AI失败案例分析](https://www.kdnuggets.com/2021/12/9b-ai-failure-examined.html)
