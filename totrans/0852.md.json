["```py\nimport geopandas as gpd\nimport requests\nfrom io import BytesIO\n\n# Request the data from the SODA API\nreq = requests.get(\n    \"https://data.cityofnewyork.us/resource/gdww-crzy.geojson?stname_lab=BROADWAY\"\n)\n# Convert to a stream of bytes\nreqstrm = BytesIO(req.content)\n# Read the stream as a GeoDataFrame\nny_streets = gpd.read_file(reqstrm) \n```", "```py\n# Address to be geocoded\naddress = \"2709 Broadway, New York, NY 10025\"\nzipcode = address.split(\" \")[-1]\nstreet_num = address.split(\" \")[0]\n\n# Find street segments whose left side address ranges contain the street number\npotentials = ny_streets.loc[ny_streets[\"l_low_hn\"] < street_num]\npotentials = potentials.loc[potentials[\"l_high_hn\"] > street_num]\n# Find street segments whose zipcode matches the address'\npotentials = potentials.loc[potentials[\"l_zip\"] == zipcode]\n```", "```py\nimport numpy as np\nfrom shapely.geometry import Point\n\n# Calculate how far along the street to place the point\ndenom = (\n    potentials[\"l_high_hn\"].astype(float) - potentials[\"l_low_hn\"].astype(float)\n).values[0]\nnormalized_street_num = (\n    float(street_num) - potentials[\"l_low_hn\"].astype(float).values[0]\n) / denom\n\n# Define a point that far along the street\n# Move the line to start at (0,0)\npizza = np.array(potentials[\"geometry\"].values[0].coords[1]) - np.array(\n    potentials[\"geometry\"].values[0].coords[0]\n)\n# Multiply by normalized street number to get coordinates on line\npizza = pizza * normalized_street_num\n# Add starting segment to place line back on the map\npizza = pizza + np.array(potentials[\"geometry\"].values[0].coords[0])\n# Convert to geometry array for geopandas\npizza = gpd.GeoDataFrame(\n    {\"address\": [address], \"geometry\": [Point(pizza[0], pizza[1])]},\n    crs=ny_streets.crs,\n    geometry=\"geometry\",\n) \n```", "```py\n# Submit the address to the U.S. Census Bureau Geocoder REST API for processing\nresponse = requests.get(\n    \"https://geocoding.geo.census.gov/geocoder/locations/onelineaddress?address=2709+Broadway%2C+New+York%2C+NY+10025&benchmark=Public_AR_Current&format=json\"\n).json()\n```", "```py\n# Extract coordinates from the JSON file\ncoords = response[\"result\"][\"addressMatches\"][0][\"coordinates\"]\n# Convert coordinates to a Shapely Point\ncoords = Point(coords[\"x\"], coords[\"y\"])\n# Extract matched address\nmatched_address = response[\"result\"][\"addressMatches\"][0][\"matchedAddress\"]\n# Create a GeoDataFrame containing the results\npizza_point = gpd.GeoDataFrame(\n    {\"address\": [matched_address], \"geometry\": coords},\n    crs=ny_streets.crs,\n    geometry=\"geometry\",\n)\n```", "```py\n# Pull NYC park shapefiles\nparks = gpd.read_file(\n    BytesIO(\n        requests.get(\n            \"https://data.cityofnewyork.us/resource/enfh-gkve.geojson?$limit=5000\"\n        ).content\n    )\n)\n# Limit to parks with green area for a picnic\nparks = parks.loc[\n    parks[\"typecategory\"].isin(\n        [\n            \"Garden\",\n            \"Nature Area\",\n            \"Community Park\",\n            \"Neighborhood Park\",\n            \"Flagship Park\",\n        ]\n    )\n] \n```", "```py\n# Project the coordinates from latitude and longitude into meters for distance calculations\nbuffered_parks = parks.to_crs(epsg=2263)\npizza_point = pizza_point.to_crs(epsg=2263)\n# Add a buffer to the regions extending the border by 1/2 mile = 2640 feet\nbuffered_parks = buffered_parks.buffer(2640)\n# Find all parks whose buffered region contains the pizza parlor\npizza_parks = parks.loc[buffered_parks.contains(pizza_point[\"geometry\"].values[0])] \n```"]